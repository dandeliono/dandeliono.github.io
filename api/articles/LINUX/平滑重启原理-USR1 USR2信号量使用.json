{"title":"平滑重启原理-USR1 USR2信号量使用","uid":"6bea119b93beb5f935a855810bf39c07","slug":"LINUX/平滑重启原理-USR1 USR2信号量使用","date":"2024-06-17T19:32:18.000Z","updated":"2025-09-30T03:26:43.172Z","comments":true,"path":"api/articles/LINUX/平滑重启原理-USR1 USR2信号量使用.json","keywords":"XuGuangSheng","cover":"/covers/usr1-usr2.jpg","content":"<h1 id=\"平滑重启原理-USR1-USR2信号量使用\"><a href=\"#平滑重启原理-USR1-USR2信号量使用\" class=\"headerlink\" title=\"平滑重启原理-USR1 USR2信号量使用\"></a>平滑重启原理-USR1 USR2信号量使用</h1><p>在POSIX兼容的平台上，SIGUSR1和SIGUSR2是发送给一个进程的信号，它表示了用户定义的情况。<a href=\"https://so.csdn.net/so/search?q=nginx&spm=1001.2101.3001.7020\">nginx</a>常用信号量如下:</p>\n<p>| </p>\n<p>TERM, INT</p>\n<p> | </p>\n<p>Quick shutdown</p>\n<p> |<br>| </p>\n<p>QUIT</p>\n<p> | </p>\n<p>Graceful shutdown  优雅的关闭进程,即等请求结束后再关闭</p>\n<p> |<br>| </p>\n<p>HUP</p>\n<p> | </p>\n<p>Configuration reload ,Start the new worker processes with</p>\n<p> a new configuration Gracefully shutdown the old worker processes</p>\n<p>改变配置文件,平滑的重读配置文件</p>\n<p> |<br>| </p>\n<p>USR1</p>\n<p> | </p>\n<p>Reopen the log files 重读日志,在日志按月&#x2F;日分割时有用</p>\n<p> |<br>| </p>\n<p>USR2</p>\n<p> | </p>\n<p>Upgrade Executable on the fly 平滑的升级</p>\n<p> |<br>| </p>\n<p>WINCH</p>\n<p> | </p>\n<p>Gracefully shutdown the worker processes 优雅关闭旧的进程(配合USR2来进行升级)</p>\n<p> |</p>\n<h3 id=\"二、重启流程\"><a href=\"#二、重启流程\" class=\"headerlink\" title=\"二、重启流程\"></a>二、重启流程</h3><p>重启意味着新旧接替，在交接任务的过程中势必会存在新旧server并存的情形，因此，重启的流程大致为：</p>\n<ol>\n<li><p>启动新的server</p>\n</li>\n<li><p>新旧server并存，两者共同处理请求，提供服务</p>\n</li>\n<li><p>旧的server处理完所有的请求之后优雅退出</p>\n</li>\n</ol>\n<p>这里，最主要的问题在于如何保证新旧server可以并存，如果重启前后的server端口一致，如何保证两者可以监听同一端口。</p>\n<h3 id=\"三、nginx实现\"><a href=\"#三、nginx实现\" class=\"headerlink\" title=\"三、nginx实现\"></a>三、nginx实现</h3><p>1.为了验证nginx平滑重启，笔者首先尝试nginx启动的情形下再次开启一个新的server实例，结果如图：</p>\n<p><img src=\"https://img-blog.csdn.net/20170802103158212?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGhqY2VodXN0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p>\n<p>很明显，重新开启server实例是行不通的，原因在于新旧server使用了同一个端口80，在未开始socket reuseport选项复用端口时，bind系统调用会出错。nginx默认bind重试5次，失败后直接退出。而nginx需要监听IPV4地址0.0.0.0和IPV6地址[::]，故图中打印出10条emerg日志。</p>\n<p>2.接下来就开始尝试平滑重启命令了，一共两条命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -USR2 `cat /var/run/nginx.pid`kill -QUIT `cat /var/run/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>第一条命令是发送信号USR2给旧的master进程，进程的pid存放在&#x2F;var&#x2F;run&#x2F;nginx.pid文件中，其中nginx.pid文件路径由nginx.conf配置。</p>\n</li>\n<li><p>第二条命令是发送信号QUIT给旧的master进程，进程的pid存放在&#x2F;var&#x2F;run&#x2F;nginx.pid.oldbin文件中，随后旧的master进程退出。</p>\n</li>\n</ul>\n<p>那么问题来了，为什么旧的master进程的pid存在于两个pid文件之中？事实上，在发送信号USR2给旧的master进程之后，旧的master进程将pid重命名，原先的nginx.pid文件rename成nginx.pid.oldbin。这样新的master进行就可以使用nginx.pid这个文件名了。</p>\n<p>先执行第一条命令，结果如图： </p>\n<p><img src=\"https://img-blog.csdn.net/20170802103213872?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGhqY2VodXN0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p>\n<p>不错，新旧master和worker进程并存了。 再来第二条命令，结果如图: </p>\n<p><img src=\"https://img-blog.csdn.net/20170802103226979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGhqY2VodXN0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p>\n<p>如你所见，旧的master进程8527和其worker进程全部退出，只剩下新的master进程12740。</p>\n<p>不由得产生困惑，为什么手动开启一个新的实例行不通，使用信号重启就可以达到。先看下nginx log文件： </p>\n<p><img src=\"https://img-blog.csdn.net/20170802103246259?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGhqY2VodXN0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p>\n<p>除了之前的错误日志，还多了一条notice，意思就是继承了sockets，fd值为6，7。 随着日志翻看nginx源码，定位到nginx.c&#x2F;ngx_exec_new_binary函数之中，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)    ctx.name = &quot;new binary process&quot;;    env = ngx_set_environment(cycle, &amp;n);    var = ngx_alloc(sizeof(NGINX_VAR)                    + cycle-&gt;listening.nelts * (NGX_INT32_LEN + 1) + 2,    p = ngx_cpymem(var, NGINX_VAR &quot;=&quot;, sizeof(NGINX_VAR));    ls = cycle-&gt;listening.elts;for (i = 0; i &lt; cycle-&gt;listening.nelts; i++) &#123;        p = ngx_sprintf(p, &quot;%ud;&quot;, ls[i].fd);    ctx.envp = (char *const *) env;    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);if (ngx_rename_file(ccf-&gt;pid.data, ccf-&gt;oldpid.data) == NGX_FILE_ERROR) &#123;    pid = ngx_execute(cycle, &amp;ctx);if (pid == NGX_INVALID_PID) &#123;if (ngx_rename_file(ccf-&gt;oldpid.data, ccf-&gt;pid.data)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数的流程为</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>将旧的master进程监听的所有fd，拷贝至新master进程的env环境变量NGINX_VAR。</p>\n</li>\n<li><p>rename重命名pid文件</p>\n</li>\n<li><p>ngx_execute函数fork子进程，execve执行命令行启动新的server。</p>\n</li>\n</ul>\n<p>在server启动流程之中，涉及到环境变量NGINX_VAR的解析，ngx_connection.c&#x2F;ngx_add_inherited_sockets具体代码为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngx_add_inherited_sockets(ngx_cycle_t *cycle)    inherited = (u_char *) getenv(NGINX_VAR);if (ngx_array_init(&amp;cycle-&gt;listening, cycle-&gt;pool, 10,for (p = inherited, v = p; *p; p++) &#123;if (*p == &#x27;:&#x27; || *p == &#x27;;&#x27;) &#123;            ls = ngx_array_push(&amp;cycle-&gt;listening);            ngx_memzero(ls, sizeof(ngx_listening_t));            ls-&gt;fd = (ngx_socket_t) s;return ngx_set_inherited_sockets(cycle);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数流程为：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>解析环境变量NGINX_VAR的值，获取fd存入数组</p>\n</li>\n<li><p>fd对应的socket设为ngx_inherited，保存这些socket的信息。</p>\n</li>\n</ul>\n<p>也就是说，新的server压根就没重新bind端口listen，这些fd状态和值都是新的master进程fork时带过来的,新的master进程监听处理继承来的文件描述符即可，这里比较关键的一点在于listen socket文件描述符通过ENV传递。</p>\n<h3 id=\"四-切割日志\"><a href=\"#四-切割日志\" class=\"headerlink\" title=\"四.切割日志\"></a>四.切割日志</h3><p><strong>在linux中，一个文件对应一个节点，才是在磁盘上的真实位置。nginx在读取&#x2F;写入日志文件时，即便把日志文件改名了，还是指向那个节点(磁盘空间)。所以，要新建一个文件，再告诉nginx，读取&#x2F;写入新的日志文件。</strong> </p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS41MWN0by5jb20vaW1hZ2VzLzIwMTkwNTE4LzE1NTgxNjIxODk4NzcyNDkucG5n?x-oss-process=image/format,png\"></p>\n","text":"平滑重启原理-USR1 USR2信号量使用在POSIX兼容的平台上，SIGUSR1和SIGUSR2是发送给一个进程的信号，它表示了用户定义的情况。nginx常用...","permalink":"/post/LINUX/平滑重启原理-USR1 USR2信号量使用","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"nginx","slug":"nginx","count":3,"path":"api/categories/nginx.json"},{"name":"LINUX","slug":"nginx/LINUX","count":1,"path":"api/categories/nginx/LINUX.json"}],"tags":[{"name":"master","slug":"master","count":3,"path":"api/tags/master.json"},{"name":"server","slug":"server","count":3,"path":"api/tags/server.json"},{"name":"pid","slug":"pid","count":1,"path":"api/tags/pid.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E6%BB%91%E9%87%8D%E5%90%AF%E5%8E%9F%E7%90%86-USR1-USR2%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">平滑重启原理-USR1 USR2信号量使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E9%87%8D%E5%90%AF%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">二、重启流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81nginx%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">三、nginx实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B-%E5%88%87%E5%89%B2%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">四.切割日志</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"如何优雅的升级 Nginx（热部署）版本","uid":"ef5ca056fa60b2d5cee6602c81aa277f","slug":"MIDDLEWARE/如何优雅的升级 Nginx（热部署）版本","date":"2024-06-17T19:42:10.000Z","updated":"2025-09-30T03:26:54.289Z","comments":true,"path":"api/articles/MIDDLEWARE/如何优雅的升级 Nginx（热部署）版本.json","keywords":"XuGuangSheng","cover":"/covers/nginx.jpg","text":"如何优雅的升级 Nginx（热部署）版本1. 升级1.1. 下载、编译新版本的 Nginx12345➜ ~ wget https://nginx.org/dow...","permalink":"/post/MIDDLEWARE/如何优雅的升级 Nginx（热部署）版本","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Nginx","slug":"Nginx","count":1,"path":"api/categories/Nginx.json"},{"name":"MIDDLEWARE","slug":"Nginx/MIDDLEWARE","count":1,"path":"api/categories/Nginx/MIDDLEWARE.json"}],"tags":[{"name":"master","slug":"master","count":3,"path":"api/tags/master.json"},{"name":"进程","slug":"进程","count":1,"path":"api/tags/进程.json"},{"name":"worker","slug":"worker","count":1,"path":"api/tags/worker.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Shell脚本调试技术","uid":"5df6cb5002e831cbd9dddd37fc2dda58","slug":"LINUX/Shell脚本调试技术","date":"2024-06-12T15:15:07.000Z","updated":"2025-09-30T03:26:35.974Z","comments":true,"path":"api/articles/LINUX/Shell脚本调试技术.json","keywords":"XuGuangSheng","cover":"/covers/shell.jpg","text":"Shell脚本调试技术shell编程在unix/linux世界中使用得非常广泛，熟练掌握shell编程也是成为一名优秀的unix/linux开发者和系统管理员的...","permalink":"/post/LINUX/Shell脚本调试技术","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"shell","slug":"shell","count":2,"path":"api/categories/shell.json"},{"name":"LINUX","slug":"shell/LINUX","count":2,"path":"api/categories/shell/LINUX.json"}],"tags":[{"name":"使用","slug":"使用","count":5,"path":"api/tags/使用.json"},{"name":"DEBUG","slug":"DEBUG","count":1,"path":"api/tags/DEBUG.json"},{"name":"trap","slug":"trap","count":1,"path":"api/tags/trap.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}