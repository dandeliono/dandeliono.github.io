{"title":"深入理解“软中断”","uid":"f4563b96f26978111a4862bba321db8f","slug":"LINUX/深入理解“软中断”","date":"2022-02-02T19:27:00.000Z","updated":"2025-12-05T01:47:20.591Z","comments":true,"path":"api/articles/LINUX/深入理解“软中断”.json","keywords":"XuGuangSheng","cover":"/covers/bce1619d1231.jpg","content":"<h1 id=\"深入理解“软中断”\"><a href=\"#深入理解“软中断”\" class=\"headerlink\" title=\"深入理解“软中断”\"></a>深入理解“软中断”</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li>软中断（softirq）导致 CPU 使用率升高也是最常见的一种性能问题</li>\n<li>所以软中断这个硬骨头必须啃下去！</li>\n</ul>\n<h2 id=\"回忆下什么是中断\"><a href=\"#回忆下什么是中断\" class=\"headerlink\" title=\"回忆下什么是中断\"></a>回忆下什么是中断</h2><ul>\n<li>中断是系统用来响应硬件设备请求的一种机制</li>\n<li>它会<strong>打断</strong>进程的正常调度和执行</li>\n<li>然后调用内核中的中断处理程序来<strong>响应</strong>硬件设备的请求</li>\n</ul>\n<h3 id=\"场景类比，加深印象\"><a href=\"#场景类比，加深印象\" class=\"headerlink\" title=\"场景类比，加深印象\"></a>场景类比，加深印象</h3><p>比如说你订了一份外卖，但是不确定外卖什么时候送到，也没有别的方法了解外卖的进度， 但是，配送员送外卖是不等人的，到了你这儿没人取的话，就直接走人了；所以你只能苦苦等着，时不时去门口看看外卖送到没，而不能干其他事情；不过呢，如果在订外卖的时候，你就跟配送员约定好，让他送到后给你打个电话，那你就不用苦苦等待了，就可以去忙别的事情，直到电话一响，接电话、取外卖就可以了、</p>\n<ul>\n<li><strong>打电话：</strong> 其实就是一个中断，没接到电话的时候，你可以做其他的事情</li>\n<li>只有接到了电话（也就是发生中断），你才要进行另一个动作：<strong>取外卖</strong></li>\n</ul>\n<h3 id=\"中断的优势\"><a href=\"#中断的优势\" class=\"headerlink\" title=\"中断的优势\"></a>中断的优势</h3><p>一种异步的事件处理机制，可以提高系统的并发处理能力</p>\n<h3 id=\"中断运行时间短\"><a href=\"#中断运行时间短\" class=\"headerlink\" title=\"中断运行时间短\"></a>中断运行时间短</h3><ul>\n<li>由于中断处理程序<strong>会打断其他进程的运行</strong>，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行</li>\n<li>如果中断要处理的事情很多，中断服务程序就有可能要运行很长时间</li>\n</ul>\n<h3 id=\"中断处理程序在响应中断\"><a href=\"#中断处理程序在响应中断\" class=\"headerlink\" title=\"中断处理程序在响应中断\"></a>中断处理程序在<strong>响应中断</strong></h3><p>会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失</p>\n<h4 id=\"响应中断场景类比\"><a href=\"#响应中断场景类比\" class=\"headerlink\" title=\"响应中断场景类比\"></a>响应中断场景类比</h4><p>假如你订了 2 份外卖，一份主食和一份饮料，并且是由 2 个不同的配送员来配送。这次你不用时时等待着，两份外卖都约定了电话取外卖的方式。但是，问题又来了，当第一份外卖送到时，配送员给你打了个长长的电话，商量发票的处理方式。与此同时，第 二个配送员也到了，也想给你打电话。 但是很明显，因为电话占线（也就是<strong>关闭了中断响应</strong>），第二个配送员的电话是打不通的。 所以，第二个配送员很可能试几次后就走掉了（也就是<strong>丢失了一次中断</strong>）</p>\n<h2 id=\"软中断\"><a href=\"#软中断\" class=\"headerlink\" title=\"软中断\"></a>软中断</h2><h3 id=\"中断处理过程分割\"><a href=\"#中断处理过程分割\" class=\"headerlink\" title=\"中断处理过程分割\"></a>中断处理过程分割</h3><ul>\n<li><strong>为了解决中断处理程序执行过长和中断丢失的问题</strong>，Linux 会将中断处理过程<strong>分成两个阶段</strong>，也就是上半部和下半部</li>\n<li><strong>上半部：</strong> 快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作</li>\n<li><strong>下半部：</strong> 延迟处理上半部<strong>未完成</strong>的工作，通常以<strong>内核线程</strong>的方式运行</li>\n</ul>\n<h4 id=\"承上启下\"><a href=\"#承上启下\" class=\"headerlink\" title=\"承上启下\"></a>承上启下</h4><ul>\n<li>上面说到的响应中断场景</li>\n<li><strong>上半部</strong>就是你接听电话，告诉配送员你已经知道了，其他事儿见面再说，然后电话就可以挂断了</li>\n<li><strong>下半部</strong>才是取外卖的动作，以及见面后商量发票处理的动 作。</li>\n</ul>\n<h3 id=\"网卡接收数据包的栗子\"><a href=\"#网卡接收数据包的栗子\" class=\"headerlink\" title=\"网卡接收数据包的栗子\"></a>网卡接收数据包的栗子</h3><p>网卡接收到数据包后，会通过<strong>硬件中断</strong>的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它</p>\n<h4 id=\"上半部\"><a href=\"#上半部\" class=\"headerlink\" title=\"上半部\"></a><strong>上半部</strong></h4><ol>\n<li>快速处理</li>\n<li>首先，要把网卡的数据读到内存中</li>\n<li>然后，<strong>更新</strong>一下硬件寄存器的状态（表示数据已经读好了）</li>\n<li>最后，再发送一个<strong>软中断信号</strong>，<strong>通知下半部</strong>做进一步的处理</li>\n</ol>\n<h4 id=\"下半部\"><a href=\"#下半部\" class=\"headerlink\" title=\"下半部\"></a>下半部</h4><ol>\n<li>被软中断信号唤醒</li>\n<li>需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"上半部-1\"><a href=\"#上半部-1\" class=\"headerlink\" title=\"上半部\"></a><strong>上半部</strong></h4><ul>\n<li>直接处理<strong>硬件</strong>请求，也就是<strong>硬中断</strong></li>\n<li><strong>特点：</strong> 快速执行</li>\n<li>会打断 CPU 正在执行的任务，然后立即执行中断处理程序</li>\n</ul>\n<h4 id=\"下半部-1\"><a href=\"#下半部-1\" class=\"headerlink\" title=\"下半部\"></a>下半部</h4><ul>\n<li>由<strong>内核</strong>触发，也就是<strong>软中断</strong></li>\n<li><strong>特点：</strong> 延迟执行</li>\n<li>以内核线程的方式执行，并且<strong>每个 CPU 都对应一个软中断内核线程</strong>，名字为 “ksoftirqd&#x2F;CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd&#x2F;0</li>\n<li>不只包括了硬件设备中断处理程序的下半部，一些内核自定义的事件也属于软中断，网络收发、定时、调度、RCU 锁等各种类型</li>\n<li>内核调度和 RCU 锁（Read-Copy Update）， RCU 是 Linux 内核中最常用的锁之一</li>\n</ul>\n<h2 id=\"查看软中断和内核线程\"><a href=\"#查看软中断和内核线程\" class=\"headerlink\" title=\"查看软中断和内核线程\"></a>查看软中断和内核线程</h2><h3 id=\"proc-文件系统\"><a href=\"#proc-文件系统\" class=\"headerlink\" title=\"proc 文件系统\"></a>proc 文件系统</h3><p>它是一种内核空间和用户空间进行通信的机制，可以用来查看内核的数据结构，或者用来动态修改内核的配置</p>\n<ul>\n<li> &#x2F;proc&#x2F;softirqs ：提供了软中断的运行情况</li>\n<li> &#x2F;proc&#x2F;interrupts ：提供了硬中断的运行情况</li>\n</ul>\n<h3 id=\"查看软中断文件内容\"><a href=\"#查看软中断文件内容\" class=\"headerlink\" title=\"查看软中断文件内容\"></a>查看软中断文件内容</h3><pre><code>$ cat /proc/softirqs CPU0 CPU1 HI: 0 0 TIMER: 811613 1972736 NET\\_TX: 49 7 NET\\_RX: 1136736 1506885 BLOCK: 0 0 IRQ\\_POLL: 0 0 TASKLET: 304787 3691 SCHED: 689718 1897539 HRTIMER: 0 0 RCU: 1330771 1354737\n</code></pre>\n<h4 id=\"注意软中断的类型\"><a href=\"#注意软中断的类型\" class=\"headerlink\" title=\"注意软中断的类型\"></a>注意软中断的类型</h4><ul>\n<li>从第一列可以看出，软中断包括了 10 个类别</li>\n<li><strong>比如：</strong> NET_RX 表示网络接收中断，而 NET_TX 表示网络发送中断</li>\n</ul>\n<h4 id=\"注意同一种软中断在不同-CPU-上的分布情况\"><a href=\"#注意同一种软中断在不同-CPU-上的分布情况\" class=\"headerlink\" title=\"注意同一种软中断在不同 CPU 上的分布情况\"></a>注意同一种软中断在不同 CPU 上的分布情况</h4><ul>\n<li>也就是同一行的内容</li>\n<li>正常情况 下，同一种中断在不同 CPU 上的累积次数应该差不多</li>\n<li><strong>比如：</strong> 上面的，NET_RX 在 CPU0 和 CPU1 上的中断次数基本是同一个数量级，相差不大</li>\n</ul>\n<h4 id=\"TASKLET\"><a href=\"#TASKLET\" class=\"headerlink\" title=\"TASKLET\"></a>TASKLET</h4><ul>\n<li>TASKLET 在不同 CPU 上的分布并不均匀</li>\n<li><strong>TASKLET 是最常用的软中断实现机制</strong>，每个 TASKLET <strong>只运行一次</strong>就会结束 ，并且只在调用它的函数所在的 CPU 上运行</li>\n<li>存在的问题： 由于只在一个 CPU 上运行导致的调度不均衡，再比如因为不能在多个 CPU 上并行运行带来了性能限制</li>\n</ul>\n<h3 id=\"查看软中断线程\"><a href=\"#查看软中断线程\" class=\"headerlink\" title=\"查看软中断线程\"></a>查看软中断线程</h3><p><a href=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/e6bdbd4305127e3a46deaaa482b17611.png\"><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/e6bdbd4305127e3a46deaaa482b17611.png\">\n</a></p>\n<ul>\n<li>注意，这些线程的名字外面都有中括号，这说明 ps <strong>无法获取它们的命令行参数</strong> （cmline）</li>\n<li>一般来说，ps 的输出中，名字括在中括号里的，一般都是内核线程<br><a href=\"https://www.cnblogs.com/poloyy/p/13435519.html\">https://www.cnblogs.com/poloyy/p/13435519.html</a></li>\n</ul>\n","text":"深入理解“软中断”前言 软中断（softirq）导致 CPU 使用率升高也是最常见的一种性能问题 所以软中断这个硬骨头必须啃下去！ 回忆下什么是中断 中断是系统...","permalink":"/post/LINUX/深入理解“软中断”","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"CPU","slug":"CPU","count":5,"path":"api/categories/CPU.json"},{"name":"LINUX","slug":"CPU/LINUX","count":4,"path":"api/categories/CPU/LINUX.json"}],"tags":[{"name":"软中断","slug":"软中断","count":1,"path":"api/tags/软中断.json"},{"name":"也就是","slug":"也就是","count":1,"path":"api/tags/也就是.json"},{"name":"上半部","slug":"上半部","count":1,"path":"api/tags/上半部.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E2%80%9C%E8%BD%AF%E4%B8%AD%E6%96%AD%E2%80%9D\"><span class=\"toc-text\">深入理解“软中断”</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E5%BF%86%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">回忆下什么是中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9C%BA%E6%99%AF%E7%B1%BB%E6%AF%94%EF%BC%8C%E5%8A%A0%E6%B7%B1%E5%8D%B0%E8%B1%A1\"><span class=\"toc-text\">场景类比，加深印象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">中断的优势</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9F%AD\"><span class=\"toc-text\">中断运行时间短</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">中断处理程序在响应中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD%E5%9C%BA%E6%99%AF%E7%B1%BB%E6%AF%94\"><span class=\"toc-text\">响应中断场景类比</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">软中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E5%88%86%E5%89%B2\"><span class=\"toc-text\">中断处理过程分割</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%BF%E4%B8%8A%E5%90%AF%E4%B8%8B\"><span class=\"toc-text\">承上启下</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E5%8D%A1%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E6%A0%97%E5%AD%90\"><span class=\"toc-text\">网卡接收数据包的栗子</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E5%8D%8A%E9%83%A8\"><span class=\"toc-text\">上半部</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E5%8D%8A%E9%83%A8\"><span class=\"toc-text\">下半部</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E5%8D%8A%E9%83%A8-1\"><span class=\"toc-text\">上半部</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E5%8D%8A%E9%83%A8-1\"><span class=\"toc-text\">下半部</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">查看软中断和内核线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#proc-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">proc 文件系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">查看软中断文件内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E8%BD%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">注意软中断的类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E5%90%8C%E4%B8%80%E7%A7%8D%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%9C%A8%E4%B8%8D%E5%90%8C-CPU-%E4%B8%8A%E7%9A%84%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5\"><span class=\"toc-text\">注意同一种软中断在不同 CPU 上的分布情况</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#TASKLET\"><span class=\"toc-text\">TASKLET</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E8%BD%AF%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">查看软中断线程</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Nginx 服务器应用详解","uid":"83fcc4ed8f1c6107bdf89c34a8b59a09","slug":"MIDDLEWARE/Nginx 服务器应用详解","date":"2022-02-26T11:17:14.000Z","updated":"2025-12-05T01:47:34.836Z","comments":true,"path":"api/articles/MIDDLEWARE/Nginx 服务器应用详解.json","keywords":"XuGuangSheng","cover":"/covers/nginx.jpg","text":"Nginx 服务器应用详解一、前言Nginx作为一个异步框架的 Web服务器，也可以用作反向代理，负载平衡器 和 HTTP缓存，下面本篇文章就来介绍一下Ngin...","permalink":"/post/MIDDLEWARE/Nginx 服务器应用详解","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"nginx","slug":"nginx","count":3,"path":"api/categories/nginx.json"},{"name":"MIDDLEWARE","slug":"nginx/MIDDLEWARE","count":2,"path":"api/categories/nginx/MIDDLEWARE.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"SSL","slug":"SSL","count":1,"path":"api/tags/SSL.json"},{"name":"复制代码","slug":"复制代码","count":1,"path":"api/tags/复制代码.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"软中断导致 CPU 使用率过高的案例","uid":"f8276dfd473ae590df0c6e191d789800","slug":"LINUX/软中断导致 CPU 使用率过高的案例","date":"2022-02-02T19:25:37.000Z","updated":"2025-12-05T01:47:20.952Z","comments":true,"path":"api/articles/LINUX/软中断导致 CPU 使用率过高的案例.json","keywords":"XuGuangSheng","cover":"/covers/cpu.jpg","text":"软中断导致 CPU 使用率过高的案例前言软中断基本原理，可参考这篇博客：https://www.cnblogs.com/poloyy/p/13435519.ht...","permalink":"/post/LINUX/软中断导致 CPU 使用率过高的案例","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"CPU","slug":"CPU","count":5,"path":"api/categories/CPU.json"},{"name":"LINUX","slug":"CPU/LINUX","count":4,"path":"api/categories/CPU/LINUX.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"通过","slug":"通过","count":2,"path":"api/tags/通过.json"},{"name":"SYN","slug":"SYN","count":1,"path":"api/tags/SYN.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}