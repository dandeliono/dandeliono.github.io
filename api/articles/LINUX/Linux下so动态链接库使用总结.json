{"title":"Linux下so动态链接库使用总结","uid":"86d3016d930075b1294dec7c5e7f9e57","slug":"LINUX/Linux下so动态链接库使用总结","date":"2024-07-01T13:35:18.000Z","updated":"2025-12-05T01:47:03.011Z","comments":true,"path":"api/articles/LINUX/Linux下so动态链接库使用总结.json","keywords":"XuGuangSheng","cover":"/covers/linuxso.jpg","content":"<h1 id=\"Linux下so动态链接库使用总结\"><a href=\"#Linux下so动态链接库使用总结\" class=\"headerlink\" title=\"Linux下so动态链接库使用总结\"></a>Linux下so动态链接库使用总结</h1><p>本文主要总结在Linux环境下，使用so动态链接库经常遇到的问题，包括使用cp命令覆盖so导致进程coredump之类的问题。<br>主要有以下内容：</p>\n<ul>\n<li>Linux下so动态链接库介绍</li>\n<li>ldconfig命令的使用</li>\n<li>so动态库使用的常见问题</li>\n</ul>\n<hr>\n<h3 id=\"一、Linux下so动态链接库介绍\"><a href=\"#一、Linux下so动态链接库介绍\" class=\"headerlink\" title=\"一、Linux下so动态链接库介绍\"></a><a href=\"#%E4%B8%80%E3%80%81Linux%E4%B8%8Bso%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%BB%8B%E7%BB%8D\" title=\"一、Linux下so动态链接库介绍\"></a>一、Linux下so动态链接库介绍</h3><p>在介绍动态库前，提一个问题：到底什么是库呢？</p>\n<p>库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。</p>\n<p>静态库：这类库的名字一般是libxxx.a，xxx为库的名字。利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中，他的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。</p>\n<p>动态库：这类库的名字一般是libxxx.M.N.so，同样的xxx为库的名字，M是库的主版本号，N是库的副版本号。当然也可以不要版本号，但名字必须有。相对于静态函数库，动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。linux系统有几个重要的目录存放相应的函数库，如&#x2F;lib和&#x2F;usr&#x2F;lib。</p>\n<p>本文主要介绍动态库。</p>\n<p>Linux下动态库文件的文件名形如 <strong>libxxx.so</strong>，其中so是 <strong>Shared Object</strong> 的缩写，即可以共享的目标文件。</p>\n<p>共享文件（*.so）也称为动态库文件，它包含了代码和数据（这些数据是在连接时候被连接器ld和运行时动态连接器使用的）。动态连接器可能称为ld.so.1，libc.so.1或者 ld-linux.so.1。我的CentOS6.0系统中该文件为：&#x2F;lib&#x2F;ld-2.12.so</p>\n<p>在链接动态库生成可执行文件时，并不会把动态库的代码复制到执行文件中，而是在执行文件中记录对动态库的引用。<br>程序执行时，再去加载动态库文件。如果动态库已经加载，则不必重复加载，从而能节省内存空间。<br><strong>程序动态链接的优点</strong>是</p>\n<ol>\n<li>减少依赖相同动态库的多个进程同时运行时的内存的占用（不用每一个进程都加载一份动态库</li>\n<li>可扩展性在程序不用重启的情况下，动态的加载所需要的动态库，可实现对程序的扩展</li>\n<li>程序版本更新与动态链接库的分离</li>\n</ol>\n<p><strong><em>Linux下生成和使用动态库的步骤如下：</em></strong></p>\n<ol>\n<li>编写源文件</li>\n<li>使用命令： gcc -fPIC -shared -o libxxx.so xxx.c，将一个或几个源文件编译链接，生成共享库</li>\n<li>通过 -L -lxxx 的gcc选项链接生成的libxxx.so。</li>\n<li>把libxxx.so放入链接库的标准路径，或指定 LD_LIBRARY_PATH，才能运行链接了libxxx.so的程序。</li>\n</ol>\n<p>具体示例请参考：<a href=\"https://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html\">Linux动态库生成与使用指南</a></p>\n<p><strong>查看程序使用的动态库</strong><br>基本上每一个linux 程序都会使用动态库，查看某个程序使用了那些动态库，可以使用ldd命令：  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">ldd /bin/ls</span></span><br><span class=\"line\">linux-vdso.so.1 =&gt; (0x00007fff597ff000)</span><br><span class=\"line\">libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00000036c2e00000)</span><br><span class=\"line\">librt.so.1 =&gt; /lib64/librt.so.1 (0x00000036c2200000)</span><br><span class=\"line\">libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00000036c4a00000)</span><br><span class=\"line\">libacl.so.1 =&gt; /lib64/libacl.so.1 (0x00000036d0600000)</span><br><span class=\"line\">libc.so.6 =&gt; /lib64/libc.so.6 (0x00000036c1200000)</span><br><span class=\"line\">libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00000036c1600000)</span><br><span class=\"line\">/lib64/ld-linux-x86-64.so.2 (0x00000036c0e00000)</span><br><span class=\"line\">libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00000036c1a00000)</span><br><span class=\"line\">libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00000036cf600000)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、ldconfig命令的使用\"><a href=\"#二、ldconfig命令的使用\" class=\"headerlink\" title=\"二、ldconfig命令的使用\"></a><a href=\"#%E4%BA%8C%E3%80%81ldconfig%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8\" title=\"二、ldconfig命令的使用\"></a>二、ldconfig命令的使用</h3><p>ldconfig命令是在Linux环境下使用so动态链接库时，经常会用到的命令，是Linux下动态链接库的管理命令，<strong>该命令位于&#x2F;sbin目录下</strong>。</p>\n<p>ldconfig命令的用途主要是在默认搜寻目录&#x2F;lib和&#x2F;usr&#x2F;lib以及动态库配置文件&#x2F;etc&#x2F;ld.so.conf内所列的目录下，搜索出可共享的动态链接库（格式如lib_.so_）,进而创建出动态装入程序(ld.so)所需的连接和缓存文件。缓存文件默认为&#x2F;etc&#x2F;ld.so.cache，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令ldconfig，此执行程序存放在&#x2F;sbin目录下。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>ldconfig通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。</p></blockquote>\n<p><strong>使用ldconfig几个需要注意的地方：</strong> </p>\n<ol>\n<li>往&#x2F;lib和&#x2F;usr&#x2F;lib里面加东西，是不用修改&#x2F;etc&#x2F;ld.so.conf的，但是完了之后要调一下ldconfig，不然这个library会找不到。</li>\n<li>想往上面两个目录以外加东西的时候，一定要修改&#x2F;etc&#x2F;ld.so.conf，然后再调用ldconfig，不然也会找不到。</li>\n<li>比如安装了一个mysql到&#x2F;usr&#x2F;local&#x2F;mysql，mysql有一大堆library在&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib下面，这时就需要在&#x2F;etc&#x2F;ld.so.conf下面加一行&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib，保存过后ldconfig一下，新的library才能在程序运行时被找到。</li>\n<li>如果想在这两个目录以外放lib，但是又不想在&#x2F;etc&#x2F;ld.so.conf中加东西（或者是没有权限加东西）。那也可以，就是export一个全局变量LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找library。一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用,因为这样的export 只对当前shell有效，当另开一个shell时候，又要重新设置，当然可以把export LD_LIBRARY_PATH&#x3D;xxx 语句写到 ~&#x2F;.bashrc中，这样就对当前用户有效了，写到&#x2F;etc&#x2F;bashrc中就对所有用户有效了。</li>\n</ol>\n<p><strong>程序执行时的搜索顺序</strong><br>程序执行时按照下列顺序依次装载或者查找共享对象:<br>0）最优先的是，如果在编译时通过-rpath选项指定了路径，便会优先搜索这个路径<br>1）由环境变量 LD_LIBRARY_PATH指定的路径<br>2）由路径缓存文件&#x2F;etc&#x2F;ld.so.cache指定的路径<br>3）默认共享目录 &#x2F;lib和&#x2F;usr&#x2F;lib<br>其中LD_LIBRARY_PATH是一个环境变量，当指定某个程序的LD_LIBRARY_PATH时<br>动态链接器在查找共享库的时候，<strong>会首先从指定的路径开始查找</strong></p>\n<h3 id=\"三、so动态库使用的常见问题\"><a href=\"#三、so动态库使用的常见问题\" class=\"headerlink\" title=\"三、so动态库使用的常见问题\"></a><a href=\"#%E4%B8%89%E3%80%81so%E5%8A%A8%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\" title=\"三、so动态库使用的常见问题\"></a>三、so动态库使用的常见问题</h3><p>介绍完so动态链接库的常见使用之后，下面介绍两个常见的问题：<br>一个是cp命令拷贝一个新的so去覆盖旧的so时，如果有进程或者程序正常使用这个so，那么该操作极有可能导致该进程coredump或者程序崩溃；<br>另一个问题是多个进程或程序都在使用同一个so，但是这个so的路径和版本均不同，那么使用ldconfig命令可能导致另一个进程或者程序出错。</p>\n<h4 id=\"1-覆盖so导致coredump问题总结\"><a href=\"#1-覆盖so导致coredump问题总结\" class=\"headerlink\" title=\"1. 覆盖so导致coredump问题总结\"></a><a href=\"#1-%E8%A6%86%E7%9B%96so%E5%AF%BC%E8%87%B4coredump%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\" title=\"1. 覆盖so导致coredump问题总结\"></a>1. 覆盖so导致coredump问题总结</h4><p>出现问题的场景是升级，在升级流程的脚本中需要升级各个业务进程使用的so，但是有一个so文件是两个业务进程都在同时使用。比如有业务进程A、B、C，升级的过程是:A-&gt;B-&gt;C。其中有so是A和B都依赖，在升级A的过程中，先停掉A进程，升级其需要的so，这个时候升级so，使用的命令是cp，升级完so后，升级A进程使用的二进制，然后拉起A进程。在这一系列的过程中发现B进程coredump了，主要是没有考虑到B进程也在使用那个so。</p>\n<p><strong>cp与mv&#x2F;rm的区别：</strong> </p>\n<p>cp from to，则被覆盖文件 to的inode依旧不变（属性也不变），内容变为from的；</p>\n<p>mv from to，则to的inode变为from的，相应的，to的属性也成了from的；rm类似；</p>\n<p>关于为什么会coredump可参考：<a href=\"https://www.cnblogs.com/zhaoyl/p/4964811.html\">关于so文件cp覆盖导致调用者core的研究</a></p>\n<p><strong>解决方法</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>方法一：<br>先删除旧的so，然后再把新的so拷贝过去，即：<br>rm oldlib.so 然后 cp newlib.so oldlib.so</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>方法二：<br>mv oldlib.so oldlib.so_bak 然后 cp newlib.so oldlib.so</p></blockquote>\n<h4 id=\"2-一次执行ldconfig导致别的模块进程挂掉的经历\"><a href=\"#2-一次执行ldconfig导致别的模块进程挂掉的经历\" class=\"headerlink\" title=\"2. 一次执行ldconfig导致别的模块进程挂掉的经历\"></a><a href=\"#2-%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8Cldconfig%E5%AF%BC%E8%87%B4%E5%88%AB%E7%9A%84%E6%A8%A1%E5%9D%97%E8%BF%9B%E7%A8%8B%E6%8C%82%E6%8E%89%E7%9A%84%E7%BB%8F%E5%8E%86\" title=\"2. 一次执行ldconfig导致别的模块进程挂掉的经历\"></a>2. 一次执行ldconfig导致别的模块进程挂掉的经历</h4><p><strong>问题原因是：</strong><br>与我们服务共同部署在同一个Linux服务器的其他服务也使用了zk服务，需要用到zk的动态链接库，我们的业务进程也需要用到zk的动态链接库。本来最初相安无事，但是在执行一个脚本之后，发现他们的服务挂了，经定位发现是因为so使用有问题，用到了我们服务进程的路径下的zk的动态链接库。在那个shell脚本中，直接用了“ldconfig + 路径”的方式搜索指定路径的so，随后导致他们的服务链接到我们的zk动态链接库了，而这动态链接库是有区别的，最终导致他们的服务挂掉。</p>\n<p><strong>解决方法</strong></p>\n<p>方法一：检查使用ldconfig的地方，在多种服务共同使用的服务器上，不能直接用“ldconfig + 路径”的方式随意添加一些常用的so路径（诸如zk这样常用的服务），诸如多种服务共同部署的时候，要注意避免这种情况；如果要调用脚本使用，可以通过export LD_LIBRARY_PATH的方式临时添加。</p>\n<p>方法二（推荐）：在编译的时候通过gcc -rpath 就指定动态库路径，这样就可以避免被其他路径下的不同的版本的so干扰。可以参考：<a href=\"https://blog.csdn.net/v6543210/article/details/44809405\">gcc -rpath 指定动态库路径</a></p>\n<hr>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><a href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/poetic_vienna/article/details/51249660\">有关Linux下库的概念、生成和升级和使用等</a><br><a href=\"http://blog.chinaunix.net/uid-27105712-id-3313293.html\">linux下so动态库一些不为人知的秘密（上）</a><br><a href=\"http://blog.chinaunix.net/uid-27105712-id-3313327.html\">linux下so动态库一些不为人知的秘密（中）</a><br><a href=\"https://blog.csdn.net/aganlengzi/article/details/44088239\">Linux共享库.so文件的命名和动态链接</a><br><a href=\"https://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html\">Linux动态库生成与使用指南</a><br><a href=\"http://man.linuxde.net/ldconfig\">ldconfig命令</a><br><a href=\"https://www.cnblogs.com/cnland/archive/2013/03/19/2969337.html\">Linux共享库(so)动态加载和升级</a><br><a href=\"https://blog.csdn.net/v6543210/article/details/44809405\">gcc -rpath 指定动态库路径</a><br><a href=\"http://blog.jobbole.com/107977/\">Linux系统中“动态库”和“静态库”那点事儿</a><br><a href=\"https://www.cnblogs.com/zhaoyl/p/4964811.html\">关于so文件cp覆盖导致调用者core的研究</a></p>\n","text":"Linux下so动态链接库使用总结本文主要总结在Linux环境下，使用so动态链接库经常遇到的问题，包括使用cp命令覆盖so导致进程coredump之类的问题。...","permalink":"/post/LINUX/Linux下so动态链接库使用总结","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ldconfig","slug":"ldconfig","count":1,"path":"api/categories/ldconfig.json"},{"name":"LINUX","slug":"ldconfig/LINUX","count":1,"path":"api/categories/ldconfig/LINUX.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"lib","slug":"lib","count":1,"path":"api/tags/lib.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Linux%E4%B8%8Bso%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">Linux下so动态链接库使用总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Linux%E4%B8%8Bso%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">一、Linux下so动态链接库介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81ldconfig%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">二、ldconfig命令的使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81so%E5%8A%A8%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">三、so动态库使用的常见问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%A6%86%E7%9B%96so%E5%AF%BC%E8%87%B4coredump%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">1. 覆盖so导致coredump问题总结</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8Cldconfig%E5%AF%BC%E8%87%B4%E5%88%AB%E7%9A%84%E6%A8%A1%E5%9D%97%E8%BF%9B%E7%A8%8B%E6%8C%82%E6%8E%89%E7%9A%84%E7%BB%8F%E5%8E%86\"><span class=\"toc-text\">2. 一次执行ldconfig导致别的模块进程挂掉的经历</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\"><span class=\"toc-text\">参考资料</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Shiro实现session和jwt认证共存【补充篇】","uid":"a16ed64205294beb02f16921cdcc37a9","slug":"JAVA/Shiro实现session和jwt认证共存【补充篇】","date":"2024-07-11T09:28:24.000Z","updated":"2025-12-05T01:46:30.162Z","comments":true,"path":"api/articles/JAVA/Shiro实现session和jwt认证共存【补充篇】.json","keywords":"XuGuangSheng","cover":"/covers/shirosessionjwt.jpg","text":"Shiro实现session和jwt认证共存【补充篇】前言前文 Shiro实现session和无状态token认证共存 保姆级代码，但是不够完善，有些难点不清不...","permalink":"/post/JAVA/Shiro实现session和jwt认证共存【补充篇】","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"session","slug":"session","count":2,"path":"api/categories/session.json"},{"name":"JAVA","slug":"session/JAVA","count":1,"path":"api/categories/session/JAVA.json"}],"tags":[{"name":"jwt","slug":"jwt","count":1,"path":"api/tags/jwt.json"},{"name":"token","slug":"token","count":1,"path":"api/tags/token.json"},{"name":"redis","slug":"redis","count":2,"path":"api/tags/redis.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"ES如何在几十亿数据场景下优化查询性能","uid":"2234c4cd1c8f1704146bd28a35b83d4d","slug":"MIDDLEWARE/ES如何在几十亿数据场景下优化查询性能","date":"2024-06-17T19:45:12.000Z","updated":"2025-12-05T01:47:23.674Z","comments":true,"path":"api/articles/MIDDLEWARE/ES如何在几十亿数据场景下优化查询性能.json","keywords":"XuGuangSheng","cover":"/covers/es.jpg","text":"ES如何在几十亿数据场景下优化查询性能1. 面试官心里分析es在数据量很大的情况下（数十亿级别）如何提高查询效率啊？ 问这个问题，是肯定的，说白了，就是看你有没...","permalink":"/post/MIDDLEWARE/ES如何在几十亿数据场景下优化查询性能","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"cache","slug":"cache","count":1,"path":"api/categories/cache.json"},{"name":"MIDDLEWARE","slug":"cache/MIDDLEWARE","count":1,"path":"api/categories/cache/MIDDLEWARE.json"}],"tags":[{"name":"filesystem","slug":"filesystem","count":1,"path":"api/tags/filesystem.json"},{"name":"order","slug":"order","count":1,"path":"api/tags/order.json"},{"name":"mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}