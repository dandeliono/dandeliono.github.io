{"title":"Linux PageCache详解","uid":"5d405dae2a57ea9119868cf9afedbd64","slug":"LINUX/Linux PageCache详解","date":"2022-04-12T14:38:01.000Z","updated":"2025-12-05T01:46:58.241Z","comments":true,"path":"api/articles/LINUX/Linux PageCache详解.json","keywords":"XuGuangSheng","cover":"/covers/linux-pagecache.jpg","content":"<h1 id=\"Linux-PageCache详解\"><a href=\"#Linux-PageCache详解\" class=\"headerlink\" title=\"Linux PageCache详解\"></a>Linux PageCache详解</h1><p>应用程序要存储或访问数据时，只需读或者写” 文件” 的一维地址空间即可，而这个地址空间与存储设备上存储块之间的对应关系则由操作系统维护。说白了，文件就是基于内核态 Page Cache 的一层抽象。</p>\n<h2 id=\"相关场景\"><a href=\"#相关场景\" class=\"headerlink\" title=\"相关场景\"></a><a href=\"#%E7%9B%B8%E5%85%B3%E5%9C%BA%E6%99%AF\" title=\"相关场景\"></a>相关场景</h2><ol>\n<li>服务器的 load 飙高；</li>\n<li>服务器的 I&#x2F;O 吞吐飙高；</li>\n<li>业务响应时延出现大的毛刺；</li>\n<li>业务平均访问时延明显增加。</li>\n</ol>\n<h2 id=\"什么是-page-cache\"><a href=\"#什么是-page-cache\" class=\"headerlink\" title=\"什么是 page cache\"></a><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFpage-cache\" title=\"什么是 page cache\"></a>什么是 page cache</h2><p><strong>page cache 是内存管理的内存，属于内核不属于用户。</strong> </p>\n<h3 id=\"查看方式\"><a href=\"#查看方式\" class=\"headerlink\" title=\"查看方式\"></a><a href=\"#%E6%9F%A5%E7%9C%8B%E6%96%B9%E5%BC%8F\" title=\"查看方式\"></a>查看方式</h3><ol>\n<li>&#x2F;proc&#x2F;meminfo</li>\n<li>free 命令</li>\n<li>vmstat 命令</li>\n</ol>\n<h3 id=\"page-cache-指标说明\"><a href=\"#page-cache-指标说明\" class=\"headerlink\" title=\"page cache 指标说明\"></a><a href=\"#page-cache%E6%8C%87%E6%A0%87%E8%AF%B4%E6%98%8E\" title=\"page cache 指标说明\"></a>page cache 指标说明</h3><p>通过 &#x2F; proc&#x2F;meminfo 查看内存信息如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MemTotal:        2046920 kB</span><br><span class=\"line\">MemFree:          375284 kB</span><br><span class=\"line\">MemAvailable:    1013780 kB</span><br><span class=\"line\">Buffers:          142100 kB</span><br><span class=\"line\">Cached:           668196 kB</span><br><span class=\"line\">SwapCached:            0 kB</span><br><span class=\"line\">Active:           959184 kB</span><br><span class=\"line\">Inactive:         279700 kB</span><br><span class=\"line\">Active(anon):     491680 kB</span><br><span class=\"line\">Inactive(anon):    46776 kB</span><br><span class=\"line\">Active(file):     467504 kB</span><br><span class=\"line\">Inactive(file):   232924 kB</span><br><span class=\"line\">Unevictable:           0 kB</span><br><span class=\"line\">Mlocked:               0 kB</span><br><span class=\"line\">SwapTotal:             0 kB</span><br><span class=\"line\">SwapFree:              0 kB</span><br><span class=\"line\">Dirty:                 0 kB</span><br><span class=\"line\">Writeback:             0 kB</span><br><span class=\"line\">AnonPages:        428608 kB</span><br><span class=\"line\">Mapped:            37768 kB</span><br><span class=\"line\">Shmem:            109868 kB</span><br><span class=\"line\">Slab:             138120 kB</span><br><span class=\"line\">SReclaimable:     126188 kB</span><br><span class=\"line\">SUnreclaim:        11932 kB</span><br><span class=\"line\">KernelStack:        2480 kB</span><br><span class=\"line\">PageTables:         4572 kB</span><br><span class=\"line\">NFS_Unstable:          0 kB</span><br><span class=\"line\">Bounce:                0 kB</span><br><span class=\"line\">WritebackTmp:          0 kB</span><br><span class=\"line\">CommitLimit:      891364 kB</span><br><span class=\"line\">Committed_AS:    1419192 kB</span><br><span class=\"line\">VmallocTotal:   34359738367 kB</span><br><span class=\"line\">VmallocUsed:        9136 kB</span><br><span class=\"line\">VmallocChunk:   34359724540 kB</span><br><span class=\"line\">HardwareCorrupted:     0 kB</span><br><span class=\"line\">AnonHugePages:    169984 kB</span><br><span class=\"line\">CmaTotal:              0 kB</span><br><span class=\"line\">CmaFree:               0 kB</span><br><span class=\"line\">HugePages_Total:     129</span><br><span class=\"line\">HugePages_Free:      129</span><br><span class=\"line\">HugePages_Rsvd:        0</span><br><span class=\"line\">HugePages_Surp:        0</span><br><span class=\"line\">Hugepagesize:       2048 kB</span><br><span class=\"line\">DirectMap4k:       53104 kB</span><br><span class=\"line\">DirectMap2M:     2043904 kB</span><br><span class=\"line\">DirectMap1G:           0 kB</span><br></pre></td></tr></table></figure>\n\n<p>通过计算发现：</p>\n<p><strong>Buffers + Cached + SwapCached &#x3D; Active(file) + Inactive(file) + Shmem + SwapCached</strong></p>\n<p>在 Page Cache 中，Active(file)+Inactive(file) 是 File-backed page（与文件对应的内存页），平时用的 mmap() 内存映射方式和 buffered I&#x2F;O 来消耗的内存就属于这部分，这部分在真实的生产环境上也最容易产生问题。</p>\n<h3 id=\"SwapCached-说明-生产环境中不建议开启，防止-IO-引起性能抖动\"><a href=\"#SwapCached-说明-生产环境中不建议开启，防止-IO-引起性能抖动\" class=\"headerlink\" title=\"SwapCached 说明 (生产环境中不建议开启，防止 IO 引起性能抖动)\"></a><a href=\"#SwapCached%E8%AF%B4%E6%98%8E-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%BC%80%E5%90%AF%EF%BC%8C%E9%98%B2%E6%AD%A2IO%E5%BC%95%E8%B5%B7%E6%80%A7%E8%83%BD%E6%8A%96%E5%8A%A8\" title=\"SwapCached 说明 (生产环境中不建议开启，防止 IO 引起性能抖动)\"></a>SwapCached 说明 (生产环境中不建议开启，防止 IO 引起性能抖动)</h3><p>SwapCached 是在打开了 <strong>Swap</strong> 分区后，把 Inactive(anon)+Active(anon) 这两项里的匿名页给交换到磁盘（swap out），然后再读入到内存（swap in）后分配的内存。由于读入到内存后原来的 Swap File 还在，所以 SwapCached 也可以认为是 File-backed page，即属于 Page Cache。</p>\n<h3 id=\"Shmem\"><a href=\"#Shmem\" class=\"headerlink\" title=\"Shmem\"></a><a href=\"#Shmem\" title=\"Shmem\"></a>Shmem</h3><ol>\n<li>Shmem 是指匿名共享映射这种方式分配的内存（free 命令中 shared 这一项）</li>\n<li>进程使用 mmap(MAP_ANON|MAP_SHARED) 的方式申请内存</li>\n<li>tmpfs： 磁盘的速度是远远低于内存的，有些应用程序为了提升性能，会避免将一些无需持续化存储的数据写入到磁盘，而是把这部分临时数据写入到内存中，然后定期或者在不需要这部分数据时，清理掉这部分内容来释放出内存。在这种需求下，就产生了一种特殊的 Shmem：tmpfs</li>\n</ol>\n<h3 id=\"frem-命令的说明\"><a href=\"#frem-命令的说明\" class=\"headerlink\" title=\"frem 命令的说明\"></a><a href=\"#frem%E5%91%BD%E4%BB%A4%E7%9A%84%E8%AF%B4%E6%98%8E\" title=\"frem 命令的说明\"></a>frem 命令的说明</h3><p><strong>数据来源于 &#x2F; proc&#x2F;meminfo</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -k</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:        2046920      732896      377464      109860      936560     1016044</span><br><span class=\"line\">Swap:             0           0           0</span><br></pre></td></tr></table></figure>\n\n<p>通过源码可知：<strong>buff&#x2F;cache &#x3D; Buffers + Cached + SReclaimable</strong></p>\n<p><strong>SReclaimable 是指可以被回收的内核内存，包括 dentry 和 inode。</strong> </p>\n<h4 id=\"缓存的具体含义\"><a href=\"#缓存的具体含义\" class=\"headerlink\" title=\"缓存的具体含义\"></a><a href=\"#%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89\" title=\"缓存的具体含义\"></a>缓存的具体含义</h4><h5 id=\"官方定义\"><a href=\"#官方定义\" class=\"headerlink\" title=\"官方定义\"></a><a href=\"#%E5%AE%98%E6%96%B9%E5%AE%9A%E4%B9%89\" title=\"官方定义\"></a>官方定义</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Buffers %lu</span><br><span class=\"line\">    Relatively temporary storage <span class=\"keyword\">for</span> raw disk blocks that shouldn<span class=\"string\">&#x27;t get tremendously large (20MB or so).</span></span><br><span class=\"line\"><span class=\"string\">Cached %lu</span></span><br><span class=\"line\"><span class=\"string\">   In-memory cache for files read from the disk (the page cache).  Doesn&#x27;</span>t include SwapCached.</span><br><span class=\"line\">SReclaimable %lu (since Linux 2.6.19)</span><br><span class=\"line\">    Part of Slab, that might be reclaimed, such as caches.</span><br><span class=\"line\">    </span><br><span class=\"line\">SUnreclaim %lu (since Linux 2.6.19)</span><br><span class=\"line\">    Part of Slab, that cannot be reclaimed on memory pressure.</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"具体解释\"><a href=\"#具体解释\" class=\"headerlink\" title=\"具体解释\"></a><a href=\"#%E5%85%B7%E4%BD%93%E8%A7%A3%E9%87%8A\" title=\"具体解释\"></a>具体解释</h5><ol>\n<li>Buffers 是对原始磁盘块的临时存储，也就是用来<strong>缓存磁盘的数据</strong>，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。</li>\n<li>Cached 是从磁盘读取文件的页缓存，也就是用来<strong>缓存从文件读取的数据</strong>。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li>\n<li>SReclaimable 是 Slab 的一部分。Slab 包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。</li>\n<li><strong>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中</strong></li>\n</ol>\n<h3 id=\"PageCache-数据结构\"><a href=\"#PageCache-数据结构\" class=\"headerlink\" title=\"PageCache 数据结构\"></a><a href=\"#PageCache%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" title=\"PageCache 数据结构\"></a>PageCache 数据结构</h3><ol>\n<li>内存管理系统与 Page Cache 交互，负责维护每项 Page Cache 的分配和回收，同时在使用 memory map 方式访问时负责建立映射；</li>\n<li>VFS 与 Page Cache 交互，负责 Page Cache 与用户空间的数据交换，即文件读写；</li>\n<li>具体文件系统则一般只与 Buffer Cache 交互，它们负责在外围存储设备和 Buffer Cache 之间交换数据。</li>\n<li>一个 Page Cache 包含多个 Buffer Cache，一个 Buffer Cache 与一个磁盘块一一对应；假定了 Page 的大小是 4K，则文件的每个 4K 的数据块最多只能对应一个 Page Cache 项，它通过一个是 radix tree 来管理文件块和 page cache 的映射关系，Radix tree 是一种搜索树，Linux 内核利用这个数据结构来通过文件内偏移快速定位 Cache 项。</li>\n</ol>\n<h2 id=\"为什么使用-page-cache\"><a href=\"#为什么使用-page-cache\" class=\"headerlink\" title=\"为什么使用 page cache\"></a><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8page-cache\" title=\"为什么使用 page cache\"></a>为什么使用 page cache</h2><p><strong>减少 I&#x2F;O，提升应用的 I&#x2F;O 速度</strong></p>\n<ol>\n<li><strong>具体文件系统：</strong> ，如 ext2&#x2F;ext3、jfs、ntfs 等，负责在文件 Cache 和存储设备之间交换数据</li>\n<li><strong>虚拟文件系统 VFS：</strong>  负责在应用程序和文件 Cache 之间通过 read&#x2F;write 等接口交换数据</li>\n<li><strong>内存管理系统：</strong>  负责文件 Cache 的分配和回收</li>\n<li><strong>虚拟内存管理系统 (VMM)：</strong>  则允许应用程序和文件 Cache 之间通过 memory map 的方式交换数据</li>\n<li><strong>在 Linux 系统中，文件 Cache 是内存管理系统、文件系统以及应用程序之间的一个联系枢纽</strong>。</li>\n</ol>\n<h2 id=\"page-cache-的产生\"><a href=\"#page-cache-的产生\" class=\"headerlink\" title=\"page cache 的产生\"></a><a href=\"#page-cache%E7%9A%84%E4%BA%A7%E7%94%9F\" title=\"page cache 的产生\"></a>page cache 的产生</h2><h3 id=\"产生方式\"><a href=\"#产生方式\" class=\"headerlink\" title=\"产生方式\"></a><a href=\"#%E4%BA%A7%E7%94%9F%E6%96%B9%E5%BC%8F\" title=\"产生方式\"></a>产生方式</h3><ol>\n<li>Buffered I&#x2F;O（标准 I&#x2F;O）如：read&#x2F;write&#x2F;sendfile 等；</li>\n<li>Memory-Mapped I&#x2F;O（存储映射 I&#x2F;O）如：mmap；</li>\n<li>sendfile 和 mmap 都是零拷贝的实现方案。</li>\n</ol>\n<h3 id=\"产生方式的区别\"><a href=\"#产生方式的区别\" class=\"headerlink\" title=\"产生方式的区别\"></a><a href=\"#%E4%BA%A7%E7%94%9F%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB\" title=\"产生方式的区别\"></a>产生方式的区别</h3><ol>\n<li>标准 I&#x2F;O 是写的 (write(2)) 用户缓冲区 (Userpace Page 对应的内存)，然后再将用户缓冲区里的数据拷贝到内核缓冲区 (Pagecache Page 对应的内存)；如果是读的 (read(2)) 话则是先从内核缓冲区拷贝到用户缓冲区，再从用户缓冲区读数据，也就是 buffer 和文件内容不存在任何映射关系。</li>\n<li>对于存储映射 I&#x2F;O 而言，则是直接将 Pagecache Page 给映射到用户地址空间，用户直接读写 Pagecache Page 中内容。</li>\n</ol>\n<h3 id=\"常规文件读写\"><a href=\"#常规文件读写\" class=\"headerlink\" title=\"常规文件读写\"></a><a href=\"#%E5%B8%B8%E8%A7%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99\" title=\"常规文件读写\"></a>常规文件读写</h3><p>FileChannel#read，FileChannel#write，共涉及四次上下文切换（内核态和用户态的切换，包括 read 调用，read 返回，write 调用，write 返回）和四次数据拷贝。</p>\n<h4 id=\"脏页\"><a href=\"#脏页\" class=\"headerlink\" title=\"脏页\"></a><a href=\"#%E8%84%8F%E9%A1%B5\" title=\"脏页\"></a>脏页</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /proc/vmstat | egrep <span class=\"string\">&quot;dirty|writeback&quot;</span></span><br><span class=\"line\">nr_dirty 25</span><br><span class=\"line\">nr_writeback 0</span><br><span class=\"line\">nr_writeback_temp 0</span><br><span class=\"line\">nr_dirty_threshold 94000</span><br><span class=\"line\">nr_dirty_background_threshold 31333</span><br></pre></td></tr></table></figure>\n\n<p>nr_dirty 表示当前系统中积压了多少脏页，nr_writeback 则表示有多少脏页正在回写到磁盘中，他们两个的单位都是 Page(4KB)。</p>\n<h3 id=\"mmap\"><a href=\"#mmap\" class=\"headerlink\" title=\"mmap\"></a><a href=\"#mmap\" title=\"mmap\"></a>mmap</h3><ol>\n<li>文件（page cache）直接映射到用户虚拟地址空间，内核态和用户态共享一片 page cache，避免了一次数据拷贝</li>\n<li>建立 mmap 之后，并不会立马加载数据到内存，只有真正使用数据时，才会引发缺页异常并加载数据到内存</li>\n</ol>\n<h4 id=\"memory-map-具体步骤如下\"><a href=\"#memory-map-具体步骤如下\" class=\"headerlink\" title=\"memory map 具体步骤如下\"></a><a href=\"#memory-map%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E5%A6%82%E4%B8%8B\" title=\"memory map 具体步骤如下\"></a>memory map 具体步骤如下</h4><ol>\n<li>应用程序调用 mmap（图中 1），先到内核中</li>\n<li>后调用 do_mmap_pgoff（图中 2），该函数从应用程序的地址空间中<strong>分配一段区域作为映射的内存地址</strong>，并使用一个 VMA（vm_area_struct）结构代表该区域，</li>\n<li>之后就返回到应用程序（图中 3）</li>\n<li>当应用程序访问 mmap 所返回的地址指针时（图中 4），由于虚实映射尚未建立，会触发缺页中断（图中 5）。之后系统会调用缺页中断处理函数（图中 6），在缺页中断处理函数中，内核通过相应区域的 VMA 结构判断出该区域属于文件映射，于是调用具体文件系统的接口读入相应的 Page Cache 项（图中 7、8、9），并填写相应的虚实映射表。</li>\n<li>经过这些步骤之后，应用程序就可以正常访问相应的内存区域了。</li>\n</ol>\n<h3 id=\"sendfile\"><a href=\"#sendfile\" class=\"headerlink\" title=\"sendfile\"></a><a href=\"#sendfile\" title=\"sendfile\"></a>sendfile</h3><ol>\n<li>使用 sendfile 的方式避免了用户空间与内核空间的交互，复制次数减少到三次，内核态与用户态切换减少到两次。</li>\n<li>在 Linux 内核 2.4 及后期版本中，针对套接字缓冲区描述符做了相应调整，DMA 自带了收集功能，对于用户方面，用法还是一样。内部只把包含数据位置和长度信息的描述符追加到套接字缓冲区，DMA 引擎直接把数据从内核缓冲区传到协议引擎，从而消除了最后一次 CPU 参与的拷贝动作。</li>\n</ol>\n<h3 id=\"顺序读写\"><a href=\"#顺序读写\" class=\"headerlink\" title=\"顺序读写\"></a><a href=\"#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99\" title=\"顺序读写\"></a>顺序读写</h3><h4 id=\"文件预读\"><a href=\"#文件预读\" class=\"headerlink\" title=\"文件预读\"></a><a href=\"#%E6%96%87%E4%BB%B6%E9%A2%84%E8%AF%BB\" title=\"文件预读\"></a>文件预读</h4><p>文件的预读机制，它是一种将磁盘块预读到 page cache 的机制, 执行步骤如下：</p>\n<ol>\n<li>对于每个文件的<strong>第一个读请求</strong>，系统读入所请求的页面并读入紧随其后的少数几个页面 (不少于一个页面，通常是三个页面)，这时的预读称为<strong>同步预读</strong>。</li>\n<li>对于<strong>第二次读请求</strong>，如果所读页面不在 Cache 中，即不在前次预读的 group 中，则表明文件访问不是顺序访问，系统继续采用同步预读；如果所读页面在 Cache 中，则表明前次预读命中，操作系统把预读 group 扩大一倍，并让底层文件系统读入 group 中剩下尚不在 Cache 中的文件数据块，这时的预读称为<strong>异步预读</strong>。</li>\n<li>无论第二次读请求是否命中，系统都要更新当前预读 group 的大小。</li>\n<li>系统中定义了一个 window，它包括前一次预读的 group 和本次预读的 group。任何接下来的读请求都会处于两种情况之一：<ul>\n<li>第一种情况是所请求的页面处于预读 window 中，这时继续进行异步预读并更新相应的 window 和 group；</li>\n<li>第二种情况是所请求的页面处于预读 window 之外，这时系统就要进行同步预读并重置相应的 window 和 group。</li>\n</ul>\n</li>\n</ol>\n<p>图中 group 指一次读入 page cached 的集合；window 包括前一次预读的 group 和本次预读的 group；浅灰色代表要用户想要查找的 page cache，深灰色代表命中的 page。</p>\n<h4 id=\"顺序读写高效的原因\"><a href=\"#顺序读写高效的原因\" class=\"headerlink\" title=\"顺序读写高效的原因\"></a><a href=\"#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0\" title=\"顺序读写高效的原因\"></a>顺序读写高效的原因</h4><p>以顺序读为例，当用户发起一个 fileChannel.read(4kb) 之后，实际发生了两件事</p>\n<ol>\n<li>操作系统从磁盘加载了 16kb 进入 PageCache，这被称为预读</li>\n<li>操作通从 PageCache 拷贝 4kb 进入用户内存</li>\n<li>当用户继续访问接下来的 [4kb,16kb] 的磁盘内容时，便是直接从 PageCache 去访问了</li>\n</ol>\n<h2 id=\"page-cache-的消亡\"><a href=\"#page-cache-的消亡\" class=\"headerlink\" title=\"page cache 的消亡\"></a><a href=\"#page-cache%E7%9A%84%E6%B6%88%E4%BA%A1\" title=\"page cache 的消亡\"></a>page cache 的消亡</h2><p>page cache 的回收主要是针对 free 命令中的 buff&#x2F;cache 中的这些就是 “活着” 的 Page Cache。回收的过程如下图所示：</p>\n<p>回收的方式主要是两种：直接回收和后台回收, 具体的回收行为，可以使用以下命令查看：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sar -B 1</span><br><span class=\"line\">Linux 3.10.0-1062.9.1.el7.x86_64 (instance-gctg007a) \t08/18/2020 \t_x86_64_\t(1 CPU)</span><br><span class=\"line\"></span><br><span class=\"line\">07:34:59 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff</span><br><span class=\"line\">07:35:00 PM      0.00      0.00     66.00      0.00     58.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:01 PM      0.00     25.53   1893.62      0.00    608.51      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:02 PM      0.00      0.00    648.48      0.00    280.81      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:03 PM      0.00      0.00     17.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:04 PM      0.00      0.00   1096.04      0.00    295.05      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:05 PM      0.00      0.00     17.00      0.00     23.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:06 PM      0.00     52.00     17.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:07 PM      0.00      0.00     17.00      0.00     44.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:08 PM      0.00      0.00     18.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:09 PM      0.00      0.00     18.18      0.00     19.19      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:10 PM      0.00      0.00     17.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br><span class=\"line\">07:35:11 PM      0.00      0.00     17.00      0.00     19.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>pgscank&#x2F;s : kswapd(后台回收线程) 每秒扫描的 page 个数。</li>\n<li>pgscand&#x2F;s: Application 在内存申请过程中每秒直接扫描的 page 个数。</li>\n<li>pgsteal&#x2F;s: 扫描的 page 中每秒被回收的个数。</li>\n<li>%vmeff: pgsteal&#x2F;(pgscank+pgscand), 回收效率，越接近 100 说明系统越安全，越接近 0 说明系统内存压力越大。</li>\n</ol>\n<h3 id=\"sar-B-与-x2F-proc-x2F-vmstat-比对\"><a href=\"#sar-B-与-x2F-proc-x2F-vmstat-比对\" class=\"headerlink\" title=\"sar -B 与 &#x2F; proc&#x2F;vmstat 比对\"></a><a href=\"#sar-B%E4%B8%8E-proc-vmstat%E6%AF%94%E5%AF%B9\" title=\"sar -B 与 / proc/vmstat 比对\"></a>sar -B 与 &#x2F; proc&#x2F;vmstat 比对</h3><table>\n<thead>\n<tr>\n<th>sar -B</th>\n<th>&#x2F;proc&#x2F;vmstat</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pgscank</td>\n<td>pgscan_kswapd</td>\n</tr>\n<tr>\n<td>pgscand</td>\n<td>pgscan_direct</td>\n</tr>\n<tr>\n<td>pgsteal</td>\n<td>pgsteal_kswapd+pgsteal_direct</td>\n</tr>\n</tbody></table>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a><a href=\"#%E5%85%B6%E4%BB%96\" title=\"其他\"></a>其他</h2><h3 id=\"DMA（Direct-Memory-Access-直接存储器访问）\"><a href=\"#DMA（Direct-Memory-Access-直接存储器访问）\" class=\"headerlink\" title=\"DMA（Direct Memory Access, 直接存储器访问）\"></a><a href=\"#DMA%EF%BC%88Direct-Memory-Access-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%EF%BC%89\" title=\"DMA（Direct Memory Access, 直接存储器访问）\"></a>DMA（Direct Memory Access, 直接存储器访问）</h3><ol>\n<li>DMA 的出现就是为了解决批量数据的输入 &#x2F; 输出问题。DMA 是指外部设备不通过 CPU 而直接与系统内存交换数据的接口技术</li>\n<li>DMA 控制器需要具备的功能：<ul>\n<li>能向 CPU 发出系统保持信号，提出总线接管请求</li>\n<li>当 CPU 同意接管请求之后，对总线的控制交给 DMA</li>\n<li><strong>能对存储器寻址及能修改地址指针，实现对内存的读写</strong></li>\n<li>能决定本次 DMA 传送的字节数，判断 DMA 传送是否借宿</li>\n<li>发送 DMA 结束信号，使 CPU 恢复正常工作状态</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"堆外内存\"><a href=\"#堆外内存\" class=\"headerlink\" title=\"堆外内存\"></a><a href=\"#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98\" title=\"堆外内存\"></a>堆外内存</h3><h4 id=\"堆内存与堆外内存的关系\"><a href=\"#堆内存与堆外内存的关系\" class=\"headerlink\" title=\"堆内存与堆外内存的关系\"></a><a href=\"#%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB\" title=\"堆内存与堆外内存的关系\"></a>堆内存与堆外内存的关系</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>堆内内存</th>\n<th>堆外内存</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>底层实现</td>\n<td>数组，JVM 内存</td>\n<td>unsafe.allocateMemory(size) 返回直接内存</td>\n</tr>\n<tr>\n<td>分配大小限制</td>\n<td>-Xms-Xmx，</td>\n<td></td>\n</tr>\n<tr>\n<td>数组大小，当前 JVM free memory 大于 1.5G 时，ByteBuffer.allocate(900M) 会报错</td>\n<td>-XX:MaxDirectMemorySize 参数从 JVM 层面限制，同时受到机器虚拟内存的限制</td>\n<td></td>\n</tr>\n<tr>\n<td>垃圾回收</td>\n<td></td>\n<td>当前 DirectByteBuffer 不再被使用时，会触发内部 cleaner 的钩子</td>\n</tr>\n</tbody></table>\n<p>保险起见，可以考虑手动回收<br>((DirectBuffer)buffer).cleaner().clean() |<br>| 内存复制 | 堆内内存 — 堆外内存 —pageCache | 堆外内存 –pageCache |</p>\n<h4 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a><a href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\" title=\"最佳实践\"></a>最佳实践</h4><ol>\n<li>当需要申请大块的内存时，堆内内存会受到限制，只能分配堆外内存。</li>\n<li>堆外内存适用于生命周期中等或较长的对象。(如果是生命周期较短的对象，在 YGC 的时候就被回收了，就不存在大内存且生命周期较长的对象在 FGC 对应用造成的性能影响)。</li>\n<li>堆内内存刷盘的过程中，还需要复制一份到堆外内存，这部分内容可以在 FileChannel 的实现源码中看到细节<ul>\n<li>使用 HeapByteBuffer 读写都会经过 DirectByteBuffer，写入数据的流转方式其实是：HeapByteBuffer -&gt; DirectByteBuffer -&gt; PageCache -&gt; Disk，读取数据的流转方式正好相反。</li>\n<li>使用 HeapByteBuffer 读写会申请一块跟线程绑定的 DirectByteBuffer。这意味着，线程越多，临时 DirectByteBuffer 就越会占用越多的空间。</li>\n</ul>\n</li>\n<li>堆外内存就是把内存对象分配在 Java 虚拟机堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</li>\n<li>内存回收流程</li>\n</ol>\n<h2 id=\"PageCache-内存回收\"><a href=\"#PageCache-内存回收\" class=\"headerlink\" title=\"PageCache 内存回收\"></a><a href=\"#PageCache%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6\" title=\"PageCache 内存回收\"></a>PageCache 内存回收</h2><h3 id=\"回收过程\"><a href=\"#回收过程\" class=\"headerlink\" title=\"回收过程\"></a><a href=\"#%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B\" title=\"回收过程\"></a>回收过程</h3><p>在内存紧张的时候会触发内存回收，内存回收会尝试去回收 reclaimable（可被回收）的内存。包括<strong>PageCache 以及 reclaimable kernel memory（比如 slab）</strong>。</p>\n<h3 id=\"避免-PageCache-回收出现的性能问题\"><a href=\"#避免-PageCache-回收出现的性能问题\" class=\"headerlink\" title=\"避免 PageCache 回收出现的性能问题\"></a><a href=\"#%E9%81%BF%E5%85%8DPageCache%E5%9B%9E%E6%94%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98\" title=\"避免 PageCache 回收出现的性能问题\"></a>避免 PageCache 回收出现的性能问题</h3><h4 id=\"memory-cgroup-protection\"><a href=\"#memory-cgroup-protection\" class=\"headerlink\" title=\"memory cgroup protection\"></a><a href=\"#memory-cgroup-protection\" title=\"memory cgroup protection\"></a>memory cgroup protection</h4><ol>\n<li><strong>memory.max</strong>：memory cgroup 内的进程最多能够分配的内存，如果不设置的话，就默认不做内存大小的限制</li>\n<li><strong>memory.high</strong>：当 memory cgroup 内进程的内存使用量超过了该值后就会立即被回收掉，目的是为了<strong>尽快的回收掉不活跃的 Page Cache</strong>。</li>\n<li><strong>memory.low</strong>：用来保护重要数据的，当 memory cgroup 内进程的内存使用量低于了该值后，在内存紧张触发回收后就会先去回收不属于该 memory cgroup 的 Page Cache，等到其他的 Page Cache 都被回收掉后再来回收这些 Page Cache。</li>\n<li><strong>memory.min</strong>：用来保护重要数据的，只不过与 memoy.low 有所不同的是，当 memory cgroup 内进程的内存使用量低于该值后，即使其他不在该 memory cgroup 内的 Page Cache 都被回收完了也不会去回收这些 Page Cache。</li>\n<li><strong>总结：如果你想要保护你的 Page Cache 不被回收，你就可以考虑将你的业务进程放在一个 memory cgroup 中，然后设置 memory.{min,low} 来进行保护；与之相反，如果你想要尽快释放你的 Page Cache，那你可以考虑设置 memory.high 来及时的释放掉不活跃的 Page Cache。</strong></li>\n</ol>\n<h3 id=\"出现-load-过高的原因\"><a href=\"#出现-load-过高的原因\" class=\"headerlink\" title=\"出现 load 过高的原因\"></a><a href=\"#%E5%87%BA%E7%8E%B0load%E8%BF%87%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0\" title=\"出现 load 过高的原因\"></a>出现 load 过高的原因</h3><h4 id=\"直接内存回收引起\"><a href=\"#直接内存回收引起\" class=\"headerlink\" title=\"直接内存回收引起\"></a><a href=\"#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%BC%95%E8%B5%B7\" title=\"直接内存回收引起\"></a>直接内存回收引起</h4><h5 id=\"内存回收过程\"><a href=\"#内存回收过程\" class=\"headerlink\" title=\"内存回收过程\"></a><a href=\"#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B\" title=\"内存回收过程\"></a>内存回收过程</h5><p>后台回收原理：</p>\n<p>通过调整参数 vm.min_free_kbytes 来提高后台进程回收频率。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /proc/sys/vm/min_free_kbytes</span><br><span class=\"line\">vi /etc/sysctl.conf vm.min_free_kbytes=524288 </span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n\n<p>通过调整内存水位，在一定程度上保障了应用的内存申请，但是同时也带来了一定的内存浪费，因为系统始终要保障有这么多的 free 内存，这就压缩了 Page Cache 的空间。调整的效果你可以通过 &#x2F;proc&#x2F;zoneinfo 来观察</p>\n<h4 id=\"系统中脏页积压过多\"><a href=\"#系统中脏页积压过多\" class=\"headerlink\" title=\"系统中脏页积压过多\"></a><a href=\"#%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%84%8F%E9%A1%B5%E7%A7%AF%E5%8E%8B%E8%BF%87%E5%A4%9A\" title=\"系统中脏页积压过多\"></a>系统中脏页积压过多</h4><h5 id=\"内存申请过程\"><a href=\"#内存申请过程\" class=\"headerlink\" title=\"内存申请过程\"></a><a href=\"#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E8%BF%87%E7%A8%8B\" title=\"内存申请过程\"></a>内存申请过程</h5><h5 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a><a href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\" title=\"解决方法\"></a>解决方法</h5><p>设置配置：&#x2F;proc&#x2F;vmstat</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.dirty_background_bytes = 0</span><br><span class=\"line\">vm.dirty_background_ratio = 10</span><br><span class=\"line\">vm.dirty_bytes = 0</span><br><span class=\"line\">vm.dirty_expire_centisecs = 3000</span><br><span class=\"line\">vm.dirty_ratio = 20</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"系统-numa-策略配置不当\"><a href=\"#系统-numa-策略配置不当\" class=\"headerlink\" title=\"系统 numa 策略配置不当\"></a><a href=\"#%E7%B3%BB%E7%BB%9Fnuma%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93\" title=\"系统 numa 策略配置不当\"></a>系统 numa 策略配置不当</h4><h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a><a href=\"#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\" title=\"内存泄漏\"></a>内存泄漏</h2><h3 id=\"OOM-KILL-逻辑\"><a href=\"#OOM-KILL-逻辑\" class=\"headerlink\" title=\"OOM KILL 逻辑\"></a><a href=\"#OOM-KILL%E9%80%BB%E8%BE%91\" title=\"OOM KILL 逻辑\"></a>OOM KILL 逻辑</h3><p>可以调整 oom_score_adj 来防止进程被杀掉（不建议配置）</p>\n<h3 id=\"如何观察内核内存泄漏\"><a href=\"#如何观察内核内存泄漏\" class=\"headerlink\" title=\"如何观察内核内存泄漏\"></a><a href=\"#%E5%A6%82%E4%BD%95%E8%A7%82%E5%AF%9F%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\" title=\"如何观察内核内存泄漏\"></a>如何观察内核内存泄漏</h3><ol>\n<li>如果 &#x2F;proc&#x2F;meminfo 中内核内存（比如 VmallocUsed 和 SUnreclaim）太大，那很有可能发生了内核内存泄漏</li>\n<li>周期性地观察 VmallocUsed 和 SUnreclaim 的变化，如果它们持续增长而不下降，也可能是发生了内核内存泄漏</li>\n<li>通过 &#x2F;proc&#x2F;vmallocinfo 来看到该模块的内存使用情况</li>\n<li>kmemleak 内核内存分析工具</li>\n</ol>\n<h3 id=\"排查思路\"><a href=\"#排查思路\" class=\"headerlink\" title=\"排查思路\"></a><a href=\"#%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF\" title=\"排查思路\"></a>排查思路</h3><table>\n<thead>\n<tr>\n<th>&#x2F;proc&#x2F;meminfo</th>\n<th>含义以及排查思路</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Active(anon)</td>\n<td>在 active anon lru 的 page，与下一项相互转换</td>\n</tr>\n<tr>\n<td>Inactive(anon)</td>\n<td>在 inactive anonlru 的 page，可以交换到 swap 分区，（active anno 也是）但是不能回收</td>\n</tr>\n</tbody></table>\n<p>程序使用 malloc() 或 mmap() 匿名方式申请并且写后的内存。如果过大，排除思路：  </p>\n<ol>\n<li><p>使用 top 找出内存消耗最大的进程  </p>\n</li>\n<li><p>使用 pmap 分析该进程  </p>\n</li>\n<li><p>如果没有任何进程内存开销大，则重点排除 tmpfs |<br>| Unevictable | 在系统内存紧张时不能被回收，主要组成：<br>1.ram disk 或 ramfs 消耗的内存  </p>\n</li>\n<li><p>以 SHM_LOCK 方式申请的 Shmem  </p>\n</li>\n<li><p>使用 mlock() 序列函数来管理的内存 |<br>| Mlocked | 属于 Unevictable 的一种，重点排除 mlock() 方式包含的内存 |<br>| AnonPages | AnonPages！&#x3D;Active（anon）+Inactive（anon）<br>因为 shmem（包括 tmpfs）虽然属于 active（anon）或 Inactive（anon），但是他们有自己的内存文件，所以不属于 AnonPages<br>active anon 和 Inactive anon 表示不可回收但是可以被交换到 swap 分区的内存<br>AnonPages 没有对应文件的内存<br>排除 malloc() 方式申请的内存或 mmap（PROT_WRITE,MAP_ANON|MAP_PRIVATE）方式申请的内存 |<br>| Mapped | 使用 mmap（2）申请，没有被 unmap 的内存；unmap 包含主动调用 unmap（2）以及内核内存回收时的 unmap<br>排查 mmap（）申请的内存 |<br>| Shmem | 共享内存，特别注意 tmpfs，排查思路  </p>\n</li>\n<li><p>使用 top 找出 shr 最大的进程  </p>\n</li>\n<li><p>使用 pmap 分析该进程  </p>\n</li>\n<li><p>如果没有任何进程消耗 shr 内存，则重点排查 tmpfs |<br>| Slab | 分为可被回收（SReclaimable）和不可以被回收（SUnreclaim），其中不可被回收的 slab 如果发生泄漏，<br>比如 kmalloc 申请的内存没有释放，排查思路  </p>\n</li>\n<li><p>使用 slaptop 分析 slab 最大的数据  </p>\n</li>\n<li><p>排查驱动程序以 kmalloc(）方式申请的内存 |<br>| VmallocUsed | 通过 vmalloc 分配的内核内存，可以使用 &#x2F; proc&#x2F;vmallocinfo，来判断哪些驱动程序以 vmalloc 方式申请的内存较多<br>可以尝试卸载驱动，释放内存 |</p>\n</li>\n<li><p>应用程序可以通过 malloc() 和 free() 在用户态申请和释放内存，与之对应，可以通过 kmalloc()&#x2F;kfree() 以及 vmalloc()&#x2F;vfree() 在内核态申请和释放内存</p>\n</li>\n<li><p>vmalloc 申请的内存会体现在 VmallocUsed 这一项中，即已使用的 Vmalloc 区大小；而 kmalloc 申请的内存则是体现在 Slab 这一项中，它又分为两部分，其中 SReclaimable 是指在内存紧张的时候可以被回收的内存，而 SUnreclaim 则是不可以被回收只能主动释放的内存。</p>\n</li>\n</ol>\n<h2 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a><a href=\"#%E5%85%B6%E4%BB%96-1\" title=\"其他\"></a>其他</h2><h3 id=\"清理缓存-buffer-x2F-cache\"><a href=\"#清理缓存-buffer-x2F-cache\" class=\"headerlink\" title=\"清理缓存 buffer&#x2F;cache\"></a><a href=\"#%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98buffer-cache\" title=\"清理缓存 buffer/cache\"></a>清理缓存 buffer&#x2F;cache</h3><h4 id=\"运行-sync-将-dirty-的内容写回硬盘\"><a href=\"#运行-sync-将-dirty-的内容写回硬盘\" class=\"headerlink\" title=\"运行 sync 将 dirty 的内容写回硬盘\"></a><a href=\"#%E8%BF%90%E8%A1%8Csync%E5%B0%86dirty%E7%9A%84%E5%86%85%E5%AE%B9%E5%86%99%E5%9B%9E%E7%A1%AC%E7%9B%98\" title=\"运行 sync 将 dirty 的内容写回硬盘\"></a>运行 sync 将 dirty 的内容写回硬盘</h4><h4 id=\"通过修改-proc-系统的-drop-caches-清理-free-的-cache\"><a href=\"#通过修改-proc-系统的-drop-caches-清理-free-的-cache\" class=\"headerlink\" title=\"通过修改 proc 系统的 drop_caches 清理 free 的 cache\"></a><a href=\"#%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9proc%E7%B3%BB%E7%BB%9F%E7%9A%84drop-caches%E6%B8%85%E7%90%86free%E7%9A%84cache\" title=\"通过修改 proc 系统的 drop_caches 清理 free 的 cache\"></a>通过修改 proc 系统的 drop_caches 清理 free 的 cache</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br><span class=\"line\">说明</span><br><span class=\"line\"><span class=\"built_in\">echo</span> 1 &gt; /proc/sys/vm/drop_caches:表示清除pagecache。 </span><br><span class=\"line\"><span class=\"built_in\">echo</span> 2 &gt; /proc/sys/vm/drop_caches:表示清除回收slab分配器中的对象（包括目录项缓存和inode缓存）。slab分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的pagecache。 </span><br><span class=\"line\"><span class=\"built_in\">echo</span> 3 &gt; /proc/sys/vm/drop_caches:表示清除pagecache和slab分配器中的缓存对象。</span><br></pre></td></tr></table></figure>\n\n<p>可以通过<code>/proc/vmstat</code>文件判断是否执行过 drop_caches：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@instance-gctg007a ~]</span><br><span class=\"line\">drop_pagecache 0</span><br><span class=\"line\">drop_slab 0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可以调用-crond-定时任务：每-10-分钟执行一次\"><a href=\"#可以调用-crond-定时任务：每-10-分钟执行一次\" class=\"headerlink\" title=\"可以调用 crond 定时任务：每 10 分钟执行一次\"></a><a href=\"#%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8crond%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9A%E6%AF%8F10%E5%88%86%E9%92%9F%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1\" title=\"可以调用 crond 定时任务：每 10 分钟执行一次\"></a>可以调用 crond 定时任务：每 10 分钟执行一次</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/10 * * * * <span class=\"built_in\">sync</span>;<span class=\"built_in\">echo</span> 3 &gt; /proc/sys/vm/drop_caches;  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重要配置参数\"><a href=\"#重要配置参数\" class=\"headerlink\" title=\"重要配置参数\"></a><a href=\"#%E9%87%8D%E8%A6%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0\" title=\"重要配置参数\"></a>重要配置参数</h3><h4 id=\"x2F-proc-x2F-sys-x2F-vm-x2F-dirty-ratio（同步刷盘）\"><a href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-dirty-ratio（同步刷盘）\" class=\"headerlink\" title=\"&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_ratio（同步刷盘）\"></a><a href=\"#proc-sys-vm-dirty-ratio%EF%BC%88%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%EF%BC%89\" title=\"/proc/sys/vm/dirty_ratio（同步刷盘）\"></a>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_ratio（同步刷盘）</h4><p>这个参数控制文件系统的文件系统写缓冲区的大小，单位是百分比，表示系统内存的百分比，<strong>表示当写缓冲使用到系统内存多少的时候，开始向磁盘写出数据</strong>。增大之会使用更多系统内存用于磁盘写缓冲，也可以极大提高系统的写性能。但是，当你需要持续、恒定的写入场合时，应该降低其数值，一般启动上缺省是 10。设 1 加速程序速度</p>\n<h4 id=\"x2F-proc-x2F-sys-x2F-vm-x2F-dirty-background-ratio（异步刷盘）\"><a href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-dirty-background-ratio（异步刷盘）\" class=\"headerlink\" title=\"&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_background_ratio（异步刷盘）\"></a><a href=\"#proc-sys-vm-dirty-background-ratio%EF%BC%88%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98%EF%BC%89\" title=\"/proc/sys/vm/dirty_background_ratio（异步刷盘）\"></a>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_background_ratio（异步刷盘）</h4><p>这个参数控制文件系统的 pdflush 进程，在何时刷新磁盘。单位是百分比，<strong>表示系统内存的百分比，意思是当写缓冲使用到系统内存多少的时 候，pdflush 开始向磁盘写出数据</strong>。增大之会使用更多系统内存用于磁盘写缓冲，也可以极大提高系统的写性能。但是，当你需要持续、恒定的写入场合时， 应该降低其数值，一般启动上缺省是 5</p>\n<h4 id=\"x2F-proc-x2F-sys-x2F-vm-x2F-dirty-writeback-centisecs\"><a href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-dirty-writeback-centisecs\" class=\"headerlink\" title=\"&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_writeback_centisecs\"></a><a href=\"#proc-sys-vm-dirty-writeback-centisecs\" title=\"/proc/sys/vm/dirty_writeback_centisecs\"></a>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_writeback_centisecs</h4><p>这个参数控制内核的脏数据刷新进程 pdflush 的运行间隔。单位是 1&#x2F;100 秒。缺省数值是 500，也就是 5 秒。如果你的系统是持续地写入动作，那么实际上还是降低这个数值比较好，这样可以把尖峰的写操作削平成多次写操</p>\n<h4 id=\"x2F-proc-x2F-sys-x2F-vm-x2F-dirty-expire-centisecs\"><a href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-dirty-expire-centisecs\" class=\"headerlink\" title=\"&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_expire_centisecs\"></a><a href=\"#proc-sys-vm-dirty-expire-centisecs\" title=\"/proc/sys/vm/dirty_expire_centisecs\"></a>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_expire_centisecs</h4><p>这个参数声明 Linux 内核写缓冲区里面的数据多 “旧” 了之后，pdflush 进程就开始考虑写到磁盘中去。单位是 1&#x2F;100 秒。缺省是 30000，也就是 30 秒的数据就算旧了，将会刷新磁盘。对于特别重载的写操作来说，这个值适当缩小也是好的，但也不能缩小太多，因为缩小太多也会导致 IO 提高太快。建议设置为 1500，也就是 15 秒算旧。</p>\n<h4 id=\"x2F-proc-x2F-sys-x2F-vm-x2F-drop-caches\"><a href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-drop-caches\" class=\"headerlink\" title=\"&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches\"></a><a href=\"#proc-sys-vm-drop-caches\" title=\"/proc/sys/vm/drop_caches\"></a>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</h4><p>释放已经使用的 cache</p>\n<h4 id=\"x2F-proc-x2F-sys-x2F-vm-x2F-page-cluster\"><a href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-page-cluster\" class=\"headerlink\" title=\"&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;page_cluster\"></a><a href=\"#proc-sys-vm-page-cluster\" title=\"/proc/sys/vm/page_cluster\"></a>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;page_cluster</h4><p>该文件表示在写一次到 swap 区的时候写入的页面数量，0 表示 1 页，1 表示 2 页，2 表示 4 页。</p>\n<h4 id=\"x2F-proc-x2F-sys-x2F-vm-x2F-swapiness\"><a href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-swapiness\" class=\"headerlink\" title=\"&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swapiness\"></a><a href=\"#proc-sys-vm-swapiness\" title=\"/proc/sys/vm/swapiness\"></a>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swapiness</h4><p>该文件表示系统进行交换行为的程度，数值（0-100）越高，越可能发生磁盘交换。</p>\n<h4 id=\"x2F-proc-x2F-sys-x2F-vm-x2F-vfs-cache-pressure\"><a href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-vfs-cache-pressure\" class=\"headerlink\" title=\"&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;vfs_cache_pressure\"></a><a href=\"#proc-sys-vm-vfs-cache-pressure\" title=\"/proc/sys/vm/vfs_cache_pressure\"></a>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;vfs_cache_pressure</h4><p>该文件表示内核回收用于 directory 和 inode cache 内存的倾向</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><a href=\"#%E5%8F%82%E8%80%83\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.kernel.org/doc/Documentation/filesystems/proc.rst\">proc 帮助手册</a></li>\n<li><a href=\"https://www.sunliaodong.cn/2021/03/11/Linux-PageCache%E8%AF%A6%E8%A7%A3/linux-performance-analysis-tools.md\">常用性能分析工具</a></li>\n<li><a href=\"https://blog.csdn.net/a1240466196/article/details/106456200\">NIO 进阶篇：Page Cache、零拷贝、顺序读写、堆外内存</a></li>\n<li><a href=\"https://www.imooc.com/article/301624\">面试官：RocketMQ 如何基于 mmap+page cache 实现磁盘文件的高性能读写？</a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_448574810101k1va.html\">文件系统缓存 dirty_ratio 与 dirty_background_ratio 两个参数区别</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/42364591\">PageCache 系列之五 统一缓存之 PageCache</a></li>\n</ol>\n","text":"Linux PageCache详解应用程序要存储或访问数据时，只需读或者写” 文件” 的一维地址空间即可，而这个地址空间与存储设备上存储块之间的对应关系则由操作...","permalink":"/post/LINUX/Linux PageCache详解","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"proc","slug":"proc","count":2,"path":"api/categories/proc.json"},{"name":"LINUX","slug":"proc/LINUX","count":2,"path":"api/categories/proc/LINUX.json"}],"tags":[{"name":"Cache","slug":"Cache","count":2,"path":"api/tags/Cache.json"},{"name":"cache","slug":"cache","count":2,"path":"api/tags/cache.json"},{"name":"page","slug":"page","count":1,"path":"api/tags/page.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Linux-PageCache%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">Linux PageCache详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%85%B3%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">相关场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-page-cache\"><span class=\"toc-text\">什么是 page cache</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">查看方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#page-cache-%E6%8C%87%E6%A0%87%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">page cache 指标说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SwapCached-%E8%AF%B4%E6%98%8E-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%BC%80%E5%90%AF%EF%BC%8C%E9%98%B2%E6%AD%A2-IO-%E5%BC%95%E8%B5%B7%E6%80%A7%E8%83%BD%E6%8A%96%E5%8A%A8\"><span class=\"toc-text\">SwapCached 说明 (生产环境中不建议开启，防止 IO 引起性能抖动)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Shmem\"><span class=\"toc-text\">Shmem</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#frem-%E5%91%BD%E4%BB%A4%E7%9A%84%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">frem 命令的说明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89\"><span class=\"toc-text\">缓存的具体含义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AE%98%E6%96%B9%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">官方定义</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E8%A7%A3%E9%87%8A\"><span class=\"toc-text\">具体解释</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PageCache-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">PageCache 数据结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-page-cache\"><span class=\"toc-text\">为什么使用 page cache</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#page-cache-%E7%9A%84%E4%BA%A7%E7%94%9F\"><span class=\"toc-text\">page cache 的产生</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A7%E7%94%9F%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">产生方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A7%E7%94%9F%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">产生方式的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99\"><span class=\"toc-text\">常规文件读写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%84%8F%E9%A1%B5\"><span class=\"toc-text\">脏页</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mmap\"><span class=\"toc-text\">mmap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#memory-map-%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E5%A6%82%E4%B8%8B\"><span class=\"toc-text\">memory map 具体步骤如下</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sendfile\"><span class=\"toc-text\">sendfile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99\"><span class=\"toc-text\">顺序读写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E9%A2%84%E8%AF%BB\"><span class=\"toc-text\">文件预读</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">顺序读写高效的原因</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#page-cache-%E7%9A%84%E6%B6%88%E4%BA%A1\"><span class=\"toc-text\">page cache 的消亡</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#sar-B-%E4%B8%8E-x2F-proc-x2F-vmstat-%E6%AF%94%E5%AF%B9\"><span class=\"toc-text\">sar -B 与 &#x2F; proc&#x2F;vmstat 比对</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">其他</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DMA%EF%BC%88Direct-Memory-Access-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%EF%BC%89\"><span class=\"toc-text\">DMA（Direct Memory Access, 直接存储器访问）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98\"><span class=\"toc-text\">堆外内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">堆内存与堆外内存的关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">最佳实践</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PageCache-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">PageCache 内存回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">回收过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D-PageCache-%E5%9B%9E%E6%94%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">避免 PageCache 回收出现的性能问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#memory-cgroup-protection\"><span class=\"toc-text\">memory cgroup protection</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BA%E7%8E%B0-load-%E8%BF%87%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">出现 load 过高的原因</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%BC%95%E8%B5%B7\"><span class=\"toc-text\">直接内存回收引起</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">内存回收过程</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%84%8F%E9%A1%B5%E7%A7%AF%E5%8E%8B%E8%BF%87%E5%A4%9A\"><span class=\"toc-text\">系统中脏页积压过多</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">内存申请过程</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">解决方法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F-numa-%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93\"><span class=\"toc-text\">系统 numa 策略配置不当</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">内存泄漏</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OOM-KILL-%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">OOM KILL 逻辑</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%A7%82%E5%AF%9F%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F\"><span class=\"toc-text\">如何观察内核内存泄漏</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">排查思路</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96-1\"><span class=\"toc-text\">其他</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98-buffer-x2F-cache\"><span class=\"toc-text\">清理缓存 buffer&#x2F;cache</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C-sync-%E5%B0%86-dirty-%E7%9A%84%E5%86%85%E5%AE%B9%E5%86%99%E5%9B%9E%E7%A1%AC%E7%9B%98\"><span class=\"toc-text\">运行 sync 将 dirty 的内容写回硬盘</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9-proc-%E7%B3%BB%E7%BB%9F%E7%9A%84-drop-caches-%E6%B8%85%E7%90%86-free-%E7%9A%84-cache\"><span class=\"toc-text\">通过修改 proc 系统的 drop_caches 清理 free 的 cache</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8-crond-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9A%E6%AF%8F-10-%E5%88%86%E9%92%9F%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1\"><span class=\"toc-text\">可以调用 crond 定时任务：每 10 分钟执行一次</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A6%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">重要配置参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-dirty-ratio%EF%BC%88%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%EF%BC%89\"><span class=\"toc-text\">&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_ratio（同步刷盘）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-dirty-background-ratio%EF%BC%88%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98%EF%BC%89\"><span class=\"toc-text\">&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_background_ratio（异步刷盘）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-dirty-writeback-centisecs\"><span class=\"toc-text\">&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_writeback_centisecs</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-dirty-expire-centisecs\"><span class=\"toc-text\">&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;dirty_expire_centisecs</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-drop-caches\"><span class=\"toc-text\">&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-page-cluster\"><span class=\"toc-text\">&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;page_cluster</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-swapiness\"><span class=\"toc-text\">&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swapiness</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#x2F-proc-x2F-sys-x2F-vm-x2F-vfs-cache-pressure\"><span class=\"toc-text\">&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;vfs_cache_pressure</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Spring Boot 集成 Kafka","uid":"067b852fcc8abb83b4af6ed8c83266b0","slug":"JAVA/Spring Boot 集成 Kafka","date":"2022-04-16T18:36:54.000Z","updated":"2025-12-05T01:46:30.858Z","comments":true,"path":"api/articles/JAVA/Spring Boot 集成 Kafka.json","keywords":"XuGuangSheng","cover":"/covers/spring-boot-kafka.jpg","text":"Spring Boot 集成 KafkaMaven 依赖1234<dependency> <groupId>org.springframework.kafka<...","permalink":"/post/JAVA/Spring Boot 集成 Kafka","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[{"name":"生产方","slug":"生产方","count":1,"path":"api/categories/生产方.json"},{"name":"JAVA","slug":"生产方/JAVA","count":1,"path":"api/categories/生产方/JAVA.json"}],"tags":[{"name":"消费方","slug":"消费方","count":1,"path":"api/tags/消费方.json"},{"name":"offset","slug":"offset","count":1,"path":"api/tags/offset.json"},{"name":"使用事务","slug":"使用事务","count":1,"path":"api/tags/使用事务.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Advanced tuning finding and fixing slow Elasticsearch queries","uid":"19b24bca918ce369e190f8fc79735fce","slug":"MIDDLEWARE/Advanced tuning finding and fixing slow Elasticsearch queries","date":"2022-03-29T10:28:38.000Z","updated":"2025-12-05T01:47:22.979Z","comments":true,"path":"api/articles/MIDDLEWARE/Advanced tuning finding and fixing slow Elasticsearch queries.json","keywords":"XuGuangSheng","cover":"/covers/advanced-tuning-finding-and-fixing-slow-elasticsearch-queries.jpg","text":"Advanced tuning: finding and fixing slow Elasticsearch queriesElasticsearch 是一个非...","permalink":"/post/MIDDLEWARE/Advanced tuning finding and fixing slow Elasticsearch queries","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"elastic","slug":"elastic","count":1,"path":"api/categories/elastic.json"},{"name":"MIDDLEWARE","slug":"elastic/MIDDLEWARE","count":1,"path":"api/categories/elastic/MIDDLEWARE.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"www","slug":"www","count":8,"path":"api/tags/www.json"},{"name":"elasticsearch","slug":"elasticsearch","count":1,"path":"api/tags/elasticsearch.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}