{"title":"Too many open files的四种解决办法","uid":"bf7b35be44144689d93f501402e9fb0d","slug":"LINUX/Too many open files的四种解决办法","date":"2022-12-07T00:21:50.000Z","updated":"2025-12-05T01:47:05.976Z","comments":true,"path":"api/articles/LINUX/Too many open files的四种解决办法.json","keywords":"XuGuangSheng","cover":"/covers/too-many-open-files.jpg","content":"<h1 id=\"Too-many-open-files的四种解决办法\"><a href=\"#Too-many-open-files的四种解决办法\" class=\"headerlink\" title=\"Too many open files的四种解决办法\"></a>Too many open files的四种解决办法</h1><p>【摘要】 Too many open files有四种可能:一 单个进程打开文件句柄数过多,二 操作系统打开的文件句柄数过多,三 systemd对该进程进行了限制,四 inotify达到上限.</p>\n<p>领导见了孔乙己，也每每这样问他，引人发笑。孔乙己自己知道不能和他们谈天，便只好向我们新员工说话。有一回对我说道，“你定位过问题么？”我略略点一点头。他说，“定位过，……我便考你一考。Too many open files，怎样解决？”我想，考评垫底的人，也配考我么？便回过脸去，不再理会。孔乙己等了许久，很恳切的说道，“不能解决罢？……我教给你，记着！这些方法应该记着。将来做接口人的时候，定位问题要用。”我暗想我和接口人的等级还很远呢，而且我们领导也从不将问题定位记功；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不是ulimit太小么？”孔乙己显出极高兴的样子，将两个指头的长指甲敲着白板，点头说，“对呀对呀！……Too many open files有四种可能，你知道么？”我愈不耐烦了，努着嘴走远。孔乙己却像是没有看到，自顾自的在白板上画了起来。</p>\n<h3 id=\"一-单个进程打开文件句柄数过多\"><a href=\"#一-单个进程打开文件句柄数过多\" class=\"headerlink\" title=\"一  单个进程打开文件句柄数过多\"></a>一  单个进程打开文件句柄数过多</h3><p>ulimit中的nofile表示单进程可以打开的最大文件句柄数，可以通过ulimit -a查看，子进程默认继承父进程的限制（注意，是继承，不是共享，子进程和父进程打开的文件句柄数是单独算的）。</p>\n<p>网上还有一种解读是nofile表示单用户可以打开的文件句柄数，因为他们在limit.conf中看到类似于“openstack soft nofile 65536”，便认为是openstack用户最多可以打开的文件句柄数。该解读是错误的，“openstack soft nofile 65536”表示的含义是当你执行”su - openstack”切换到openstack用户后，你创建的所有进程最大可以打开的文件句柄数是65536。</p>\n<p>要查看一个进程可以打开的文件句柄数，可以通过“cat &#x2F;proc&#x2F;<pid>&#x2F;limits”查看。</p>\n<p>要修改ulimit中的nofile，可以通过修改&#x2F;etc&#x2F;security&#x2F;limits.conf文件，在其中加入类似“openstack soft nofile 65536”的语句来进行修改。修改完成后，可以通过“su - openstack”切换用户，或者重新登录，来使该配置生效。</p>\n<p>要动态修改一个进程的限制，可以使用prlimit命令，具体用法为：“prlimit –pid ${pid} –nofile&#x3D;102400:102400”。</p>\n<h3 id=\"二-操作系统打开的文件句柄数过多\"><a href=\"#二-操作系统打开的文件句柄数过多\" class=\"headerlink\" title=\"二 操作系统打开的文件句柄数过多\"></a>二 操作系统打开的文件句柄数过多</h3><p>整个操作系统可以打开的文件句柄数是有限的，受内核参数“fs.file-max”影响。</p>\n<p>可以通过执行“echo 100000000 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max”命令来动态修改该值，也可以通过修改”&#x2F;etc&#x2F;sysctl.conf”文件来永久修改该值。</p>\n<h3 id=\"三-systemd对该进程进行了限制\"><a href=\"#三-systemd对该进程进行了限制\" class=\"headerlink\" title=\"三 systemd对该进程进行了限制\"></a>三 systemd对该进程进行了限制</h3><p>该场景仅针对被systemd管理的进程（也就是可以通过systemctl来控制的进程）生效，可以通过修改该进程的service文件（通常在&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;目录下），在“[Service]”下面添加“LimitNOFILE&#x3D;20480000”来实现，修改完成之后需要执行”systemctl daemon-reload”来使该配置生效。</p>\n<h3 id=\"四-inotify达到上限\"><a href=\"#四-inotify达到上限\" class=\"headerlink\" title=\"四 inotify达到上限\"></a>四 inotify达到上限</h3><p>inotify是linux提供的一种监控机制，可以监控文件系统的变化。该机制受到2个内核参数的影响：“fs.inotify.max_user_instances”和“fs.inotify.max_user_watches”，其中“fs.inotify.max_user_instances”表示每个用户最多可以创建的inotify instances数量上限，“fs.inotify.max_user_watches”表示么个用户同时可以添加的watch数目，当出现too many open files问题而上面三种方法都无法解决时，可以尝试通过修改这2个内核参数来生效。修改方法是修改”&#x2F;etc&#x2F;sysctl.conf”文件，并执行”sysctl -p”。</p>\n","text":"Too many open files的四种解决办法【摘要】 Too many open files有四种可能:一 单个进程打开文件句柄数过多,二 操作系统打开...","permalink":"/post/LINUX/Too many open files的四种解决办法","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"inotify","slug":"inotify","count":1,"path":"api/categories/inotify.json"},{"name":"LINUX","slug":"inotify/LINUX","count":1,"path":"api/categories/inotify/LINUX.json"}],"tags":[{"name":"nofile","slug":"nofile","count":1,"path":"api/tags/nofile.json"},{"name":"openstack","slug":"openstack","count":1,"path":"api/tags/openstack.json"},{"name":"max","slug":"max","count":1,"path":"api/tags/max.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Too-many-open-files%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">Too many open files的四种解决办法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E5%8D%95%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%95%B0%E8%BF%87%E5%A4%9A\"><span class=\"toc-text\">一  单个进程打开文件句柄数过多</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%95%B0%E8%BF%87%E5%A4%9A\"><span class=\"toc-text\">二 操作系统打开的文件句柄数过多</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89-systemd%E5%AF%B9%E8%AF%A5%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8C%E4%BA%86%E9%99%90%E5%88%B6\"><span class=\"toc-text\">三 systemd对该进程进行了限制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B-inotify%E8%BE%BE%E5%88%B0%E4%B8%8A%E9%99%90\"><span class=\"toc-text\">四 inotify达到上限</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"徒手撸框架--高并发环境下的请求合并","uid":"536679e8a77999953c3193ac12ff85df","slug":"JAVA/徒手撸框架--高并发环境下的请求合并","date":"2022-12-28T19:57:07.000Z","updated":"2025-12-05T01:46:49.549Z","comments":true,"path":"api/articles/JAVA/徒手撸框架--高并发环境下的请求合并.json","keywords":"XuGuangSheng","cover":"/covers/6e574f2f4349.jpg","text":"徒手撸框架–高并发环境下的请求合并在高并发系统中，我们经常遇到这样的需求：系统产生大量的请求，但是这些请求实时性要求不高。我们就可以将这些请求合并，达到一定数量...","permalink":"/post/JAVA/徒手撸框架--高并发环境下的请求合并","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"LockSupport","slug":"LockSupport","count":1,"path":"api/categories/LockSupport.json"},{"name":"JAVA","slug":"LockSupport/JAVA","count":1,"path":"api/categories/LockSupport/JAVA.json"}],"tags":[{"name":"底层使用什么数据结构来持有需要合并的请求","slug":"底层使用什么数据结构来持有需要合并的请求","count":1,"path":"api/tags/底层使用什么数据结构来持有需要合并的请求.json"},{"name":"timeOut","slug":"timeOut","count":1,"path":"api/tags/timeOut.json"},{"name":"如何实现定时提交呢","slug":"如何实现定时提交呢","count":1,"path":"api/tags/如何实现定时提交呢.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"strace 常用操作","uid":"a9faca4b916382c99b92d1b36024956a","slug":"LINUX/strace 常用操作","date":"2022-12-07T00:21:02.000Z","updated":"2025-12-05T01:47:10.419Z","comments":true,"path":"api/articles/LINUX/strace 常用操作.json","keywords":"XuGuangSheng","cover":"/covers/strace.jpg","text":"strace 常用操作2019-03-30 前言¶strace 可以用来查看/记录程序运行过程中调用的 系统调用 以及接收到的进程信号（signal）， 对于我...","permalink":"/post/LINUX/strace 常用操作","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"trace","slug":"trace","count":1,"path":"api/categories/trace.json"},{"name":"LINUX","slug":"trace/LINUX","count":1,"path":"api/categories/trace/LINUX.json"}],"tags":[{"name":"strace","slug":"strace","count":2,"path":"api/tags/strace.json"},{"name":"man","slug":"man","count":1,"path":"api/tags/man.json"},{"name":"signal","slug":"signal","count":1,"path":"api/tags/signal.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}