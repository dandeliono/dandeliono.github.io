{"title":"延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟","uid":"9cd0d8d4260de5985eda82c0c9a4fe26","slug":"ALG/延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟","date":"2025-05-23T15:23:11.000Z","updated":"2025-12-05T01:46:01.742Z","comments":true,"path":"api/articles/ALG/延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟.json","keywords":"XuGuangSheng","cover":"/covers/cache-aside.jpg","content":"<h1 id=\"延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟\"><a href=\"#延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟\" class=\"headerlink\" title=\"延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟\"></a>延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟</h1><p><strong>摘要：</strong>  在绝大多数介绍缓存与数据库一致性方案的文章中，随着 Cache-aside 模式的数据变更几乎无例外的推荐使用删除缓存的策略，为进一步降低数据不一致的风险通常会配合延迟双删的策略。但是令人意外的是，在一些互联网大厂中的核心业务却很少使用这种方式。这背后的原因是什么呢？延迟双删策略有什么致命缺陷么？以及这些大厂如何选择缓存与数据库一致性保障的策略呢？如果你对此同样抱有有疑问的话，希望本文能为你答疑解惑。</p>\n<hr>\n<p>当数据库（主副本）数据记录变更时，为了降低缓存数据不一致状态的持续时间，通常会选择主动 失效 &#x2F; 更新 缓存数据的方式。绝大多数应用系统的设计方案中会选择通过删除缓存数据的方式使其失效。但同样会出现数据不一致的情况，具体情况参见下图： <img src=\"https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7621765c6c8b4b6aaa81abe429fbff26~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEFpYmlpaW4=:q75.awebp?rk3s=f64ab15b&x-expires=1748208406&x-signature=zx664FBjo60WYvwVqUtJV/PC7H4=\"><br> 所以延迟双删又成为了组合出现的常见模式。延迟双删最复杂的技术实现在于对延迟时间的确定上，间隔时间久的话数据不一致的状态持续时间会变长，如果间隔时间过短可能无法起到一致性保障的作用。所以基于经验会将这个时间设定在秒级，如 1-2 秒后执行第二次删除操作。</p>\n<h2 id=\"延迟双删的致命缺陷\"><a href=\"#延迟双删的致命缺陷\" class=\"headerlink\" title=\"延迟双删的致命缺陷\"></a>延迟双删的致命缺陷</h2><p>但是延迟时间最大的问题不在于此，而是两次删除缓存数据引起的缓存击穿（Cache Breakdown），短时间对数据库（主副本）造成的流量与负载压力。绝大多数应用系统本身流量与负载并不高，使用缓存通常是为了提升系统性能表现，数据库（主副本）完全可以承载一段时间内的负载压力。对于此类系统延迟双删是一个完全可以接受的高性价比策略。</p>\n<p>现实世界中的系统响应慢所带来的却是流量的加倍上涨。回想一下当你面对 App 响应慢的情况，是如何反应与对待便能明白，几乎所有用户的下意识行为都是如出一辙。</p>\n<p>所以对于那些流量巨大的应用系统而言，短时的访问流量穿透缓存访问数据库（主副本），恐怕很难接受。为了应对这种流量穿透的情况，通常需要增加数据库（主副本）的部署规格或节点。而且这类应用系统的响应变慢的时候，会对其支持系统产生影响，如果其支持系统较多的情况下，会存在影响的增溢。相比延迟双删在技术实现上带来高效便捷而言，其对系统的影响与副作用则变得不可忽视。</p>\n<h2 id=\"Facebook（今-Meta）解决方案\"><a href=\"#Facebook（今-Meta）解决方案\" class=\"headerlink\" title=\"Facebook（今 Meta）解决方案\"></a>Facebook（今 Meta）解决方案</h2><p>早在 2013 年由 Facebook（今 Meta）发表的论文 “Scaling Memcache at Facebook” 中便提供了其内部的解决方案，通过提供一种类似 “锁” 的 “leases”（本文译为“租约”）机制防止并发带来的数据不一致现象。</p>\n<p>租约机制实现方法大致如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当有多个请求抵达缓存时，缓存中并不存在该值时会返回给客户端一个 64 位的 token ，这个 token 会记录该请求，同时该 token 会和缓存键作为绑定，该 token 即为上文中租约的值，客户端在更新时需要传递这个 token ，缓存验证通过后会进行数据的存储。其他请求需要等待这个租约过期后才可申请新的租约。</p></blockquote>\n<p>可结合下图辅助理解其作用机制。也可阅读<a href=\"https://juejin.cn/post/7440021417506979866#heading-5\" title=\"https://juejin.cn/post/7440021417506979866#heading-5\">缓存与主副本数据一致性系统设计方案（下篇）</a>一文中的如何解决并发数据不一致，又能避免延迟双删带来的惊群问题章节进一步了解。 <img src=\"https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a546b2862a14a9986e0cb4ded76b0c3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEFpYmlpaW4=:q75.awebp?rk3s=f64ab15b&x-expires=1748208406&x-signature=2j53YKcmWzIlsVMWQq8/R7JGz2w=\"></p>\n<h3 id=\"简易参考实现\"><a href=\"#简易参考实现\" class=\"headerlink\" title=\"简易参考实现\"></a>简易参考实现</h3><p>接下来我们以 Redis 为例，提供一个 Java 版本的简易参考实现。本文中会给出实现所涉及的关键要素与核心代码，你可以访问 <a href=\"https://link.juejin.cn/?target=https://github.com/HAibiiin/system-design-codebase/tree/master/cache-aside-pattern\" title=\"https://github.com/HAibiiin/system-design-codebase/tree/master/cache-aside-pattern\">Github 项目</a> 来了解整个样例工程，并通过查阅 <a href=\"https://link.juejin.cn/?target=https://github.com/HAibiiin/system-design-codebase/issues/1\" title=\"https://github.com/HAibiiin/system-design-codebase/issues/1\">Issue 与 commits</a> 来了解整个样例工程的演化进程。</p>\n<p>要想实现上述租约机制，需要关注的核心要素有三个：</p>\n<ol>\n<li>需要复写 Redis 数据获取操作，当 Redis 中数据不存在时增加对租约的设置；</li>\n<li>需要复写 Redis 数据设置操作，当设置 Redis 中数据时校验租约的有效性；</li>\n<li>最后是当数据库（主副本）数据变更时，删除 Redis 数据同时要连带删除租约信息。</li>\n</ol>\n<p>同时为了保障 Redis 操作的原子性，我们需要借助 Lua 脚本来实现上述三点。这里以字符串类型为例，对应脚本分别如下：</p>\n<h4 id=\"Redis-数据获取操作\"><a href=\"#Redis-数据获取操作\" class=\"headerlink\" title=\"Redis 数据获取操作\"></a>Redis 数据获取操作</h4><p>返回值的第二个属性作为判断是否需要执行数据获取的判断依据。当为 false 时表示 Redis 中无对应数据，需要从数据库中加载，同时保存了当前请求与 key 对应的租约信息。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> key = KEYS[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">local</span> token = ARGV[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">local</span> value = redis.call(<span class=\"string\">&#x27;get&#x27;</span>, key)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> value <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.replicate_commands()</span><br><span class=\"line\">    <span class=\"keyword\">local</span> lease_key = <span class=\"string\">&#x27;lease:&#x27;</span>..key</span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;set&#x27;</span>, lease_key, token)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"literal\">false</span>, <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;value, <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis-数据设置操作\"><a href=\"#Redis-数据设置操作\" class=\"headerlink\" title=\"Redis 数据设置操作\"></a>Redis 数据设置操作</h4><p>返回值的第二个属性作为判断是否成功执行数据设置操作的依据。该属性为 false 表示租约校验失败，未成功执行数据设置操作。同时意味着有其他进程&#x2F;线程 执行数据查询操作并对该 key 设置了新的租约。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> key = KEYS[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">local</span> token = ARGV[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">local</span> value = ARGV[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">local</span> lease_key = <span class=\"string\">&#x27;lease:&#x27;</span>..key</span><br><span class=\"line\"><span class=\"keyword\">local</span> lease_value = redis.call(<span class=\"string\">&#x27;get&#x27;</span>, lease_key)</span><br><span class=\"line\"><span class=\"keyword\">if</span> lease_value == token <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.replicate_commands()</span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;set&#x27;</span>, key, value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;value, <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"literal\">false</span>, <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis-数据删除操作\"><a href=\"#Redis-数据删除操作\" class=\"headerlink\" title=\"Redis 数据删除操作\"></a>Redis 数据删除操作</h4><p>当数据库变更进程&#x2F;线程 完成数据变更操作后，尝试删除缓存需要同时清理对应数据记录的 key 以及其关联租约 key。防止数据变更前的查询操作通过租约校验，将旧数据写入 Redis 。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> key = KEYS[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">local</span> token = ARGV[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">local</span> lease_key = <span class=\"string\">&#x27;lease:&#x27;</span>..key</span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;del&#x27;</span>, key, leask_key)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>该方案主要的影响在应用层实现，主要在集中在三个方面：</p>\n<ol>\n<li>应用层不能调用 Redis 数据类型的原始操作命令，而是改为调用 <a href=\"https://link.juejin.cn/?target=https://redis.io/docs/latest/commands/eval/\" title=\"https://redis.io/docs/latest/commands/eval/\">EVAL</a> 命令；</li>\n<li>调用 Redis 返回结果数据结构的变更为数组，需要解析数组；</li>\n<li>应用层对于 Redis 的操作变复杂，需要生成租约用的 token，并根据每个阶段返回结果进行后续处理；</li>\n</ol>\n<p>为应对上述三点变化，对应操作 Redis 的 Java 实现如下：</p>\n<h4 id=\"封装返回结果\"><a href=\"#封装返回结果\" class=\"headerlink\" title=\"封装返回结果\"></a>封装返回结果</h4><p>为便于后续操作，首先是对脚本返回结果的封装。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EvalResult</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    String value;  </span><br><span class=\"line\">    <span class=\"type\">boolean</span> effect;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">EvalResult</span><span class=\"params\">(List&lt;?&gt; args)</span> &#123;  </span><br><span class=\"line\">        value = (String) args.get(<span class=\"number\">0</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.get(<span class=\"number\">1</span>) == <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">            effect = <span class=\"literal\">false</span>;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            effect = <span class=\"number\">1</span> == (<span class=\"type\">long</span>) args.get(<span class=\"number\">1</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"组件设计\"><a href=\"#组件设计\" class=\"headerlink\" title=\"组件设计\"></a>组件设计</h4><p><img src=\"https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/74c00055d8a640d09bb8df81273ec30c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEFpYmlpaW4=:q75.awebp?rk3s=f64ab15b&x-expires=1748208406&x-signature=vHowL0waziGlrFwMFVQaSftZqoo=\"></p>\n<h4 id=\"封装-Redis-操作\"><a href=\"#封装-Redis-操作\" class=\"headerlink\" title=\"封装 Redis 操作\"></a>封装 Redis 操作</h4><p>因为在<a href=\"https://link.juejin.cn/?target=https://github.com/HAibiiin/system-design-codebase/tree/master/cache-aside-pattern\" title=\"https://github.com/HAibiiin/system-design-codebase/tree/master/cache-aside-pattern\">样例工程</a>中独立出了一个 Query Engine 组件，所以需要跨组件传递 token，这里为了实现简单采用了 ThreadLocal 进行 token 的传递，具体系统可查阅<a href=\"https://link.juejin.cn/?target=https://github.com/HAibiiin/system-design-codebase/blob/master/cache-aside-pattern/query-engine/src/main/java/io/haibiiin/github/query/engine/SimpleQueryEngine.java\" title=\"https://github.com/HAibiiin/system-design-codebase/blob/master/cache-aside-pattern/query-engine/src/main/java/io/haibiiin/github/query/engine/SimpleQueryEngine.java\">样例工程中的用例</a>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LeaseWrapper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Jedis</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CacheCommands</span> &#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Jedis jedis;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TokenGenerator tokenGenerator;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; tokenHolder;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LeaseWrapper</span><span class=\"params\">(Jedis jedis)</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = jedis;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tokenHolder = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;&gt;();  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.tokenGenerator = () -&gt; UUID.randomUUID().toString();  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">get</span><span class=\"params\">(String key)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.tokenGenerator.get();  </span><br><span class=\"line\">        tokenHolder.set(token);  </span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.jedis.eval(LuaScripts.leaseGet(), List.of(key), List.of(token));  </span><br><span class=\"line\">        <span class=\"type\">EvalResult</span> <span class=\"variable\">er</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EvalResult</span>((List&lt;?&gt;) result);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (er.effect()) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> er.value();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">set</span><span class=\"params\">(String key, String value)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> tokenHolder.get();  </span><br><span class=\"line\">        tokenHolder.remove();  </span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.jedis.eval(LuaScripts.leaseSet(), List.of(key), List.of(token, value));  </span><br><span class=\"line\">        <span class=\"type\">EvalResult</span> <span class=\"variable\">er</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EvalResult</span>((List&lt;?&gt;) result);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (er.effect()) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> er.value();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>在上面的简易参考实现中，我们并没有实现<strong>其他请求需要等待这个租约过期后才可申请新的租约</strong>。该功能主要是防止惊群问题，进一步降低可能对数据库造成的访问压力。要实现该功能需要在 Redis 数据获取操作中改进脚本：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> key = KEYS[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">local</span> token = ARGV[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">local</span> value = redis.call(<span class=\"string\">&#x27;get&#x27;</span>, key)</span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">not</span> value <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.replicate_commands()</span><br><span class=\"line\">    <span class=\"keyword\">local</span> lease_key = <span class=\"string\">&#x27;lease:&#x27;</span>..key</span><br><span class=\"line\">    <span class=\"keyword\">local</span> current_token = redis.call(<span class=\"string\">&#x27;get&#x27;</span>, lease_key)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> current_token <span class=\"keyword\">or</span> token == current_token <span class=\"keyword\">then</span></span><br><span class=\"line\">\t    redis.call(<span class=\"string\">&#x27;set&#x27;</span>, lease_key, token)</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> &#123;token, <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;current_token, <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;value, <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同时也可以为租约数据设定一个短时 TTL，并在应用层通过对 EvalResult 的 effect 判断为 false 的情况下等待一段时间后再次执行。</p>\n<p>上述实现的复杂点在于租约过期的时间的选取，以及超过设定时间的逻辑处理。我们可以实现类似自旋锁的机制，在最大等待时间内随时等待一个间隙向 Redis 发起查询请求，超过最大等待时间后直接查询数据库（主副本）获取数据。</p>\n<h2 id=\"Uber-解决方案\"><a href=\"#Uber-解决方案\" class=\"headerlink\" title=\"Uber 解决方案\"></a>Uber 解决方案</h2><p>在 Uber 今年 2 月份发表的一篇技术博客 <a href=\"https://link.juejin.cn/?target=https://www.uber.com/en-IN/blog/how-uber-serves-over-40-million-reads-per-second-using-an-integrated-cache/\" title=\"https://www.uber.com/en-IN/blog/how-uber-serves-over-40-million-reads-per-second-using-an-integrated-cache/\">“How Uber Serves Over 40 Million Reads Per Second from Online Storage Using an Integrated Cache”</a> 中透露了其内部的解决方案，通过比对版本号的方式避免将旧数据写入缓存。</p>\n<p>版本号比对机制实现方法大致如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>将数据库中行记录的时间戳作为版本号，通过 Lua 脚本通过 Redis EVAL 命令提供类似 MSET 的更新操作，基于自定义编解码器提取 Redis 记录中的版本号，在执行数据设置操作时进行比对，只写入较新的数据。</p></blockquote>\n<p>其中 Redis 的数据记录对应的 Key-Value 编码格式如所示： <img src=\"https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/875ee87fc27642638dff73dd806f309e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEFpYmlpaW4=:q75.awebp?rk3s=f64ab15b&x-expires=1748208406&x-signature=gujPt4ctCe7z9tN53I2GfeqsqkA=\"></p>\n<h3 id=\"简易参考实现-1\"><a href=\"#简易参考实现-1\" class=\"headerlink\" title=\"简易参考实现\"></a>简易参考实现</h3><p>接下来我们以 Redis 为例，提供一个 Java 版本的简易参考实现。本文中会给出实现所涉及的关键要素与核心代码，你可以访问 <a href=\"https://link.juejin.cn/?target=https://github.com/HAibiiin/system-design-codebase/tree/master/cache-aside-pattern\" title=\"https://github.com/HAibiiin/system-design-codebase/tree/master/cache-aside-pattern\">Github 项目</a> 来了解整个样例工程，并通过查阅 <a href=\"https://link.juejin.cn/?target=https://github.com/HAibiiin/system-design-codebase/issues/3\" title=\"https://github.com/HAibiiin/system-design-codebase/issues/3\">Issue 与 commits</a> 来了解整个样例工程的演化进程。</p>\n<p>我们这里不采取定制数据格式，而是通过额外的缓存 Key 存储数据版本，要想实现类似版本号比对机制，需要关注的核心要素有两个：</p>\n<ol>\n<li>需要复写 Redis 数据设置操作，当设置 Redis 中数据时校验版本号；</li>\n<li>在版本号比对通过后需要绑定版本号数据，与主数据同步写入 Redis 中。</li>\n</ol>\n<p>同时为了保障 Redis 操作的原子性，我们需要借助 Lua 脚本来实现上述两点。这里以字符串类型为例，对应脚本分别如下：</p>\n<h4 id=\"Redis-数据设置操作-1\"><a href=\"#Redis-数据设置操作-1\" class=\"headerlink\" title=\"Redis 数据设置操作\"></a>Redis 数据设置操作</h4><p>返回值的第二个属性作为判断是否成功执行数据设置操作的依据。该属性为 false 表示数据未成功写入 Redis。同时意味当前 进程&#x2F;线程 执行写入的数据为历史数据，在次过程中数据已经发生变更并又其他数据写入。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> key = KEYS[<span class=\"number\">1</span>]  </span><br><span class=\"line\"><span class=\"keyword\">local</span> value = ARGV[<span class=\"number\">1</span>]  </span><br><span class=\"line\"><span class=\"keyword\">local</span> current_version = ARGV[<span class=\"number\">2</span>]  </span><br><span class=\"line\"><span class=\"keyword\">local</span> version_key = <span class=\"string\">&#x27;version:&#x27;</span>..key  </span><br><span class=\"line\"><span class=\"keyword\">local</span> version_value = redis.call(<span class=\"string\">&#x27;get&#x27;</span>, version_key)  </span><br><span class=\"line\"><span class=\"keyword\">if</span> version_value == <span class=\"literal\">false</span> <span class=\"keyword\">or</span> version_value &lt; current_version <span class=\"keyword\">then</span>  </span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;mset&#x27;</span>, version_key, current_version, key, value)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;value, <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"literal\">false</span>, <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>该方案主要的影响在应用层实现，需要在调用 Redis 的 EVAL 命令前从数据实体中提取时间戳作为版本号，同时需要保障数据实体中包含时间戳相关属性。</p>\n<h4 id=\"封装-Redis-操作-1\"><a href=\"#封装-Redis-操作-1\" class=\"headerlink\" title=\"封装 Redis 操作\"></a>封装 Redis 操作</h4><p>结合我们的<a href=\"https://link.juejin.cn/?target=https://github.com/HAibiiin/system-design-codebase/tree/master/cache-aside-pattern\" title=\"https://github.com/HAibiiin/system-design-codebase/tree/master/cache-aside-pattern\">样例工程代码</a>，我们通过实现 VersionWrapper 对 Redis 的操作进行如下封装。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VersionWrapper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Jedis</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CacheCommands</span> &#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Jedis jedis;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">VersionWrapper</span><span class=\"params\">(Jedis jedis)</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = jedis;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">set</span><span class=\"params\">(String key, String value, String version)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.jedis.eval(LuaScripts.versionSet(), List.of(key), List.of(value, version));  </span><br><span class=\"line\">        <span class=\"type\">EvalResult</span> <span class=\"variable\">er</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EvalResult</span>((List&lt;?&gt;) result);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (er.effect()) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> er.value();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"补充-1\"><a href=\"#补充-1\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>透过该方案我们推测 Uber 采取的并非数据变更后删除缓存的策略，很可能是更新缓存的策略（在 Uber 的技术博客中也间接的提到了更新缓存的策略）。</p>\n<p>因为整个版本号比对的方式与删除缓存的逻辑相悖。我们抛开 Uber CacheFront 的整体架构，仅仅将该方案应用在简单架构模型中。采取删除缓存的策略，可能会产生如下图所示的结果，此时应用服务 Server - 2 因为查询缓存未获取到值，而从数据库加载并写入缓存，但是此时缓存中写入的为历史旧值，而在该数据过期前或者下次数据变更前，都不会再触发更新了。 <img src=\"https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb8de17e04c34261912e22dd5abd0b9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSEFpYmlpaW4=:q75.awebp?rk3s=f64ab15b&x-expires=1748208406&x-signature=FVZ3asD3oPHcVjHkyxJYhwswqmY=\"><br> 当然对于更新缓存的策略同样面临这个问题，因为当数据变更发生期间，缓存中并没有该数据记录时，通常我们不会采取主动刷新缓存的策略，那么则依然会面对上面的问题。</p>\n<p>而 Uber 的 CacheFront 基于企业内部的 Flux 技术组件实现对缓存的异步处理，通过阅读文章我们也可以发现这个异步延迟在秒级，那么在如此长的时间间隙后，无论采用删除还是更新策略想要产生上图中的不一致现象都比较难，因为对应用系统来说，进程&#x2F;线程阻塞 2-3 秒是很难以忍受的现象，所以通常不会出现如此漫长的阻塞与卡顿。</p>\n<p>如果你想进一步了解如何实现与 Uber 利用 Flux 实现缓存异步处理的内容，也可阅读我们此前<a href=\"https://juejin.cn/post/7440021417506979866#heading-2\" title=\"https://juejin.cn/post/7440021417506979866#heading-2\">缓存与主副本数据一致性系统设计方案（下篇）</a>文章中更新主副本数据后更新缓存并发问题解决方案章节。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文并非对延迟双删的全盘否定，而是强调在特殊场景下，延迟双删策略的弊端会被放大，进而完全盖过其优势。对于那些业务体量大伴随着流量大的应用系统，必应要从中权衡取舍。</p>\n<p>每一种策略都仅适配应用系统生命周期的一段。只不过部分企业随着业务发展逐步壮大，其研发基础设施的能力也更完善。从而为系统设计带来诸多便捷，从而使得技术决策变得与中小研发团队截然不同。</p>\n","text":"延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟摘要： 在绝大多数介绍缓存与数据库一致性...","permalink":"/post/ALG/延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"https","slug":"https","count":12,"path":"api/categories/https.json"},{"name":"ALG","slug":"https/ALG","count":1,"path":"api/categories/https/ALG.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"Redis","slug":"Redis","count":3,"path":"api/tags/Redis.json"},{"name":"design","slug":"design","count":1,"path":"api/tags/design.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0%E5%A6%82%E6%AD%A4%E5%A5%BD%E7%94%A8%EF%BC%8C%E4%B8%BA%E4%BD%95%E5%A4%A7%E5%8E%82%E4%BB%8E%E6%9D%A5%E4%B8%8D%E7%94%A8Cache-aside%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E7%9A%84%E7%AD%96%E7%95%A5%EF%BC%8C%E4%B8%BA%E9%99%8D%E4%BD%8E%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%80%9A%E5%B8%B8%E4%BC%9A%E9%85%8D%E5%90%88%E5%BB%B6%E8%BF%9F\"><span class=\"toc-text\">延迟双删如此好用，为何大厂从来不用Cache-aside下数据变更推荐使用删除缓存的策略，为降低数据不一致通常会配合延迟</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0%E7%9A%84%E8%87%B4%E5%91%BD%E7%BC%BA%E9%99%B7\"><span class=\"toc-text\">延迟双删的致命缺陷</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Facebook%EF%BC%88%E4%BB%8A-Meta%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">Facebook（今 Meta）解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E6%98%93%E5%8F%82%E8%80%83%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">简易参考实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Redis-%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Redis 数据获取操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Redis-%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Redis 数据设置操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Redis-%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Redis 数据删除操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">封装返回结果</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">组件设计</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85-Redis-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">封装 Redis 操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">补充</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Uber-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">Uber 解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E6%98%93%E5%8F%82%E8%80%83%E5%AE%9E%E7%8E%B0-1\"><span class=\"toc-text\">简易参考实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Redis-%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">Redis 数据设置操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85-Redis-%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">封装 Redis 操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85-1\"><span class=\"toc-text\">补充</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Linux 扩容 根分区(LVM+非LVM)","uid":"039f48a281ee50d74a45933d415e35b5","slug":"LINUX/Linux 扩容 根分区(LVM+非LVM)","date":"2025-08-01T14:54:34.000Z","updated":"2025-12-05T01:47:01.869Z","comments":true,"path":"api/articles/LINUX/Linux 扩容 根分区(LVM+非LVM).json","keywords":"XuGuangSheng","cover":"/covers/linux-lvm-lvm.jpg","text":"Linux 扩容 / 根分区(LVM+非LVM)目录： 1，概述 2，CentOS7，LVM根分区扩容步骤 3，CentOS7，非LVM根分区扩容步骤： 一、背...","permalink":"/post/LINUX/Linux 扩容 根分区(LVM+非LVM)","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"https","slug":"https","count":12,"path":"api/categories/https.json"},{"name":"LINUX","slug":"https/LINUX","count":1,"path":"api/categories/https/LINUX.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"pic","slug":"pic","count":2,"path":"api/tags/pic.json"},{"name":"zhimg","slug":"zhimg","count":2,"path":"api/tags/zhimg.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"清除信号量队列导致zabbix自动关闭","uid":"262f61f15e8ffbc737e54526fd907a92","slug":"MIDDLEWARE/清除信号量队列导致zabbix自动关闭","date":"2025-04-24T11:26:42.000Z","updated":"2025-12-05T01:47:49.723Z","comments":true,"path":"api/articles/MIDDLEWARE/清除信号量队列导致zabbix自动关闭.json","keywords":"XuGuangSheng","cover":"/covers/zabbix.jpg","text":"清除信号量队列导致zabbix自动关闭前几天在海外UCloud机器上部署了一套zabbix proxy和zabbix agentd，可是第二天一大早就收到邮件说...","permalink":"/post/MIDDLEWARE/清除信号量队列导致zabbix自动关闭","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"zabbix","slug":"zabbix","count":1,"path":"api/categories/zabbix.json"},{"name":"MIDDLEWARE","slug":"zabbix/MIDDLEWARE","count":1,"path":"api/categories/zabbix/MIDDLEWARE.json"}],"tags":[{"name":"proxy","slug":"proxy","count":1,"path":"api/tags/proxy.json"},{"name":"file","slug":"file","count":1,"path":"api/tags/file.json"},{"name":"line","slug":"line","count":1,"path":"api/tags/line.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}