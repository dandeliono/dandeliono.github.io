{"title":"如何在 Docker 容器中使用 systemctl","uid":"cf58df7d33c8bd4e506c71804d861dcc","slug":"OCI/如何在 Docker 容器中使用 systemctl","date":"2024-01-29T14:59:56.000Z","updated":"2025-12-05T01:48:01.140Z","comments":true,"path":"api/articles/OCI/如何在 Docker 容器中使用 systemctl.json","keywords":"XuGuangSheng","cover":"/covers/docker-systemctl.jpg","content":"<h1 id=\"如何在-Docker-容器中使用-systemctl\"><a href=\"#如何在-Docker-容器中使用-systemctl\" class=\"headerlink\" title=\"如何在 Docker 容器中使用 systemctl\"></a>如何在 Docker 容器中使用 systemctl</h1><p>我们有时在使用 docker 的时候，会发现在容器中使用 systemctl 或者 service 的时候，会遇到下面的错误：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failed <span class=\"built_in\">to</span> connect <span class=\"built_in\">to</span> bus: No such <span class=\"built_in\">file</span> <span class=\"keyword\">or</span> <span class=\"built_in\">directory</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>一、原因</strong></p>\n<p>That’s because “systemctl” talks to the systemd daemon by using the d-bus. In a container there is no systemd-daemon. Asking for a start will probably not quite do what you expect - the dev-mapping need to be a bit longer.</p>\n<p>容器里面是没有 systemd 进程的，所以不能正常开启 systemctl 。为什么 docker 会这样呢：</p>\n<p>This is by design. Docker should be running a process in the foreground in your container and it will be spawned as PID 1 within the container’s pid namespace. Docker is designed for process isolation, not for OS virtualization, so there are no other OS processes and daemons running inside the container (like systemd, cron, syslog, etc), only your entrypoint or command you run.</p>\n<p>If they included systemd commands, you’d find a lot of things not working since your entrypoint replaces init. Systemd also makes use to cgroups which docker restricts inside of containers since the ability to change cgroups could allow a process to escape the container’s isolation. Without systemd running as init inside your container, there’s no daemon to process your start and stop commands.</p>\n<p>docker只是提供了进程隔离，不是操作系统的虚拟。</p>\n<p><strong>二、解决方案</strong></p>\n<p><strong>1、网上流传一种错误的解决方法。</strong> </p>\n<p>我们可以在启动容器的时候将在启动参数加上 &#x2F;sbin&#x2F;init 来让其生效。</p>\n<p>以centos为例：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -v /sys/fs/cgroup/<span class=\"symbol\">:/sys/fs/cgroup</span><span class=\"symbol\">:ro</span> --cap-add <span class=\"title class_\">SYS_ADMIN</span> --name systemd_websrv centos /sbin/init</span><br></pre></td></tr></table></figure>\n\n<p>以上为网上流传的方法，我先为大家解释一下这条命令：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">-</span>d：表示以后台进程的形式运行 <span class=\"type\">Docker</span> 容器<span class=\"operator\">。</span></span><br><span class=\"line\"><span class=\"operator\">-</span>v <span class=\"regexp\">/sys/</span>fs<span class=\"regexp\">/cgroup/</span>:<span class=\"regexp\">/sys/</span>fs<span class=\"regexp\">/cgroup:ro：表示将主机的 /</span>sys<span class=\"regexp\">/fs/</span>cgroup 目录挂载到容器中的 <span class=\"regexp\">/sys/</span>fs<span class=\"operator\">/</span>cgroup 目录，并以只读的方式挂载<span class=\"operator\">。</span>这个目录包含了 cgroups 系统的配置文件，用于管理系统资源的分配<span class=\"operator\">。</span>（:ro表示以只读方式挂载，当然:rw表示以读写方式挂载）</span><br><span class=\"line\"><span class=\"operator\">--</span>cap<span class=\"operator\">-</span>add <span class=\"type\">SYS_ADMIN：表示为容器添加</span> <span class=\"type\">SYS_ADMIN</span> 的能力，以便容器能够访问系统的一些管理功能<span class=\"operator\">。</span></span><br><span class=\"line\"><span class=\"operator\">--</span>name systemd_websrv：表示将容器命名为 <span class=\"string\">&quot;systemd_websrv&quot;</span><span class=\"operator\">。</span></span><br><span class=\"line\">centos <span class=\"regexp\">/sbin/</span><span class=\"keyword\">init</span>：表示使用 <span class=\"type\">CentOS</span> 镜像来创建容器，并在容器中运行 <span class=\"regexp\">/sbin/</span><span class=\"keyword\">init</span> 程序<span class=\"operator\">。/</span>sbin<span class=\"operator\">/</span><span class=\"keyword\">init</span> 是系统启动时运行的第一个进程，它负责启动系统的其他进程<span class=\"operator\">。</span></span><br></pre></td></tr></table></figure>\n\n<p>我们尝试运行这条命令，然后使用如下命令查询 systemctl 在容器里是否正常工作。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -<span class=\"keyword\">it</span> systemd_websrv systemctl</span><br><span class=\"line\">Failed <span class=\"built_in\">to</span> connect <span class=\"built_in\">to</span> bus: No such <span class=\"built_in\">file</span> <span class=\"keyword\">or</span> <span class=\"built_in\">directory</span></span><br></pre></td></tr></table></figure>\n\n<p>错误的原因可能是在启动 Docker 容器时没有正确挂载容器内的 &#x2F;run&#x2F;dbus 目录。我们使用如下命令将 &#x2F;run&#x2F;dbus 挂载上。</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> docker stop systemd_websrv</span><br><span class=\"line\">docker rm systemd_websrv</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -d -v <span class=\"string\">/sys/fs/cgroup</span>:<span class=\"string\">/sys/fs/cgroup</span><span class=\"function\">:ro</span> -v <span class=\"string\">/run/dbus</span>:<span class=\"string\">/run/dbus</span> -v <span class=\"string\">/etc/machine-id</span>:<span class=\"string\">/etc/machine-id</span> <span class=\"params\">--cap-add</span> SYS_ADMIN <span class=\"params\">--name</span> systemd_websrv centos <span class=\"string\">/sbin/init</span></span><br></pre></td></tr></table></figure>\n\n<p>再次尝试运行这条命令，然后使用如下命令查询 systemctl 在容器里是否正常工作。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -<span class=\"keyword\">it</span> systemd_websrv systemctl</span><br><span class=\"line\">Failed <span class=\"keyword\">to</span> connect <span class=\"keyword\">to</span> bus: Permission denied</span><br></pre></td></tr></table></figure>\n\n<p>这次提示的是没有权限了，继续改命令。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> docker stop systemd_websrv</span><br><span class=\"line\">docker rm systemd_websrv</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -ti -v <span class=\"regexp\">/run/</span>dbus<span class=\"regexp\">/system_bus_socket:/</span>run<span class=\"regexp\">/dbus/</span>system_bus_socket:ro -v <span class=\"regexp\">/sys/</span>fs<span class=\"regexp\">/cgroup/</span>:<span class=\"regexp\">/sys/</span>fs<span class=\"regexp\">/cgroup:ro --cap-add SYS_ADMIN --name systemd_websrv centos /</span>bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>这次可以了，进入 Docker容器了，我们尝试查询 systemctl 能否正常使用。</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status</span><br><span class=\"line\">System has <span class=\"built_in\">not</span> been booted <span class=\"keyword\">with</span> systemd <span class=\"keyword\">as</span> init system (PID <span class=\"number\">1</span>). Can<span class=\"comment\">&#x27;t operate.</span></span><br><span class=\"line\">Failed <span class=\"keyword\">to</span> connect <span class=\"keyword\">to</span> bus: Host <span class=\"built_in\">is</span> down</span><br></pre></td></tr></table></figure>\n\n<p>PID 1 是什么东东？我们尝试使用如下命令查询一下。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ps</span> aux</span><br><span class=\"line\"><span class=\"attribute\">USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class=\"line\"><span class=\"attribute\">root</span>         <span class=\"number\">1</span>  <span class=\"number\">0</span>.<span class=\"number\">0</span>  <span class=\"number\">0</span>.<span class=\"number\">4</span>  <span class=\"number\">12036</span>  <span class=\"number\">2160</span> ?        Ss   <span class=\"number\">08</span>:<span class=\"number\">16</span>   <span class=\"number\">0</span>:<span class=\"number\">00</span> /bin/bash</span><br><span class=\"line\"><span class=\"attribute\">root</span>        <span class=\"number\">16</span>  <span class=\"number\">0</span>.<span class=\"number\">0</span>  <span class=\"number\">0</span>.<span class=\"number\">4</span>  <span class=\"number\">44652</span>  <span class=\"number\">1780</span> ?        R+   <span class=\"number\">08</span>:<span class=\"number\">20</span>   <span class=\"number\">0</span>:<span class=\"number\">00</span> ps aux</span><br></pre></td></tr></table></figure>\n\n<p>由于 init 进程 PID 1 是 &#x2F;bin&#x2F;bash，而不是 systemd，即使挂载了 dbus 也无济于事。因此这条路是行不通的。</p>\n<p><strong>2、正确的解决方法：替换 systemctl</strong></p>\n<p>使用 <a href=\"https://github.com/gdraheim/docker-systemctl-replacement\">docker-systemctl-replacement</a> 替换容器中的 systemctl 。</p>\n<p>以 ubuntu 镜像为例：</p>\n<p>1). 安装python2</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt <span class=\"keyword\">install</span> python</span><br></pre></td></tr></table></figure>\n\n<p>2). 替换 systemctl (注意路径，可以使用 where is systemctl 查看当前默认路径)</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:<span class=\"regexp\">//</span>raw.githubusercontent.com<span class=\"regexp\">/gdraheim/</span>docker-systemctl-replacement<span class=\"regexp\">/master/</span>files<span class=\"regexp\">/docker/</span>systemctl.py -O <span class=\"regexp\">/bin/</span>systemctl</span><br></pre></td></tr></table></figure>\n\n<p>3). 给定权限</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">chmod</span> a+x /bin/systemctl</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以使用非 systemd 的 systemctl ，但是因为是非官方的 systemctl 所以可能存在一些未知问题。</p>\n<p>最好还是建议将 docker 作为进程隔离环境，single app single container， 但是遇到非常特殊的情况下，可以使用上述解决方案，如果有更好的方案，欢迎反馈。</p>\n<p><strong>三、参考</strong></p>\n<p><a href=\"https://stackoverflow.com/questions/49285658/how-to-solve-docker-issue-failed-to-connect-to-bus-no-such-file-or-directory\">https://stackoverflow.com/questions/49285658/how-to-solve-docker-issue-failed-to-connect-to-bus-no-such-file-or-directory</a><br><a href=\"https://stackoverflow.com/questions/39169403/systemd-and-systemctl-within-ubuntu-docker-images\">https://stackoverflow.com/questions/39169403/systemd-and-systemctl-within-ubuntu-docker-images</a><br>[<a href=\"https://super-unix.com/ubuntu/ubuntu-systemctl-failed-to-connect-to-bus-docker-ubuntu16-04-container/]\">https://super-unix.com/ubuntu/ubuntu-systemctl-failed-to-connect-to-bus-docker-ubuntu16-04-container/]</a></p>\n","text":"如何在 Docker 容器中使用 systemctl我们有时在使用 docker 的时候，会发现在容器中使用 systemctl 或者 service 的时候，...","permalink":"/post/OCI/如何在 Docker 容器中使用 systemctl","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"systemctl","slug":"systemctl","count":1,"path":"api/categories/systemctl.json"},{"name":"OCI","slug":"systemctl/OCI","count":1,"path":"api/categories/systemctl/OCI.json"}],"tags":[{"name":"docker","slug":"docker","count":4,"path":"api/tags/docker.json"},{"name":"systemd","slug":"systemd","count":1,"path":"api/tags/systemd.json"},{"name":"the","slug":"the","count":1,"path":"api/tags/the.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%9C%A8-Docker-%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8-systemctl\"><span class=\"toc-text\">如何在 Docker 容器中使用 systemctl</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"NullPointerException 没有打印异常栈问题追踪","uid":"f3f0b4e51e77515a8031a4140316d20f","slug":"JAVA/NullPointerException 没有打印异常栈问题追踪","date":"2024-01-31T16:27:01.000Z","updated":"2025-12-05T01:46:26.401Z","comments":true,"path":"api/articles/JAVA/NullPointerException 没有打印异常栈问题追踪.json","keywords":"XuGuangSheng","cover":"/covers/nullpointerexception.jpg","text":"NullPointerException 没有打印异常栈问题追踪今天去服务器后台看日志，发现有很多NullPointerException异常。我下意识的去找异...","permalink":"/post/JAVA/NullPointerException 没有打印异常栈问题追踪","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"JVM","slug":"JVM","count":1,"path":"api/categories/JVM.json"},{"name":"JAVA","slug":"JVM/JAVA","count":1,"path":"api/categories/JVM/JAVA.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"www","slug":"www","count":8,"path":"api/tags/www.json"},{"name":"NullPointerException","slug":"NullPointerException","count":1,"path":"api/tags/NullPointerException.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"linux TOP命令各参数详解","uid":"c4719cbd659f86d7d7d8c9fcfcd72c3e","slug":"LINUX/linux TOP命令各参数详解","date":"2024-01-18T11:57:19.000Z","updated":"2025-12-05T01:47:09.020Z","comments":true,"path":"api/articles/LINUX/linux TOP命令各参数详解.json","keywords":"XuGuangSheng","cover":"/covers/linux-top.jpg","text":"linux TOP命令各参数详解[toc] TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程...","permalink":"/post/LINUX/linux TOP命令各参数详解","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"CPU","slug":"CPU","count":5,"path":"api/categories/CPU.json"},{"name":"LINUX","slug":"CPU/LINUX","count":4,"path":"api/categories/CPU/LINUX.json"}],"tags":[{"name":"top","slug":"top","count":1,"path":"api/tags/top.json"},{"name":"单位","slug":"单位","count":1,"path":"api/tags/单位.json"},{"name":"total","slug":"total","count":2,"path":"api/tags/total.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}