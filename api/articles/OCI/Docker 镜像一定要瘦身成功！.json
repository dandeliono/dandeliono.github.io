{"title":"Docker 镜像一定要瘦身成功！","uid":"36b3336ca3e4df2e2f8cc5b82199f426","slug":"OCI/Docker 镜像一定要瘦身成功！","date":"2024-04-28T14:19:56.000Z","updated":"2025-12-05T01:47:54.505Z","comments":true,"path":"api/articles/OCI/Docker 镜像一定要瘦身成功！.json","keywords":"XuGuangSheng","cover":"/covers/docker.jpg","content":"<h1 id=\"Docker-镜像一定要瘦身成功！\"><a href=\"#Docker-镜像一定要瘦身成功！\" class=\"headerlink\" title=\"Docker 镜像一定要瘦身成功！\"></a>Docker 镜像一定要瘦身成功！</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"# 简介\"></a><a href=\"#%E7%AE%80%E4%BB%8B\">#</a> 简介</h2><p>容器镜像类似于虚拟机镜像，封装了程序的运行环境，保证了运行环境的一致性，使得我们可以一次创建任意场景部署运行。镜像构建的方式有两种，一种是通过 docker build 执行 Dockerfile 里的指令来构建镜像，另一种是通过 docker commit 将存在的容器打包成镜像，通常我们都是使用第一种方式来构建容器镜像。</p>\n<p>在构建 docker 容器时，我们一般希望尽量减小镜像，以便加快镜像的分发；但是不恰当的镜像构建方式，很容易导致镜像过大，造成带宽和磁盘资源浪费，尤其是遇到 daemonset 这种需要在每台机器上拉取镜像的服务，会造成大量资源浪费；而且镜像过大还会影响服务的启动速度，尤其是处理紧急线上镜像变更时，直接影响变更的速度。如果不是刻意控制镜像大小、注意镜像瘦身，一般的业务系统中可能 90% 以上的大镜像都存在镜像空间浪费的现象（不信可以尝试检测看看）。因此我们非常有必要了解镜像瘦身方法，减小容器镜像。</p>\n<h2 id=\"如何判断镜像是否需要瘦身\"><a href=\"#如何判断镜像是否需要瘦身\" class=\"headerlink\" title=\"# 如何判断镜像是否需要瘦身\"></a><a href=\"#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%95%9C%E5%83%8F%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E7%98%A6%E8%BA%AB\">#</a> 如何判断镜像是否需要瘦身</h2><p>通常，我们可能都是在容器镜像过大，明显影响到镜像上传&#x2F;拉取速度时，才会考虑到分析镜像，尝试镜像瘦身。此时采用的多是 docker image history 等 docker 自带的镜像分析命令，以查看镜像构建历史、镜像大小在各层的分布等。然后根据经验判断是否存在空间浪费，但是这种判断方式起点较高、没有量化，不方便自动化判断。当前，社区中也有很多镜像分析工具，其中比较流行的 <a href=\"https://link.zhihu.com/?target=https://github.com/wagoodman/dive\">dive (opens new window)</a> 分析工具，就可以量化给出_容器镜像有效率_、_镜像空间浪费率_等指标，如下图： <img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/95758f46-182f-405e-889a-4cef2bd05309.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<p>采用 dive 对一个 mysql 镜像进行效率分析，发现镜像有效率只有 41%，镜像空间浪费率高达 59%，显然需要瘦身。</p>\n<h2 id=\"如何进行镜像瘦身\"><a href=\"#如何进行镜像瘦身\" class=\"headerlink\" title=\"# 如何进行镜像瘦身\"></a><a href=\"#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB\">#</a> 如何进行镜像瘦身</h2><p>当判断一个镜像需要瘦身后，我们就需要知道如何进行镜像瘦身，下面将结合具体案例讲解一些典型的镜像瘦身方法。</p>\n<h3 id=\"多阶段构建\"><a href=\"#多阶段构建\" class=\"headerlink\" title=\"# 多阶段构建\"></a><a href=\"#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA\">#</a> 多阶段构建</h3><p>所谓多阶段构建，实际上是允许在一个 Dockerfile 中出现多个 FROM 指令。最后生成的镜像，以最后一条 FROM 构建阶段为准，之前的 FROM 构建阶段会被抛弃。通过多阶段构建，后一个阶段的构建过程可以直接利用前一阶段的构建缓存，有效降低镜像大小。一个典型的场景是将编译环境和运行环境分离，以一个 go 项目镜像构建过程为例：</p>\n<p>这种传统的构建方式有以下缺点：</p>\n<ul>\n<li>基础镜像为支持编译环境，包含大量go语言的工具&#x2F;库，而运行时并不需要</li>\n<li>COPY 源码，增加了镜像分层，同时有源码泄漏风险</li>\n</ul>\n<p>采用多阶段构建方式，可以将上述传统的构建方式修改如下：</p>\n<p>可以看到，使用多阶段构建，可以获取如下好处：</p>\n<ul>\n<li>最终镜像只关心运行时，采用了更小的基础镜像。</li>\n<li>直接拷贝上一个编译阶段的编译结果，减少了镜像分层，还避免了源码泄漏。</li>\n</ul>\n<h3 id=\"减少镜像分层\"><a href=\"#减少镜像分层\" class=\"headerlink\" title=\"# 减少镜像分层\"></a><a href=\"#%E5%87%8F%E5%B0%91%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82\">#</a> 减少镜像分层</h3><p>镜像的层就像 Git 的提交（commit）一样，用于保存镜像的当前版本与上一版本之间的差异，但是镜像层会占用空间，拥有的层越多，最终的镜像就越大。在构建镜像时，RUN, ADD, COPY 指令对应的层会增加镜像大小，其他命令并不会增加最终的镜像大小。下面以实际工作中的一个案例讲解如何减少镜像分层，以减小镜像大小。</p>\n<h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"# 背景\"></a><a href=\"#%E8%83%8C%E6%99%AF\">#</a> 背景</h4><p>测试项目 mysql 镜像时，遇到了容器创建比较慢的情况，我们发现主要是因为容器镜像较大，拉取镜像时间较长，所以就打算看看 mysql 镜像为什么这么大，是否可以减小容器镜像。</p>\n<h4 id=\"镜像大小分析\"><a href=\"#镜像大小分析\" class=\"headerlink\" title=\"# 镜像大小分析\"></a><a href=\"#%E9%95%9C%E5%83%8F%E5%A4%A7%E5%B0%8F%E5%88%86%E6%9E%90\">#</a> 镜像大小分析</h4><p>通过 docker image history 查看镜像构建历史及各层大小。</p>\n<p>镜像大小：2.9GB <img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/04740084-a9c8-4697-bac2-2585d44a8ec4.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<p>其相应 Dockerfile 如下：</p>\n<p>可以发现：Dockerfile 中存在过多分散的 RUN&#x2F;COPY 指令，而且还是大文件相关操作，导致了过多的镜像分层，使得镜像过大，可以尝试合并相关指令，以减小镜像分层。</p>\n<h4 id=\"合并-RUN-指令\"><a href=\"#合并-RUN-指令\" class=\"headerlink\" title=\"# 合并 RUN 指令\"></a><a href=\"#%E5%90%88%E5%B9%B6-run-%E6%8C%87%E4%BB%A4\">#</a> 合并 RUN 指令</h4><p>该 Dockerfile 中 RUN 指令较多，可以将 RUN 指令合并到同一层：</p>\n<p>编译后镜像大小显著下降：</p>\n<p>镜像大小：1.92GB <img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/51e56a78-2cc6-41be-9d04-1a0869708ace.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<h4 id=\"COPY-指令转换合并到-RUN-指令\"><a href=\"#COPY-指令转换合并到-RUN-指令\" class=\"headerlink\" title=\"# COPY 指令转换合并到 RUN 指令\"></a><a href=\"#copy-%E6%8C%87%E4%BB%A4%E8%BD%AC%E6%8D%A2%E5%90%88%E5%B9%B6%E5%88%B0-run-%E6%8C%87%E4%BB%A4\">#</a> COPY 指令转换合并到 RUN 指令</h4><p>从上图中可以看到，一个较大的镜像层是 COPY 指令导致的，拷贝的文件较大，所以我们考虑将 COPY 指令转换合并到 RUN 指令；具体做法是将文件上传到 oss，在 RUN 指令中下载。当然也可以发现之前还有一个 RUN 指令漏掉没有合并，需要继续合并到已有 RUN 指令中。</p>\n<p>RUN curl -o &#x2F;tmp&#x2F;mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar <a href=\"https://xxx.oss.aliyuncs.com/addon-pkgs/mysql-5.7.29-1.el7.x86/_64.rpm-bundle.tar\">https://xxx.oss.aliyuncs.com/addon-pkgs/mysql-5.7.29-1.el7.x86\\_64.rpm-bundle.tar</a> &amp;&amp;<br>tar -vxf &#x2F;tmp&#x2F;mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar &amp;&amp;<br>…</p>\n<p>编译后镜像大小显著下降：</p>\n<p>镜像大小： 1.27GB</p>\n<p><strong>注意</strong>：此处主要是因为 COPY 指令操作的相关文件较大，对应层占用空间较多，才会将 COPY 指令转换合并到RUN 指令；如果其对应层占用空间较小，则只需分别合并 COPY 指令、RUN 指令，会更加清晰，而没必要将两者转换合并到一层。</p>\n<h3 id=\"减少容器中不必要的包\"><a href=\"#减少容器中不必要的包\" class=\"headerlink\" title=\"# 减少容器中不必要的包\"></a><a href=\"#%E5%87%8F%E5%B0%91%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%8C%85\">#</a> 减少容器中不必要的包</h3><p>还是以上述 mysql 镜像为例，我们发现下载的包 mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar 包含如下 rpm 包：</p>\n<p><img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/c80f9c7d-e8e8-42c1-a69c-c79d5a125a3a.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<p>而安装所需的 rmp 包只有：</p>\n<p><img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/8e366572-f26e-4de6-871d-493eaea2de1d.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<p>删除不必要的包，用最新的最小 rpm 压缩包替换 mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar 后重新编译镜像：</p>\n<p>镜像大小： 1.19GB</p>\n<h2 id=\"镜像分析工具\"><a href=\"#镜像分析工具\" class=\"headerlink\" title=\"# 镜像分析工具\"></a><a href=\"#%E9%95%9C%E5%83%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7\">#</a> 镜像分析工具</h2><p>前面我们通过 docker 自带的 docker image history 命令分析镜像，本节主要讲解镜像分析工具 <a href=\"https://github.com/wagoodman/dive\">dive (opens new window)</a> 的使用，其主要特征如下：</p>\n<ul>\n<li>按层显示 Docker 镜像内容</li>\n<li>指出每一层的变化</li>\n<li>评估 “镜像的效率”，浪费的空间</li>\n<li>快速的构建&#x2F;分析周期</li>\n<li>和 CI 集成，方便自动化检测镜像效率是否合格</li>\n</ul>\n<h3 id=\"镜像效率分析\"><a href=\"#镜像效率分析\" class=\"headerlink\" title=\"# 镜像效率分析\"></a><a href=\"#%E9%95%9C%E5%83%8F%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90\">#</a> 镜像效率分析</h3><p>之前是通过 docker image history 分析镜像体积分布，并进行镜像瘦身，此处将采用 dive 分析镜像有效率。</p>\n<p>使用方法：dive <image_name></p>\n<h4 id=\"优化前\"><a href=\"#优化前\" class=\"headerlink\" title=\"# 优化前\"></a><a href=\"#%E4%BC%98%E5%8C%96%E5%89%8D\">#</a> 优化前</h4><p><strong>原始镜像有效率</strong>: 41%，大部分镜像体积都是浪费的。</p>\n<p>如下： <img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/27df5d5a-cfa8-4a55-9567-d6bd1265046d.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<h4 id=\"优化后\"><a href=\"#优化后\" class=\"headerlink\" title=\"# 优化后\"></a><a href=\"#%E4%BC%98%E5%8C%96%E5%90%8E\">#</a> 优化后</h4><p><strong>优化后镜像有效率：97%</strong></p>\n<p><strong>注意：</strong>优化后，镜像分层明显减少，镜像有效率显著提高；但是此时的镜像效率提升主要是依靠减少浪费空间获取的，如果要继续优化镜像体积，需要结合镜像体积瓶颈点评估下一步优化方向。一个通常的继续优化点是：减小基础镜像体积和不必要的包。</p>\n<p>如下所示： <img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/f5f68c6b-b4ba-4659-90d8-eb12e07055e6.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<h3 id=\"番外篇：如何通过镜像恢复-Dockerfile\"><a href=\"#番外篇：如何通过镜像恢复-Dockerfile\" class=\"headerlink\" title=\"# 番外篇：如何通过镜像恢复 Dockerfile\"></a><a href=\"#%E7%95%AA%E5%A4%96%E7%AF%87-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E9%95%9C%E5%83%8F%E6%81%A2%E5%A4%8D-dockerfile\">#</a> 番外篇：如何通过镜像恢复 Dockerfile</h3><p>前面主要通过镜像分析工具分析镜像体积分布，发现浪费空间，优化镜像大小。镜像分析工具的另一个典型应用场景是：当只有容器镜像时如何通过镜像恢复 Dockerfile？</p>\n<h4 id=\"镜像构建历史查看\"><a href=\"#镜像构建历史查看\" class=\"headerlink\" title=\"# 镜像构建历史查看\"></a><a href=\"#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2%E6%9F%A5%E7%9C%8B\">#</a> 镜像构建历史查看</h4><p>一般，我们可以通过 docker image history 查看镜像构建历史、镜像层及对应的构建指令，从而还原出对应Dockerfile。</p>\n<p><strong>注意</strong>：docker image history 查看对应的构建命令可能显示不全，需要带上 –no-trunc 选项。</p>\n<p>这种方法有如下缺陷：</p>\n<ul>\n<li><p>一些指令信息提取不完整、不易读，如 COPY&#x2F;ADD 指令，对应的操作文件用 id 表示，如下图所示。 <img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/a48e46c4-5fd5-4975-bffc-71497eb29a1f.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n</li>\n<li><p>对于一些镜像层，不是通过 Dockerfile 指令构建出来的，而是直接通过修改容器内容，然后 docker commit 生成，不方便查看该层变更的文件。</p>\n</li>\n</ul>\n<h4 id=\"借助-dive-分析工具还原\"><a href=\"#借助-dive-分析工具还原\" class=\"headerlink\" title=\"# 借助 dive 分析工具还原\"></a><a href=\"#%E5%80%9F%E5%8A%A9-dive-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E8%BF%98%E5%8E%9F\">#</a> 借助 dive 分析工具还原</h4><p>借助 dive 分析工具还原 Dockerfile，主要是因为 dive 可以指出每一层的变化，如下：</p>\n<ul>\n<li>可以根据 COPY 层变化内容（右侧），直观判断拷贝的文件。</li>\n<li>因为可以查看每一层的变化，所以对于 docker commit 也更容易分析相关操作对应的变动范围。</li>\n</ul>\n<p><img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/1d732a27-6309-4dfc-bb7e-c49291f4cff5.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"# 思考\"></a><a href=\"#%E6%80%9D%E8%80%83\">#</a> 思考</h2><h3 id=\"镜像变胖的原因\"><a href=\"#镜像变胖的原因\" class=\"headerlink\" title=\"# 镜像变胖的原因\"></a><a href=\"#%E9%95%9C%E5%83%8F%E5%8F%98%E8%83%96%E7%9A%84%E5%8E%9F%E5%9B%A0\">#</a> 镜像变胖的原因</h3><p>镜像变胖的原因很多，如：</p>\n<ul>\n<li>无用文件，比如编译过程中的依赖文件对编译或运行无关的指令被引入到镜像</li>\n<li>系统镜像冗余文件多</li>\n<li>各种日志文件，缓存文件</li>\n<li>重复编译中间文件</li>\n<li>重复拷贝资源文件</li>\n<li>运行无依赖文件</li>\n</ul>\n<p>但是一般情况是，用户可能对少量的镜像空间浪费不那么敏感；但是在操作大文件时，一些不当的指令（RUN&#x2F;COPY&#x2F;ADD）使用方式却很容易造成大量的空间浪费，此时尤其要注意镜像分析与镜像瘦身。</p>\n<h3 id=\"镜像瘦身难吗\"><a href=\"#镜像瘦身难吗\" class=\"headerlink\" title=\"# 镜像瘦身难吗\"></a><a href=\"#%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB%E9%9A%BE%E5%90%97\">#</a> 镜像瘦身难吗</h3><p>对于基础镜像的减小、系统包的减小，将镜像体积从 200M 减小到 190M 等可能相对难些，此时需要对程序镜像非常熟悉，并结合专门的分析工具具体分析。但是一般场景下，镜像的浪费很可能仅仅是因为镜像构建命令的使用姿势不佳。此时结合本文的镜像瘦身方法，和 Dockerfile 最佳实践，一般都能实现镜像瘦身。</p>\n<h3 id=\"如何评价瘦身效果（镜像效率）\"><a href=\"#如何评价瘦身效果（镜像效率）\" class=\"headerlink\" title=\"# 如何评价瘦身效果（镜像效率）\"></a><a href=\"#%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E7%98%A6%E8%BA%AB%E6%95%88%E6%9E%9C-%E9%95%9C%E5%83%8F%E6%95%88%E7%8E%87\">#</a> 如何评价瘦身效果（镜像效率）</h3><p>如果可以评价镜像的空间使用效率，一方面可以比较直观的判断哪些镜像空降浪费严重，需要瘦身；另一方面也可以对瘦身的效果进行评价。上文介绍的，镜像分析工具 <a href=\"https://github.com/wagoodman/dive\">dive (opens new window)</a> 即可满足要求。</p>\n<h3 id=\"CI-集成\"><a href=\"#CI-集成\" class=\"headerlink\" title=\"# CI 集成\"></a><a href=\"#ci-%E9%9B%86%E6%88%90\">#</a> CI 集成</h3><p>如果需要对大量镜像的体积使用效率进行把关，就必须将效率检测作为自动化流程的一环，而 <a href=\"https://github.com/wagoodman/dive\">dive (opens new window)</a> 就比较容易集成到 CI 中，只需执行如下指令：</p>\n<p>CI&#x3D;true dive <code>&lt;image-name&gt;</code></p>\n<p>优化前 mysql 镜像执行结果：由上文可知，优化前实际效率值为 41%，由于默认效率阈值为 90%，所以执行失败。</p>\n<p><img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/806f10de-32cf-4c3a-a7c3-7ed4c9b8739e.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<p>优化后镜像执行结果：效率值为 97%，由于默认效率阈值为 90%，所以执行通过。</p>\n<p><img src=\"https://terminus-paas.oss-cn-hangzhou.aliyuncs.com/paas-doc/2021/08/24/055d42b7-33ee-4550-8e40-bb2bf5b31406.png?x-oss-process=image/resize,w_2304/format,webp\"></p>\n<p>同时项目也可以根据其对镜像大小的敏感度，将镜像大小最为一个检测条件，如只有镜像大小超过 1G 时，才进行镜像效率检测，这就可以避免大量小镜像的检测，加快 CI 流程。</p>\n<h3 id=\"如何自动化的检测-Dockerfile-并给出优化建议呢\"><a href=\"#如何自动化的检测-Dockerfile-并给出优化建议呢\" class=\"headerlink\" title=\"# 如何自动化的检测 Dockerfile 并给出优化建议呢\"></a><a href=\"#%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E6%A3%80%E6%B5%8B-dockerfile-%E5%B9%B6%E7%BB%99%E5%87%BA%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE%E5%91%A2\">#</a> 如何自动化的检测 Dockerfile 并给出优化建议呢</h3><p>结合上文，ADD&#x2F;COPY&#x2F;RUN 指令对应层会增加最终镜像大小，而一般镜像的构建过程包含：文件准备、文件操作等。文件准备阶段在 ADD&#x2F;COPY&#x2F;RUN 指令中都有可能出现；文件操作阶段主要由 RUN 指令实现，如果指令过于分散，文件操作阶段会根据 <strong>写时复制</strong> 原则，拷贝一份到当前镜像层，造成空间浪费，尤其是在涉及大文件操作时。更严重的情况是，假如对文件的操作分散在不同的 RUN 指令中，不就造成了多次文件拷贝浪费了。试想一下，如果拷贝和操作在同一层进行，不就可以避免这些文件跨层拷贝了吗。</p>\n<p>所以有以下一些通用的优化检测方法和建议：</p>\n<ul>\n<li>检测 RUN 指令是否过于分散，建议合并。</li>\n<li>检测 COPY&#x2F;ADD 指令是否有拷贝大文件，且在 RUN 指令中有对文件进行操作，则建议将 COPY&#x2F;ADD 指令转换合并到 RUN 指令中。当然此种检测方法，仅仅只有 Dockerfile 还是不够的，还需要有上下文，才能检测相关文件的大小。</li>\n</ul>\n","text":"Docker 镜像一定要瘦身成功！# 简介容器镜像类似于虚拟机镜像，封装了程序的运行环境，保证了运行环境的一致性，使得我们可以一次创建任意场景部署运行。镜像构建...","permalink":"/post/OCI/Docker 镜像一定要瘦身成功！","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"oss","slug":"oss","count":1,"path":"api/categories/oss.json"},{"name":"OCI","slug":"oss/OCI","count":1,"path":"api/categories/oss/OCI.json"}],"tags":[{"name":"paas","slug":"paas","count":1,"path":"api/tags/paas.json"},{"name":"RUN","slug":"RUN","count":1,"path":"api/tags/RUN.json"},{"name":"image","slug":"image","count":1,"path":"api/tags/image.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Docker-%E9%95%9C%E5%83%8F%E4%B8%80%E5%AE%9A%E8%A6%81%E7%98%A6%E8%BA%AB%E6%88%90%E5%8A%9F%EF%BC%81\"><span class=\"toc-text\">Docker 镜像一定要瘦身成功！</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\"> 简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%95%9C%E5%83%8F%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E7%98%A6%E8%BA%AB\"><span class=\"toc-text\"> 如何判断镜像是否需要瘦身</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB\"><span class=\"toc-text\"> 如何进行镜像瘦身</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA\"><span class=\"toc-text\"> 多阶段构建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82\"><span class=\"toc-text\"> 减少镜像分层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%83%8C%E6%99%AF\"><span class=\"toc-text\"> 背景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E5%A4%A7%E5%B0%8F%E5%88%86%E6%9E%90\"><span class=\"toc-text\"> 镜像大小分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6-RUN-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\"> 合并 RUN 指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#COPY-%E6%8C%87%E4%BB%A4%E8%BD%AC%E6%8D%A2%E5%90%88%E5%B9%B6%E5%88%B0-RUN-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\"> COPY 指令转换合并到 RUN 指令</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%8C%85\"><span class=\"toc-text\"> 减少容器中不必要的包</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\"> 镜像分析工具</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90\"><span class=\"toc-text\"> 镜像效率分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E5%89%8D\"><span class=\"toc-text\"> 优化前</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E5%90%8E\"><span class=\"toc-text\"> 优化后</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E9%95%9C%E5%83%8F%E6%81%A2%E5%A4%8D-Dockerfile\"><span class=\"toc-text\"> 番外篇：如何通过镜像恢复 Dockerfile</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2%E6%9F%A5%E7%9C%8B\"><span class=\"toc-text\"> 镜像构建历史查看</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%80%9F%E5%8A%A9-dive-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E8%BF%98%E5%8E%9F\"><span class=\"toc-text\"> 借助 dive 分析工具还原</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%80%83\"><span class=\"toc-text\"> 思考</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E5%8F%98%E8%83%96%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\"> 镜像变胖的原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB%E9%9A%BE%E5%90%97\"><span class=\"toc-text\"> 镜像瘦身难吗</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E7%98%A6%E8%BA%AB%E6%95%88%E6%9E%9C%EF%BC%88%E9%95%9C%E5%83%8F%E6%95%88%E7%8E%87%EF%BC%89\"><span class=\"toc-text\"> 如何评价瘦身效果（镜像效率）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CI-%E9%9B%86%E6%88%90\"><span class=\"toc-text\"> CI 集成</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E6%A3%80%E6%B5%8B-Dockerfile-%E5%B9%B6%E7%BB%99%E5%87%BA%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE%E5%91%A2\"><span class=\"toc-text\"> 如何自动化的检测 Dockerfile 并给出优化建议呢</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"docker容器内执行linux的dmidecode命令","uid":"c699c53537948b0233bf4a3c00fbe8ed","slug":"OCI/docker容器内执行linux的dmidecode命令","date":"2024-05-15T11:45:44.000Z","updated":"2025-12-05T01:47:56.923Z","comments":true,"path":"api/articles/OCI/docker容器内执行linux的dmidecode命令.json","keywords":"XuGuangSheng","cover":"/covers/dockerlinuxdmidecode.jpg","text":"docker容器内执行linux的dmidecode命令报错：[Errno 2] No such file or directory: ‘dmidecode’:...","permalink":"/post/OCI/docker容器内执行linux的dmidecode命令","photos":[],"count_time":{"symbolsCount":525,"symbolsTime":"1 mins."},"categories":[{"name":"dmidecode","slug":"dmidecode","count":1,"path":"api/categories/dmidecode.json"},{"name":"OCI","slug":"dmidecode/OCI","count":1,"path":"api/categories/dmidecode/OCI.json"}],"tags":[{"name":"docker","slug":"docker","count":4,"path":"api/tags/docker.json"},{"name":"mem","slug":"mem","count":1,"path":"api/tags/mem.json"},{"name":"sbin","slug":"sbin","count":1,"path":"api/tags/sbin.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"nginx平滑重启原理","uid":"382d6c325a8d429096616c76d2784a58","slug":"MIDDLEWARE/nginx平滑重启原理","date":"2024-04-26T15:57:42.000Z","updated":"2025-12-05T01:47:44.845Z","comments":true,"path":"api/articles/MIDDLEWARE/nginx平滑重启原理.json","keywords":"XuGuangSheng","cover":"/covers/nginx.jpg","text":"nginx平滑重启原理背景对于一个高并发的网络服务来说，平滑重启功能是必不可少的。试想，如果我们直接kill然后再start一个服务进程，则会导致： 12341...","permalink":"/post/MIDDLEWARE/nginx平滑重启原理","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"worker","slug":"worker","count":1,"path":"api/categories/worker.json"},{"name":"MIDDLEWARE","slug":"worker/MIDDLEWARE","count":1,"path":"api/categories/worker/MIDDLEWARE.json"}],"tags":[{"name":"master","slug":"master","count":3,"path":"api/tags/master.json"},{"name":"nginx","slug":"nginx","count":1,"path":"api/tags/nginx.json"},{"name":"fOxm","slug":"fOxm","count":1,"path":"api/tags/fOxm.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}