{"title":"Esper学习之四：Context","uid":"b92a10e317d46caa8257a30d6cf731e3","slug":"BIGDATA/Esper学习之四：Context","date":"2023-06-08T17:49:42.000Z","updated":"2025-12-05T01:46:07.032Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之四：Context.json","keywords":"XuGuangSheng","cover":"/covers/espercontext.jpg","content":"<h1 id=\"Esper学习之四：Context\"><a href=\"#Esper学习之四：Context\" class=\"headerlink\" title=\"Esper学习之四：Context\"></a>Esper学习之四：Context</h1><p> Context是Esper里一个很有意思的概念，要是理解为上下文，我觉得有点不妥。以我的理解，Context就像一个框，把不同的事件按照框的规则框起来，并且有可能有多个框，而框与框之间不会互相影响。不知道各位在看完这篇文章后是否认同我的观点，我愿洗耳恭听。</p>\n<p><strong>1.Context基本语法</strong></p>\n<p>语法结构如下</p>\n<ol>\n<li>create context context_name partition [by] event_property [and event_property [and …]] from stream_def   </li>\n<li>[, event_property […] from stream_def] [, …]</li>\n</ol>\n<p>  </p>\n<p>说明：<br>context_name为context的名字，并且唯一。如果重复，会说明已存在。</p>\n<p>event_property为事件的属性名，多个属性名之间用and连接，也可以用逗号连接。</p>\n<p>stream_def为事件流的定义，简单的定义可以是一个事件的名称，比如之前定义了一个Map结构的事件为User，那么这里就可以写User。复杂的流定义后面会说到</p>\n<p>举个例子：</p>\n<ol>\n<li>create context NewUser partition by id and name from User  </li>\n<li>&#x2F;&#x2F; id和name是User的属性</li>\n</ol>\n<p>  </p>\n<p>如果context包含多个流，例子如下：</p>\n<ol>\n<li>create context Person partition by sid from Student, tid from Teacher  </li>\n<li>&#x2F;&#x2F; sid是Student的属性，tid是Teacher的属性</li>\n</ol>\n<p>  </p>\n<p>多个流一定要注意，每个流的中用于context的属性的数量要一样，数据类型也要一致。比如下面这几个就是错误的：</p>\n<ol>\n<li><p>create context Person partition by sid from Student, tname from Teacher  </p>\n</li>\n<li><p>&#x2F;&#x2F; 错误：sid是int，tname是String，数据类型不一致  </p>\n</li>\n<li><p>create context Person partition by sid from Student, tid,tname from Teacher  </p>\n</li>\n<li><p>&#x2F;&#x2F; 错误：Student有一个属性，Teacher有两个属性，属性数量不一致  </p>\n</li>\n<li><p>create context Person partition by sid,sname from Student, tname,tid from Teacher  </p>\n</li>\n<li><p>&#x2F;&#x2F; 错误：sid对应tname，sname对应tid，并且sname和tname是String，sid和tid是int，属性数量一样，但是对应的数据类型不一致</p>\n</li>\n</ol>\n<p>  </p>\n<p>实际上可以对进入context的事件增加过滤条件，不符合条件的就被过滤掉，就像下面这样：</p>\n<ol>\n<li>create context Person partition by sid from Student(age &gt; 20)  </li>\n<li>&#x2F;&#x2F; age大于20的Student事件才能建立或者进入context</li>\n</ol>\n<p>  </p>\n<p>       看了这么多，可能大家只是知道context的一些基本定义方法，但是不知道什么意思。其实很简单，partition by后面的属性，就是作为context的一个约束，比如说id，如果id相等的则进入同一个context里，如果id不同，那就新建一个context。好比根据id分组，id相同的会被分到一个组里，不同的会新建一个组并等待相同的进入。</p>\n<p>       如果parition by后面跟着同一个流的两个属性，那么必须两个属性值一样才能进入context。比如说A事件id&#x3D;1,name&#x3D;a，那么会以1和a两个值建立context，有点像数据库里的联合主键。然后B事件id&#x3D;1,name&#x3D;b，则又会新建一个context。接着C事件id&#x3D;1,name&#x3D;a，那么会进入A事件建立的context。</p>\n<p>       如果partition by后面跟着两个流的一个属性，那么两个属性值一样才能进入context。比如说Student事件sid&#x3D;1，那么会新建一个context，然后来了个Teacher事件tid&#x3D;1，则会进入sid&#x3D;1的那个context。多个流也一样，不用关心是什么事件，只用关心事件的属性值一样即可进入同一个context。</p>\n<p>要是说了这么多还是不懂，可以看看下面要讲的context自带属性也许就能明白一些了。</p>\n<p><strong>2. Built-In Context Properties</strong></p>\n<p>Context本身自带一些属性，最关键的是可以查看所创建的context的标识，并帮助我们理解context的语法。</p>\n<p><img src=\"https://img-blog.csdn.net/20130902231634312\"></p>\n<p>如上所示，name表示context的名称，这个是不会变的。id是每个context的唯一标识，从0开始。key1和keyN表示context定义时所选择的属性的值，1和N表示属性的位置。例如：</p>\n<ol>\n<li>EPL: create context Person partition by sid, sname from Student  </li>\n<li>&#x2F;&#x2F; key1为sid，key2为sname</li>\n</ol>\n<p>  </p>\n<p>为了说明对这几个属性的应用，我举了一个比较完整的例子。</p>\n<ol>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import com.espertech.esper.client.UpdateListener;  </p>\n</li>\n<li><p>class ESB  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    private int id;  </p>\n</li>\n<li><p>    private int price;  </p>\n</li>\n<li><p>    public int getId()  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        return id;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setId(int id)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        this.id &#x3D; id;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public int getPrice()  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        return price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setPrice(int price)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        this.price &#x3D; price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class ContextPropertiesListener2 implements UpdateListener  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null)  </p>\n</li>\n<li><p>        {  </p>\n</li>\n<li><p>            EventBean event &#x3D; newEvents[0];  </p>\n</li>\n<li><p>            System.out.println(“context.name “ + event.get(“name”) + “, context.id “ + event.get(“id”) + “, context.key1 “ + event.get(“key1”)  </p>\n</li>\n<li><p>                    + “, context.key2 “ + event.get(“key2”));  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class ContextPropertiesTest2  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public static void main(String[] args)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        String esb &#x3D; ESB.class.getName();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “create context esbtest partition by id,price from “ + esb;  </p>\n</li>\n<li><p>        String epl2 &#x3D; “context esbtest select context.id,context.name,context.key1,context.key2 from “ + esb;  </p>\n</li>\n<li><p>        admin.createEPL(epl1);  </p>\n</li>\n<li><p>        EPStatement state &#x3D; admin.createEPL(epl2);  </p>\n</li>\n<li><p>        state.addListener(new ContextPropertiesListener2());  </p>\n</li>\n<li><p>        ESB e1 &#x3D; new ESB();  </p>\n</li>\n<li><p>        e1.setId(1);  </p>\n</li>\n<li><p>        e1.setPrice(20);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: id&#x3D;1, price&#x3D;20”);  </p>\n</li>\n<li><p>        runtime.sendEvent(e1);  </p>\n</li>\n<li><p>        ESB e2 &#x3D; new ESB();  </p>\n</li>\n<li><p>        e2.setId(2);  </p>\n</li>\n<li><p>        e2.setPrice(30);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: id&#x3D;2, price&#x3D;30”);  </p>\n</li>\n<li><p>        runtime.sendEvent(e2);  </p>\n</li>\n<li><p>        ESB e3 &#x3D; new ESB();  </p>\n</li>\n<li><p>        e3.setId(1);  </p>\n</li>\n<li><p>        e3.setPrice(20);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: id&#x3D;1, price&#x3D;20”);  </p>\n</li>\n<li><p>        runtime.sendEvent(e3);  </p>\n</li>\n<li><p>        ESB e4 &#x3D; new ESB();  </p>\n</li>\n<li><p>        e4.setId(4);  </p>\n</li>\n<li><p>        e4.setPrice(20);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: id&#x3D;4, price&#x3D;20”);  </p>\n</li>\n<li><p>        runtime.sendEvent(e4);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li>sendEvent: id&#x3D;1, price&#x3D;20  </li>\n<li>context.name esbtest, context.id 0, context.key1 1, context.key2 20  </li>\n<li>sendEvent: id&#x3D;2, price&#x3D;30  </li>\n<li>context.name esbtest, context.id 1, context.key1 2, context.key2 30  </li>\n<li>sendEvent: id&#x3D;1, price&#x3D;20  </li>\n<li>context.name esbtest, context.id 0, context.key1 1, context.key2 20  </li>\n<li>sendEvent: id&#x3D;4, price&#x3D;20  </li>\n<li>context.name esbtest, context.id 2, context.key1 4, context.key2 20</li>\n</ol>\n<p>  </p>\n<p>      这个例子说得比较明白，针对不同的id和price，都会新建一个context，并context.id会从0开始增加作为其标识。如果id和price一样，事件就会进入之前已经存在的context，所以e3这个事件就会和e1一样存在于context.id&#x3D;0的context里面。</p>\n<p>      对于epl2这个句子，意思是在esbtest这个context限制下进行事件的计算，不过这个句子很简单，可以说没有什么计算，事件进入后就显示出来了。实际上写成什么样都可以，但是必须以context xxx开头（xxx表示context定义时的名字），比如说：</p>\n<ol>\n<li><p>&#x2F;&#x2F; context定义  </p>\n</li>\n<li><p>create context esbtest2 partition by id from ESB  </p>\n</li>\n<li><p>&#x2F;&#x2F; 每当5个id相同的ESB事件进入时，统计price的总和  </p>\n</li>\n<li><p>context esbtest select sum(price) from ESB.win:length_batch(5)  </p>\n</li>\n<li><p>&#x2F;&#x2F; 根据不同的id，统计3秒内进入的事件的平均price，且price必须大于10  </p>\n</li>\n<li><p>context esbtest select avg(price) from ESB(price&gt;10).win:time(3 sec)</p>\n</li>\n</ol>\n<p>  </p>\n<p>       也许你会发现为什么我写的句子都会带有”.win:length”或者”.win:time”，那是因为我要计算的都是一堆事件，所以必须用一定条件才能把事件聚集起来。当然并不是一个事件没法计算，只不过更多情况下计算都是以多个事件为基础的。关于这一点，学习到后面就会有更多的接触。</p>\n<p><strong>3. Hash Context</strong></p>\n<p>       前面介绍的Context语法是以事件属性来定义的，Esper提供了以Hash值为标准定义Context，通俗一点说就是提供事件属性参与hash值的计算，计算的值再对某个值（这是什么）是同余的则进入到同一个context中。详细语法如下：</p>\n<ol>\n<li>create context context_name coalesce [by]  </li>\n<li>hash_func_name(hash_func_param) from stream_def  </li>\n<li>[, hash_func_name(hash_func_param) from stream_def ]  </li>\n<li>[, …]  </li>\n<li>granularity granularity_value  </li>\n<li>[preallocate]</li>\n</ol>\n<p>   </p>\n<p>a). hash_func_name为hash函数的名称，Esper提供了CRC32或者使用Java的hashcode函数来计算hash值，分别为consistent_hash_crc32和hash_code。你也可以自己定义hash函数，不过这需要配置。</p>\n<p>b). hash_func_param为参与计算的属性列表，比如之前的sid或者tname什么的。</p>\n<p>c). stream_def就是事件类型，可以一个可以多个。不同于前面的Context语法要求，Hash Context不管有多个少属性作为基础来计算hash值，hash值都只有一个，并且为int型。所以就不用关心这些属性的个数以及数据类型了。</p>\n<p>d). granularity是必选参数，表示为最多能创建多少个context</p>\n<p>e). granularity_value就是那个用于取余的“某个值”，因为Esper为了防止内存溢出，就想出了取余这种办法来限制context创建的数量。也就是说context.id&#x3D;hash_func_name(hash_func_param)  % granularity_value。</p>\n<p>f). preallocate是一个可选参数，如果使用它，那么Esper会预分配空间来创建granularity_value数量的context。比如说granularity_value为1024，那么Esper会预创建1024个context。内存不大的话不建议使用这个参数。</p>\n<p>Hash Context同样可以过滤事件，举个完整的例子：</p>\n<ol>\n<li>&#x2F;&#x2F; 以java的hashcode方法计算sid的值(sid必须大于5)，以CRC32算法计算tid的值，然后对10取余后的值来建立context  </li>\n<li>create context HashPerson coalesce by hash_code(sid) from Student(sid&gt;5), consistent_hash_crc32(tid) from Teacher granularity 10</li>\n</ol>\n<p>  </p>\n<p>Hash Context也有Built-In Context Properties，只不过只有context.id和context.name了。用法和前面说的一样，这里就不列举了。</p>\n<p>小贴士：</p>\n<p>1.如果用于hash计算的属性比较多，那么就不建议使用CRC32算法了，因为他会把这些属性值先序列化字节数组以后才能计算hash值。hashcode方法相对它能快很多。</p>\n<p>2.如果使用preallocate参数，建议granularity_value不要超过1000</p>\n<p>3.如果granularity_value超过65536，引擎查找context会比较费劲，进而影响计算速度</p>\n<p><strong>4. Category Context</strong></p>\n<p>Category Context相对之前的两类context要简单许多，也更容易理解。语法说明如下：</p>\n<ol>\n<li>create context context_name  </li>\n<li>group [by] group_expression as category_label  </li>\n<li>[, group [by] group_expression as category_label]  </li>\n<li>[, …]  </li>\n<li>from stream_def</li>\n</ol>\n<p>  </p>\n<p>       我相信基本上不用我说，大家都能理解。group_expression表示分组策略的表达式，category_label为策略定义一个名字，一个context可以有多个策略同时存在，但是特殊的是之能有一个stream_def。例如：</p>\n<ol>\n<li>create context CategoryByTemp  </li>\n<li>group temp &lt; 5 as cold, group temp between 5 and 85 as normal, group temp &gt; 85 as large  </li>\n<li>from Temperature</li>\n</ol>\n<p>  </p>\n<p>Category Context也有它自带的属性。</p>\n<p><img src=\"https://img-blog.csdn.net/20130903225426093\"></p>\n<p>label指明进入的事件所处的group是什么。完整例子如下：</p>\n<ol>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import com.espertech.esper.client.UpdateListener;  </p>\n</li>\n<li><p>class ESB3  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    private int id;  </p>\n</li>\n<li><p>    private int price;  </p>\n</li>\n<li><p>    public int getId()  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        return id;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setId(int id)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        this.id &#x3D; id;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public int getPrice()  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        return price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setPrice(int price)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        this.price &#x3D; price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class ContextPropertiesListener4 implements UpdateListener  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null)  </p>\n</li>\n<li><p>        {  </p>\n</li>\n<li><p>            EventBean event &#x3D; newEvents[0];  </p>\n</li>\n<li><p>            System.out.println(“context.name “ + event.get(“name”) + “, context.id “ + event.get(“id”) + “, context.label “ + event.get(“label”));  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class ContextPropertiesTest4  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public static void main(String[] args)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        String esb &#x3D; ESB3.class.getName();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “create context esbtest group by id&lt;0 as low, group by id&gt;0 and id&lt;10 as middle,group by id&gt;10 as high from “ + esb;  </p>\n</li>\n<li><p>        String epl2 &#x3D; “context esbtest select context.id,context.name,context.label, price from “ + esb;  </p>\n</li>\n<li><p>        admin.createEPL(epl1);  </p>\n</li>\n<li><p>        EPStatement state &#x3D; admin.createEPL(epl2);  </p>\n</li>\n<li><p>        state.addListener(new ContextPropertiesListener4());  </p>\n</li>\n<li><p>        ESB3 e1 &#x3D; new ESB3();  </p>\n</li>\n<li><p>        e1.setId(1);  </p>\n</li>\n<li><p>        e1.setPrice(20);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: id&#x3D;1, price&#x3D;20”);  </p>\n</li>\n<li><p>        runtime.sendEvent(e1);  </p>\n</li>\n<li><p>        ESB3 e2 &#x3D; new ESB3();  </p>\n</li>\n<li><p>        e2.setId(0);  </p>\n</li>\n<li><p>        e2.setPrice(30);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: id&#x3D;0, price&#x3D;30”);  </p>\n</li>\n<li><p>        runtime.sendEvent(e2);  </p>\n</li>\n<li><p>        ESB3 e3 &#x3D; new ESB3();  </p>\n</li>\n<li><p>        e3.setId(11);  </p>\n</li>\n<li><p>        e3.setPrice(20);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: id&#x3D;11, price&#x3D;20”);  </p>\n</li>\n<li><p>        runtime.sendEvent(e3);  </p>\n</li>\n<li><p>        ESB3 e4 &#x3D; new ESB3();  </p>\n</li>\n<li><p>        e4.setId(-1);  </p>\n</li>\n<li><p>        e4.setPrice(40);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: id&#x3D;-1, price&#x3D;40”);  </p>\n</li>\n<li><p>        runtime.sendEvent(e4);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>输出结果为：</p>\n<ol>\n<li>sendEvent: id&#x3D;1, price&#x3D;20  </li>\n<li>context.name esbtest, context.id 1, context.label middle  </li>\n<li>sendEvent: id&#x3D;0, price&#x3D;30  </li>\n<li>sendEvent: id&#x3D;11, price&#x3D;20  </li>\n<li>context.name esbtest, context.id 2, context.label high  </li>\n<li>sendEvent: id&#x3D;-1, price&#x3D;40  </li>\n<li>context.name esbtest, context.id 0, context.label low</li>\n</ol>\n<p>  </p>\n<p>可以发现，id&#x3D;0的事件，并没有触发监听器，那是因为context里的三个category没有包含id&#x3D;0的情况，所以这个事件就被排除掉了。</p>\n<p><strong>5. Non-Overlapping Context</strong></p>\n<p>这类Context有个特点，是由开始和结束两个条件构成context。语法如下：</p>\n<ol>\n<li>create context context_name start start_condition end end_condition</li>\n</ol>\n<p>  </p>\n<p>       这个context有两个条件做限制，形成一个约束范围。当开始条件和结束条件都没被触发时，引擎会观察事件的进入是否会触发开始条件。如果开始条件被触发了，那么就新建一个context，并且观察结束条件是否被触发。如果结束条件被触发，那么context结束，引擎继续观察开始条件何时被触发。所以说这类Context的另一个特点是，要么context存在并且只有一个，要么条件都没被触发，也就一个context都没有了。</p>\n<p>start_condition和end_condition可以是时间，或者是事件类型。比如说：</p>\n<ol>\n<li>create context NineToFive start (0, 9, *, *, *) end (0, 17, *, *, *)  </li>\n<li>&#x2F;&#x2F;  9点到17点此context才可用（以引擎的时间为准）。如果事件进入的事件不在此范围内，则不受该context影响</li>\n</ol>\n<p>  </p>\n<p>我列了一个完整的例子，以某类事件开始，以某类事件结束</p>\n<ol>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import com.espertech.esper.client.UpdateListener;  </p>\n</li>\n<li><p>class StartEvent  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class EndEvent  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class OtherEvent  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    private int id;  </p>\n</li>\n<li><p>    public int getId()  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        return id;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setId(int id)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        this.id &#x3D; id;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class NoOverLappingContextTest3 implements UpdateListener  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null)  </p>\n</li>\n<li><p>        {  </p>\n</li>\n<li><p>            EventBean event &#x3D; newEvents[0];  </p>\n</li>\n<li><p>            System.out.println(“Class:” + event.getUnderlying().getClass().getName() + “, id:” + event.get(“id”));  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class NoOverLappingContextTest  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public static void main(String[] args)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        String start &#x3D; StartEvent.class.getName();  </p>\n</li>\n<li><p>        String end &#x3D; EndEvent.class.getName();  </p>\n</li>\n<li><p>        String other &#x3D; OtherEvent.class.getName();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “create context NoOverLapping start “ + start + “ end “ + end;  </p>\n</li>\n<li><p>        String epl2 &#x3D; “context NoOverLapping select * from “ + other;  </p>\n</li>\n<li><p>        admin.createEPL(epl1);  </p>\n</li>\n<li><p>        EPStatement state &#x3D; admin.createEPL(epl2);  </p>\n</li>\n<li><p>        state.addListener(new NoOverLappingContextTest3());  </p>\n</li>\n<li><p>        StartEvent s &#x3D; new StartEvent();  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: StartEvent”);  </p>\n</li>\n<li><p>        runtime.sendEvent(s);  </p>\n</li>\n<li><p>        OtherEvent o &#x3D; new OtherEvent();  </p>\n</li>\n<li><p>        o.setId(2);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: OtherEvent”);  </p>\n</li>\n<li><p>        runtime.sendEvent(o);  </p>\n</li>\n<li><p>        EndEvent e &#x3D; new EndEvent();  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: EndEvent”);  </p>\n</li>\n<li><p>        runtime.sendEvent(e);  </p>\n</li>\n<li><p>        OtherEvent o2 &#x3D; new OtherEvent();  </p>\n</li>\n<li><p>        o2.setId(4);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: OtherEvent”);  </p>\n</li>\n<li><p>        runtime.sendEvent(o2);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li>sendEvent: StartEvent  </li>\n<li>sendEvent: OtherEvent  </li>\n<li>Class:blog.OtherEvent, id:2  </li>\n<li>sendEvent: EndEvent  </li>\n<li>sendEvent: OtherEvent</li>\n</ol>\n<p>  </p>\n<p>由此可以看出，在NoOverLapping这个Context下监控OtherEvent，必须是在StartEvent被触发才能监控到，所以在EndEvent发送后，再发送一个OtherEvent是不会触发Listener的。</p>\n<p><strong>6. OverLapping</strong></p>\n<p>OverLapping和NoOverLapping一样都有两个条件限制，但是区别在于OverLapping的初始条件可以被触发多次，并且只要被触发就会新建一个context，但是当终结条件被触发时，之前建立的所有context都会被销毁。他的语法也很简单：</p>\n<ol>\n<li>create context context_name initiated [by] initiating_condition terminated [by] terminating_condition</li>\n</ol>\n<p>  </p>\n<p>initiating_condition和terminating_condition可以为事件类型，事件或者别的条件表达式。下面给出了一个完整的例子。</p>\n<ol>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import com.espertech.esper.client.UpdateListener;  </p>\n</li>\n<li><p>class InitialEvent{}  </p>\n</li>\n<li><p>class TerminateEvent{}  </p>\n</li>\n<li><p>class SomeEvent  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    private int id;  </p>\n</li>\n<li><p>    public int getId()  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        return id;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setId(int id)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        this.id &#x3D; id;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class OverLappingContextListener implements UpdateListener  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null)  </p>\n</li>\n<li><p>        {  </p>\n</li>\n<li><p>            EventBean event &#x3D; newEvents[0];  </p>\n</li>\n<li><p>            System.out.println(“context.id:” + event.get(“id”) + “, id:” + event.get(“id”));  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class OverLappingContextListener2 implements UpdateListener  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null)  </p>\n</li>\n<li><p>        {  </p>\n</li>\n<li><p>            EventBean event &#x3D; newEvents[0];  </p>\n</li>\n<li><p>            System.out.println(“Class:” + event.getUnderlying().getClass().getName() + “, id:” + event.get(“id”));  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class OverLappingContextTest  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public static void main(String[] args)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        String initial &#x3D; InitialEvent.class.getName();  </p>\n</li>\n<li><p>        String terminate &#x3D; TerminateEvent.class.getName();  </p>\n</li>\n<li><p>        String some &#x3D; SomeEvent.class.getName();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “create context OverLapping initiated “ + initial + “ terminated “ + terminate;  </p>\n</li>\n<li><p>        String epl2 &#x3D; “context OverLapping select context.id from “ + initial;  </p>\n</li>\n<li><p>        String epl3 &#x3D; “context OverLapping select * from “ + some;  </p>\n</li>\n<li><p>        admin.createEPL(epl1);  </p>\n</li>\n<li><p>        EPStatement state &#x3D; admin.createEPL(epl2);  </p>\n</li>\n<li><p>        state.addListener(new OverLappingContextListener());  </p>\n</li>\n<li><p>        EPStatement state1 &#x3D; admin.createEPL(epl3);  </p>\n</li>\n<li><p>        state1.addListener(new OverLappingContextListener2());  </p>\n</li>\n<li><p>        InitialEvent i &#x3D; new InitialEvent();  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: InitialEvent”);  </p>\n</li>\n<li><p>        runtime.sendEvent(i);  </p>\n</li>\n<li><p>        SomeEvent s &#x3D; new SomeEvent();  </p>\n</li>\n<li><p>        s.setId(2);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: SomeEvent”);  </p>\n</li>\n<li><p>        runtime.sendEvent(s);  </p>\n</li>\n<li><p>        InitialEvent i2 &#x3D; new InitialEvent();  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: InitialEvent”);  </p>\n</li>\n<li><p>        runtime.sendEvent(i2);  </p>\n</li>\n<li><p>        TerminateEvent t &#x3D; new TerminateEvent();  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: TerminateEvent”);  </p>\n</li>\n<li><p>        runtime.sendEvent(t);  </p>\n</li>\n<li><p>        SomeEvent s2 &#x3D; new SomeEvent();  </p>\n</li>\n<li><p>        s2.setId(4);  </p>\n</li>\n<li><p>        System.out.println(“sendEvent: SomeEvent”);  </p>\n</li>\n<li><p>        runtime.sendEvent(s2);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li>sendEvent: InitialEvent  </li>\n<li>context.id:0, id:0  </li>\n<li>sendEvent: SomeEvent  </li>\n<li>Class:blog.SomeEvent, id:2  </li>\n<li>sendEvent: InitialEvent  </li>\n<li>context.id:1, id:1  </li>\n<li>context.id:0, id:0  </li>\n<li>sendEvent: TerminateEvent  </li>\n<li>sendEvent: SomeEvent</li>\n</ol>\n<p>  </p>\n<p>从结果可以看得出来，每发送一个InitialEvent，都会新建一个context，以至于context.id&#x3D;0和1。并且当发送TerminateEvent后，再发送SomeEvent监听器也不会被触发了。</p>\n<p>另外，context.id是每一种Context都会有的自带属性，而且针对OverLapping，还增加了startTime和endTime两种属性，表明context的开始时间和结束时间。</p>\n<p><strong>7. Context Condition</strong></p>\n<p>Context Condition主要包含Filter，Pattern，Crontab以及Time Period</p>\n<p>**A).**Filter主要就是对属性值的过滤，比如：</p>\n<ol>\n<li>create context NewUser partition by id from User(id &gt; 10)</li>\n</ol>\n<p>  </p>\n<p>**B).**Pattern是复杂事件流的代表，比如说“A事件到达后跟着B事件到达”这是一个完整的Pattern。Pattern是Esper里面很特别的东西，并且用它描述复杂的事件流是最合适不过的了。这里暂且不展开说，后面会有专门好几篇来讲解Pattern。</p>\n<p>**C).**Crontab是定时任务，主要用于NoOverLapping，就像前面提到的(0, 9, *, *, *)，括号里的五项代表分，时，天，月，年。关于这个后面也会有讲解。</p>\n<p>**D).**Time Period在这里只有一种表达式，就是after time_period_expression。例如：after 1 minute，after 5 sec。结合Context的例子如下：</p>\n<ol>\n<li>&#x2F;&#x2F; 以0秒为时间初始点，新建一个context，于10秒后开始，1分钟后结束。下一个context从1分20秒开始  </li>\n<li>create context NonOverlap10SecFor1Min start after 10 seconds end after 1 minute</li>\n</ol>\n<p>  </p>\n<p><strong>8. Context Nesting</strong></p>\n<p>Context也可以嵌套，意义就是多个Context联合在一起组成一个大的Context，以满足复杂的限制需求。语法结构：</p>\n<ol>\n<li>create context context_name  </li>\n<li>context nested_context_name [as] nested_context_definition ,  </li>\n<li>context nested_context_name [as] nested_context_definition [, …]</li>\n</ol>\n<p>  </p>\n<p>举个例子：</p>\n<ol>\n<li>create context NineToFiveSegmented  </li>\n<li>context NineToFive start (0, 9, *, *, *) end (0, 17, *, *, *),  </li>\n<li>context SegmentedByUser partition by userId from User</li>\n</ol>\n<p>  </p>\n<p>应用和普通的Context没区别，在此就不举例了。另外针对嵌套Context，其自带的属性使用方式会有些变化。比如针对上面这个，若想查看NineToFive的startTime和SegmentedByUser的第一个属性值，要按照下面这样写：</p>\n<ol>\n<li>context NineToFiveSegmented select  </li>\n<li> context.NineToFive.startTime,  </li>\n<li> context.SegmentedByUser.key1  </li>\n<li> from User</li>\n</ol>\n<p>  </p>\n<p><strong>9. Output When Context Partition Ends</strong></p>\n<p>当Context销毁时，如果你想同时查看此时Context里的东西，那么Esper提供了一种办法来输出其内容。例如：</p>\n<ol>\n<li>create context OverLapping initiated InitialEvent terminated TerminateEvent  </li>\n<li>context OverLapping select * from User output snapshot when terminated</li>\n</ol>\n<p>  </p>\n<p>那么当终结事件发送到引擎后，会立刻输出OverLapping的快照。</p>\n<p>如果你想以固定的频率查看Context的内容，Esper也支持。例如：</p>\n<ol>\n<li>context OverLapping select * from User output snapshot every 2 minute &#x2F;&#x2F; 每两分钟输出OverLapping的事件</li>\n</ol>\n<p>  </p>\n<p>关于output表达式，后面也会有详解。</p>\n<p>       以上的内容算是包含了Context的所有方面，可能还有些细节需要各位自己去研读他的手册，并且多加练习。Esper的内容之多以至于我说了很多次“后面会专门讲解”，不过也确实是因为内容复杂，所以不得不先跳过这些。在学习到之后的内容以后，再回过头来理解Context可能会有另一番效果。</p>\n","text":"Esper学习之四：Context Context是Esper里一个很有意思的概念，要是理解为上下文，我觉得有点不妥。以我的理解，Context就像一个框，把不...","permalink":"/post/BIGDATA/Esper学习之四：Context","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"context","slug":"context","count":1,"path":"api/categories/context.json"},{"name":"BIGDATA","slug":"context/BIGDATA","count":1,"path":"api/categories/context/BIGDATA.json"}],"tags":[{"name":"sendEvent","slug":"sendEvent","count":1,"path":"api/tags/sendEvent.json"},{"name":"Context","slug":"Context","count":1,"path":"api/tags/Context.json"},{"name":"price","slug":"price","count":1,"path":"api/tags/price.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Esper%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%EF%BC%9AContext\"><span class=\"toc-text\">Esper学习之四：Context</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Esper学习之五：EPL语法（一）","uid":"c5c99cbcae7cadf842c021db56097c6a","slug":"BIGDATA/Esper学习之五：EPL语法（一）","date":"2023-06-08T17:50:09.000Z","updated":"2025-12-05T01:46:05.954Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之五：EPL语法（一）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之五：EPL语法（一）上篇说到了Esper的Context，要是不了解的同学请参看《Esper学习之四：Context》，看过的同学如果还是不理解...","permalink":"/post/BIGDATA/Esper学习之五：EPL语法（一）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"EPL","slug":"EPL","count":2,"path":"api/categories/EPL.json"},{"name":"BIGDATA","slug":"EPL/BIGDATA","count":2,"path":"api/categories/EPL/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"expression","slug":"expression","count":1,"path":"api/tags/expression.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Esper学习之三：进程模型","uid":"9e7669ec94144638fab3876a099d0e10","slug":"BIGDATA/Esper学习之三：进程模型","date":"2023-06-08T17:49:22.000Z","updated":"2025-12-05T01:46:05.779Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之三：进程模型.json","keywords":"XuGuangSheng","cover":"/covers/esper.jpg","text":"Esper学习之三：进程模型 之前对Esper所能处理的事件结构进行了概述，并结合了例子进行讲解，不清楚的同学请看Esper学习之二：事件类型。今天主要为大家解...","permalink":"/post/BIGDATA/Esper学习之三：进程模型","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"EPL","slug":"EPL","count":2,"path":"api/categories/EPL.json"},{"name":"BIGDATA","slug":"EPL/BIGDATA","count":2,"path":"api/categories/EPL/BIGDATA.json"}],"tags":[{"name":"Esper","slug":"Esper","count":2,"path":"api/tags/Esper.json"},{"name":"length","slug":"length","count":1,"path":"api/tags/length.json"},{"name":"newEvents","slug":"newEvents","count":1,"path":"api/tags/newEvents.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}