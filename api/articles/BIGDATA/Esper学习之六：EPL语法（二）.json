{"title":"Esper学习之六：EPL语法（二）","uid":"6e82ad6dc435102e8221e6c49dde0575","slug":"BIGDATA/Esper学习之六：EPL语法（二）","date":"2023-06-08T17:50:28.000Z","updated":"2025-09-30T03:26:03.929Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之六：EPL语法（二）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","content":"<h1 id=\"Esper学习之六：EPL语法（二）\"><a href=\"#Esper学习之六：EPL语法（二）\" class=\"headerlink\" title=\"Esper学习之六：EPL语法（二）\"></a>Esper学习之六：EPL语法（二）</h1><p> 从上一篇开始说EPL的语法，主要是关于注解的。今天来说说比较常用的语法，Select Clause和From Clause。这个两个可以说是写EPL必备，要想得到事件流的处理结果，基本上就靠他们俩了（Pattern除外）。今天的内容比较简单，还请各位同学牢记，以免以后应用的时候花时间看文档或者我的文章。</p>\n<p><strong>Select Clause</strong></p>\n<p><strong>1.查询事件流的所有属性及特定属性</strong></p>\n<p>EPL的select和SQL的select很相近，SQL用<em>表示查询表的所有字段，而EPL用</em>表示查询事件流的所有属性值。SQL查询某个字段名，直接在select后跟字段名就ok，EPL也是将要查询的属性名放在select之后。若查多个属性值，则用逗号分割。和SQL一样，EPL查询属性也可以设置别名。示例如下：</p>\n<ol>\n<li><p>&#x2F;&#x2F; EPL：查询完整的User对象  </p>\n</li>\n<li><p>select * from User  </p>\n</li>\n<li><p>&#x2F;&#x2F; 获取User对象  </p>\n</li>\n<li><p>User u &#x3D; newEvent.getUnderlying();  </p>\n</li>\n<li><p>&#x2F;&#x2F; EPL：查询User的name和id，id别名为i  </p>\n</li>\n<li><p>select name, id as i from User  </p>\n</li>\n<li><p>&#x2F;&#x2F; 获取name和id  </p>\n</li>\n<li><p>String name &#x3D; (String)newEvent.get(“name”);  </p>\n</li>\n<li><p>int id &#x3D; (Integer)newEvent.get(“i”);</p>\n</li>\n</ol>\n<p>  </p>\n<p>这里要注意，如果查询的是一个完整对象，需要调用getUnderlying()方法，而get方法是针对确定的属性名或者别名。另外*是不能设置别名的。</p>\n<p><strong>2.表达式</strong></p>\n<p>除了查询完整对象和特定属性，EPL还支持属性值的计算，以计算后的值作为结果返回，并且也能设置别名。这个计算的式子就是表达式。例如：</p>\n<ol>\n<li>&#x2F;&#x2F; 计算长方形的面积（长乘以宽）  </li>\n<li>select length * width as area from Rectangle</li>\n</ol>\n<p>  </p>\n<p>除了简单的加减乘除，还可以利用事件流对象的某个方法。例如：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 计算长方形的面积（长乘以宽）  </p>\n</li>\n<li><p>select r.getArea(r.length,r.width) as area from Rectangle as r  </p>\n</li>\n<li><p>select r.getArea() as area from Rectangle as r  </p>\n</li>\n<li><p>public class Rectangle  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    private int length;  </p>\n</li>\n<li><p>    private int width;  </p>\n</li>\n<li><p>    public int getArea(int l, int w){  </p>\n</li>\n<li><p>        return l*w;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public int getArea(){  </p>\n</li>\n<li><p>        return length * width;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>如上所示，一个方法需要传参，另一个方法不需要，但是他会利用当前事件的length和width来计算面积。而且要注意的是事件流需要设置别名才能使用其方法，如：r.getArea()</p>\n<p>如果Rectangle类里没有计算面积的方法，但是提供了一个专门计算面积的静态方法，表达式也可以直接引用。不过要事先加载这个包含方法的类。例如：</p>\n<ol start=\"2\">\n<li><p>public class ComputeArea{  </p>\n</li>\n<li><p>    public static int getArea(int length, int width){  </p>\n</li>\n<li><p>        return length*width;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>epService.getEPAdministrator().getConfiguration().addImport(ComputeArea.class);  </p>\n</li>\n<li><p>&#x2F;&#x2F; 调用ComputeArea的getArea方法计算面积  </p>\n</li>\n<li><p>select ComputeArea.getArea(length,width) from Rectangle</p>\n</li>\n</ol>\n<p>  </p>\n<p>注意一定要是静态方法，不然没有实例化是没法引用的。</p>\n<p><strong>3.多事件流的查询</strong></p>\n<p>和SQL类似，EPL也可以同时对多个事件流进行查询，即join，但是必须对每个事件流设置别名。例如：</p>\n<ol>\n<li>&#x2F;&#x2F; 当老师的id和学生的id相同时，查询学生的姓名和老师的姓名  </li>\n<li>select s.name, t.name from Student.win:time(10) as s, Teacher.win:time(10) as t where s.id&#x3D;t.id</li>\n</ol>\n<p>  </p>\n<p>如果想查询Student或者Teacher，则EPL改写如下：</p>\n<ol>\n<li>select s.* as st, t.* as tr from Student.win:time(10) as s, Teacher.win:time(10) as t where s.id&#x3D;t.id</li>\n</ol>\n<p>  </p>\n<p>如果想要查询的属性只有存在于一个事件，那么可以不用”别名.属性名”，但是最好还是带上别名，万一哪天另一个事件流多了一个一样的属性，那时候不需要修改EPL也可以使用。关于join，可看看这篇文章《<a href=\"http://blog.csdn.net/luonanqin/article/details/18002059\">Esper学习之九：EPL语法（五）</a>》的join部分</p>\n<p><strong>4.insert和remove事件流</strong></p>\n<p>Esper对于事件流分输入和移出两种，分别对应监听器的两个参数newEvents和oldEvents，关于监听器的内容可参看《<a href=\"http://blog.csdn.net/luonanqin/article/details/10714687\">Esper学习之三：进程模型</a>》。newEvents通常对应事件的计算结果，oldEvents可以理解过上一次计算结果。默认情况下，只有newEvents有值，oldEvents为null。如果需要查看oldEvents，则需要使用一个参数。例如：</p>\n<ol>\n<li>select rstream * from User</li>\n</ol>\n<p>  </p>\n<p>如果使用了该参数，则会将上一次计算结果放入newEvents内，而不是oldEvents（以前我还以为这是一个bug，后面发现手册上官方明确就是newEvents，汗！）。并且无法获得当前的计算结果</p>\n<ol>\n<li>select irstream * from User</li>\n</ol>\n<p>  </p>\n<p>如果使用了该参数，则会将当前的计算结果放入newEvents内，上一次的计算结果放入oldEvents内。</p>\n<ol>\n<li>select istream * from User  </li>\n<li>&#x2F;&#x2F; 等同于  </li>\n<li>select * from User</li>\n</ol>\n<p>  </p>\n<p>如果使用了该参数，则会将当前的计算结果放入newEvents内，并且无法获得上一次的计算结果。同时该参数也是默认参数，可不写。</p>\n<p>如果想修改默认参数，需要调用配置接口修改配置。</p>\n<p><strong>5.Distinct</strong></p>\n<p>distinct的用法和SQL一样，放在需要修饰的属性或者*前即可。例如：</p>\n<ol>\n<li>select distinct * from User.win:time(3 sec)</li>\n</ol>\n<p>  </p>\n<p><strong>6.查询指定引擎的处理结果</strong></p>\n<p>除了上述所说的一些特点外，select还可以针对某个引擎进行查询。因为引擎都有自己的URI，所以可以在select句子中增加URI标识来指定查询哪一个引擎的事件处理情况。例如：</p>\n<ol>\n<li>&#x2F;&#x2F; 引擎URI为Processor  </li>\n<li>select Processor.MyEvent.myProperty from Processor.MyEvent</li>\n</ol>\n<p>  </p>\n<p><strong>From Clause</strong></p>\n<p><strong>1.语法介绍</strong></p>\n<p>From的语法不难，主要内容是针对事件流的处理。包括事件流过滤，事件流的维持等等。语法如下：</p>\n<ol>\n<li><p>from stream_def [as name] [unidirectional] [retain-union | retain-intersection] [, stream_def [as stream_name]] [, …]  </p>\n</li>\n<li><p>&#x2F;&#x2F; 事件流  </p>\n</li>\n<li><p>event_stream_name [(filter_criteria)] [contained_selection] [.view_spec] [.view_spec] […]</p>\n</li>\n</ol>\n<p>  </p>\n<p>unidirectional，retain-union，retain-intersection，contained_selection，view_spec这几个关键字因为涉及到view的知识，所以这里没法讲解。待学完view之后再来回顾这几个参数会很容易理解的。下面讲讲怎么过滤事件流</p>\n<p><strong>2.事件流过滤</strong></p>\n<p><em>2.1.事件属性过滤</em></p>\n<p>事件流过滤通常情况都是对其中某个或多个属性加以限制来达到过滤的目的。注意，过滤表达式是紧跟在事件流名称之后而不是别名之后。例如：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 只有age大于10的User对象才可查询到name值  </p>\n</li>\n<li><p>select name from User(age&gt;10) as user  </p>\n</li>\n<li><p>&#x2F;&#x2F; 当name&#x3D;“luonanqin”时，可获得其age值  </p>\n</li>\n<li><p>select age from User(name&#x3D;”luonanqin”)  </p>\n</li>\n<li><p>&#x2F;&#x2F; 错误写法  </p>\n</li>\n<li><p>select name from User as user(age&gt;10)</p>\n</li>\n</ol>\n<p>  </p>\n<p>过滤表达式写法多种多样，可以用符号，又或者使用and,or,between等逻辑语言。例如：</p>\n<ol>\n<li>&#x2F;&#x2F; 查询年龄大于15小于18的学生的姓名  </li>\n<li>select name from Student(age between 15 and 18)  </li>\n<li>&#x2F;&#x2F; 等同于  </li>\n<li>select name from Student(age &gt;&#x3D; 15 and age &lt;&#x3D; 18)  </li>\n<li>&#x2F;&#x2F; 等同于  </li>\n<li>select name from Student(age &gt;&#x3D; 15, age &lt;&#x3D; 18)</li>\n</ol>\n<p>  </p>\n<p>看以看到，过滤表达式写法很多，并且多个表达式同时作用于一个事件流，用逗号连接即可。如果说满足其中一个条件即可，则需要用or连接。</p>\n<p><em>2.2.过滤范围</em></p>\n<p>刚才说到过滤表达式使用的符号很多，总结下来基本上有&lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;, &#x3D;, !&#x3D;, between, in, not in, and, or, [ ], ( )。这里主要说下between，in，( )，[ ]</p>\n<p>between……and……</p>\n<p>和SQL的between……and……意思一样，是一个闭区间。比如说between 10 and 15，中文语义为10到15之间并包含10和15.</p>\n<p>( )</p>\n<p>表示一个开区间，语法为(low：high)。如(10:15)，表示10到15之间，并且不包含10和15</p>\n<p>[ ]</p>\n<p>表示一个闭区间，语法为[low：high]。如[10:15]，表示10到15之间，并且包含10和15</p>\n<p>( )和[ ]可以混合用。比如[10:15)或者(10:15]</p>\n<p>in</p>\n<p>配合( )和[ ]进行使用，表示值在某个范围内。比如：</p>\n<ol>\n<li>select name from User(age in [10:15))</li>\n</ol>\n<p>  </p>\n<p>相应的，not in表示不在此范围内。</p>\n<p>以上都是针对数字的例子，in和not in同样可以作用于字符串。比如：</p>\n<ol>\n<li>select age from User(name in (‘张三’, ‘李四’))</li>\n</ol>\n<p>  </p>\n<p><em>2.3 静态方法过滤</em></p>\n<p>除了上面说的这些符号以外，类似于select子句中使用的静态方法，过滤表达式中也可以使用，但是返回值必须为布尔值，不然会报错。例如：</p>\n<ol start=\"2\">\n<li><p>public class IsZero  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public static boolean isZero(int sum)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        return sum&#x3D;&#x3D;0;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>epService.getEPAdministrator().getConfiguration().addImport(IsZero.class);  </p>\n</li>\n<li><p>select name from User(IsZero.isZero(money))</p>\n</li>\n</ol>\n<p>  </p>\n<p>事件流的过滤并不能弄得很复杂，他有一下几个限制：</p>\n<p>1. 要过滤的属性只能是数字和字符串。<br>2. 过滤表达式中不能使用聚合函数。<br>3. “prev”和“prior”函数不能用于过滤表达式（暂且不考虑这是什么）</p>\n<p>       Select和From的基础内容基本上就是上面所说的。当学过后面的章节之后，select和from可以写得很复杂，才能支持更为复杂的业务需求。特别是学过view和一些event function之后，变化就更加多样了。下一篇将讲解别的Clause，敬请期待。</p>\n","text":"Esper学习之六：EPL语法（二） 从上一篇开始说EPL的语法，主要是关于注解的。今天来说说比较常用的语法，Select Clause和From Clause...","permalink":"/post/BIGDATA/Esper学习之六：EPL语法（二）","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"select","slug":"select","count":1,"path":"api/categories/select.json"},{"name":"BIGDATA","slug":"select/BIGDATA","count":1,"path":"api/categories/select/BIGDATA.json"}],"tags":[{"name":"from","slug":"from","count":2,"path":"api/tags/from.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"},{"name":"User","slug":"User","count":1,"path":"api/tags/User.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Esper%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%AD%EF%BC%9AEPL%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89\"><span class=\"toc-text\">Esper学习之六：EPL语法（二）</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Esper学习之七：EPL语法（三）","uid":"7e07be7bd570848d0be5a40e5365e5e4","slug":"BIGDATA/Esper学习之七：EPL语法（三）","date":"2023-06-08T17:52:30.000Z","updated":"2025-09-30T03:26:03.424Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之七：EPL语法（三）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之七：EPL语法（三）1.Aggregation 和SQL一样，EPL也有Aggregation，即聚合函数。语法如下： aggregate_fu...","permalink":"/post/BIGDATA/Esper学习之七：EPL语法（三）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"price","slug":"price","count":2,"path":"api/categories/price.json"},{"name":"BIGDATA","slug":"price/BIGDATA","count":2,"path":"api/categories/price/BIGDATA.json"}],"tags":[{"name":"Apple","slug":"Apple","count":2,"path":"api/tags/Apple.json"},{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"color","slug":"color","count":1,"path":"api/tags/color.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Esper学习之五：EPL语法（一）","uid":"c5c99cbcae7cadf842c021db56097c6a","slug":"BIGDATA/Esper学习之五：EPL语法（一）","date":"2023-06-08T17:50:09.000Z","updated":"2025-09-30T03:26:03.869Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之五：EPL语法（一）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之五：EPL语法（一）上篇说到了Esper的Context，要是不了解的同学请参看《Esper学习之四：Context》，看过的同学如果还是不理解...","permalink":"/post/BIGDATA/Esper学习之五：EPL语法（一）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"EPL","slug":"EPL","count":2,"path":"api/categories/EPL.json"},{"name":"BIGDATA","slug":"EPL/BIGDATA","count":2,"path":"api/categories/EPL/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"expression","slug":"expression","count":1,"path":"api/tags/expression.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}