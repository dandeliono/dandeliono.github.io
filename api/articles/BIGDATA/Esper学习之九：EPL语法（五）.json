{"title":"Esper学习之九：EPL语法（五）","uid":"c610892d4b9e5d360c3a54bc62d56b3a","slug":"BIGDATA/Esper学习之九：EPL语法（五）","date":"2023-06-09T09:25:57.000Z","updated":"2025-12-05T01:46:05.834Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之九：EPL语法（五）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","content":"<h1 id=\"Esper学习之九：EPL语法（五）\"><a href=\"#Esper学习之九：EPL语法（五）\" class=\"headerlink\" title=\"Esper学习之九：EPL语法（五）\"></a>Esper学习之九：EPL语法（五）</h1><p>本篇的内容主要包括了Subquery（也就是子查询）和Join，内容不少，但是不难，基本上和sql差不太多。</p>\n<p><strong>1.Subquery</strong></p>\n<p>EPL里的Subquery和sql的类似，是否比sql的用法更多我不得而知，毕竟本人是sql菜鸟，只在where语句里用过子查询。废话不多说，先上几个Subquer的简单用法：</p>\n<p><strong><em>子查询结果作为外部事件的属性</em></strong></p>\n<ol>\n<li>select assetId, (select zone from ZoneClosed.std:lastevent()) as lastClosed from RFIDEvent</li>\n</ol>\n<p>  </p>\n<p>上面的例子是说返回当前RFIDEvent的assetId属性值和最新ZoneClosed事件的zone属性值，且以lastClosed作为zone的别名。</p>\n<p><strong><em>子查询关联外部事件的属性</em></strong></p>\n<ol>\n<li>select * from RfidEvent as RFID where ‘Dock 1’ &#x3D; (select name from Zones.std:unique(zoneId) where zoneId &#x3D; RFID.zoneId)</li>\n</ol>\n<p>  </p>\n<p>子查询语句中的where条件可以应用RFID的属性，即内部的zoneId&#x3D;RFID.zoneId</p>\n<ol>\n<li>select zoneId, (select name from Zones.std:unique(zoneId) where zoneId &#x3D; RFID.zoneId) as name from RFIDEvent</li>\n</ol>\n<p>  </p>\n<p>关联外部事件属性的同时也可以作为外部事件的属性返回。</p>\n<p><strong>子查询内部事件作为外部事件的属性</strong></p>\n<ol>\n<li>select (select * from MarketData.std:lastevent()) as md from SuperMarket</li>\n</ol>\n<p>  </p>\n<p>每进入一个SuperMarket事件就返回最新的MarketData事件作为属性返回，别名为md</p>\n<p><strong><em>子查询中应用聚合函数</em></strong></p>\n<ol>\n<li>select * from MarketData where price &gt; (select max(price) from MarketData(symbol&#x3D;’GOOG’).std:lastevent())</li>\n</ol>\n<p>  </p>\n<p>子查询出得最大price和当前事件的price进行比较</p>\n<ol>\n<li>select * from OrderEvent oe where qty &gt; (select sum(qty) from OrderEvent.win:time(1 hour) pd where pd.client &#x3D; oe.client)</li>\n</ol>\n<p>  </p>\n<p>子查询得出qty的总和和当前事件的qty进行比较</p>\n<p><strong><em>Filter中使用子查询</em></strong></p>\n<ol>\n<li>select * from BarData(ticker&#x3D;’MSFT’, closePrice &lt; (select movAgv from SMA20Stream(ticker&#x3D;’MSFT’).std:lastevent()))</li>\n</ol>\n<p>  </p>\n<p>子查询返回的movAgv和外部事件的属性closePrice进行比较作为外部事件的一个filter</p>\n<p><strong><em>Pattern中使用子查询</em></strong></p>\n<ol>\n<li>select * from pattern [  </li>\n<li>  a&#x3D;A -&gt; b&#x3D;B(bvalue &#x3D; (select d_val from DNamedWindow as d where d.d_id &#x3D; b.b_id and d.d_id &#x3D; a.a_id))  </li>\n<li>]</li>\n</ol>\n<p>  </p>\n<p>pattern的含义可先不深究，这里只要知道子查询可以用在pattern中就行了。</p>\n<p>**<em>Expression中使用子查询</em>**（什么是Expression？请看<a href=\"http://blog.csdn.net/luonanqin/article/details/11539221\">《Esper学习之五：EPL语法（一）》</a>的第八点）</p>\n<ol>\n<li>expression subq {  </li>\n<li>    (select max(quantity) as maxq, min(quantity) as minq from OrderEvent.win:time(1 min))  </li>\n<li>}  </li>\n<li>select (quantity - minq) &#x2F; (subq().maxq  - subq().minq) as prorated from OrderEvent</li>\n</ol>\n<p>  </p>\n<p>以上就是子查询的几种简单用法，不过有几点注意事项是要各位悉知的：</p>\n<p>1.子查询的返回必须使用data window或者view来进行限制，控制子查询使用的事件数（data window和view相当于具有某种功能性的事件集合）</p>\n<p>2.子查询语句只能由select子句，from子句以及where子句组成，其他的均不支持，比如group by，limit等</p>\n<p>3.没有关联外部事件的子查询语句也可以使用聚合函数</p>\n<p>4.子查询语句中的select子句必须对所有属性使用聚合函数</p>\n<p>5.在使用子查询时，如果子查询的事件和外部事件类型一样，则事件到来时，先经过子查询语句的处理，然后再经过外部语句的处理。如果包含了多个子查询语句，则事件的处理顺序规则较为复杂，本人暂时没做研究。</p>\n<p>针对第4点可能说得有些不明白，特此举例说明下：</p>\n<ol>\n<li><p>class Apple {  </p>\n</li>\n<li><p>    private int price;  </p>\n</li>\n<li><p>    private int size;  </p>\n</li>\n<li><p>    public void setPrice(int price) {  </p>\n</li>\n<li><p>        this.price &#x3D; price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setSize(int size) {  </p>\n</li>\n<li><p>        this.size &#x3D; size;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public int getPrice() {  </p>\n</li>\n<li><p>        return price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public int getSize() {  </p>\n</li>\n<li><p>        return size;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class Fruit {  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class Test {  </p>\n</li>\n<li><p>    public static void main(String[] args) throws InterruptedException {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “select (select sum(price), sum(size) from “ + Apple.class.getName() + “.std:lastevent()) from “ + Fruit.class.getName();  </p>\n</li>\n<li><p>        admin.createEPL(epl1);  </p>\n</li>\n<li><p>        System.out.println(“Create epl successfully!”);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>除了上面的语法外，有几个关键字也是需要大家注意的。</p>\n<p><strong><em>exists</em></strong></p>\n<p>这个exists和exist可不一样，虽说也是用在where子句中（不仅仅是where子句），但是exists前面是没有什么待比较属性的。语法如下：</p>\n<p>如果exists后面的subquery有查询结果，则返回true，如果没有查询结果就返回false。所以用在where子句中的示例如下：</p>\n<ol>\n<li>select * from Fruit as F where exists (select * from Apple.std:lastevent() where acount &#x3D; F.fcount)</li>\n</ol>\n<p>  </p>\n<p>既然exists语法返回的时布尔值，那么可不可以用工在Filter中呢？经本人测试，确实可以用。示例如下：</p>\n<ol>\n<li>select * from Fruit(exists (select * from Apple.win:keepall()))</li>\n</ol>\n<p>  </p>\n<p>不过在使用exists有两个注意点：</p>\n<p>1.exists后面的子查询语句一定要用圆括号括起来，遗漏的话会报语法错误。</p>\n<p>2.exists后面的子查询语句只能返回单列值。什么叫单列值？比如：Apple有price和size属性，那么select price和select size都是返回的单列（即一列），select price, size就是多列（即两列）。如果subquery中返回的大于一列，则会报multi-column错误。谨记！</p>\n<p><strong><em>in &#x2F; not in</em></strong></p>\n<p>用法和sql的一样，具体语法就不说了，直接看例子吧：</p>\n<ol>\n<li>&#x2F;&#x2F; 当前进入的Apple事件的aPrice存在于过去十秒内进入的Fruit的fPrice即可返回  </li>\n<li>select * from Apple where aPrice in (select fPrice from Fruit.win:time(10 s))</li>\n</ol>\n<p>  </p>\n<p>注意：从语法上说in&#x2F;not in前面是expression，并没有规定只能是属性。比如：Apple有aPrice和aSize两个int属性，则where子句可以写成”aPrice+aSize in …..”（这里只是举例，不expression不表示任何意思）</p>\n<p><strong><em>any &#x2F; some &#x2F; all</em></strong></p>\n<p>除了用in或者not in判断属性值是否存在于子查询结果中，还可以使用any&#x2F;some&#x2F;all并配合一些比较符号与子查询结果进行比较。语法如下：</p>\n<ol>\n<li>expression operator any&#x2F;some&#x2F;all (subquery)  </li>\n<li>&#x2F;&#x2F; operator包含：&gt;&#x3D;, !&#x3D;, &lt;&gt;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;</li>\n</ol>\n<p>  </p>\n<p>一个简单的例子：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 如果当前Apple事件的aPrice小于前十个Fruit中的任何一个fPrice，则返回此事件  </p>\n</li>\n<li><p>select * from Apple where aPrice &lt; any (select fPrice from Fruit.win:length(10))  </p>\n</li>\n<li><p>&#x2F;&#x2F; 如果当前Apple事件的aPrice小于前十个Fruit中的所有fPrice，则返回此事件  </p>\n</li>\n<li><p>select * from Apple where aPrice &lt; all (select fPrice from Fruit.win:length(10))</p>\n</li>\n</ol>\n<p>  </p>\n<p>some和any同义，所以用法也相同。既然一样为什么又要弄这么个关键字，我也没搞懂。。。</p>\n<p><strong><em>子查询返回多列数据</em></strong></p>\n<p>子查询可以返回单列数据，也可以返回多列数据。用法很简单，只需要“.”（点）就能找到每列的数据了。示例如下：</p>\n<ol>\n<li>select *,  </li>\n<li>  (select bid, offer from MarketData.std:unique(symbol) as md where md.symbol &#x3D; oe.symbol) as bidoffer  </li>\n<li>from OrderEvent oe</li>\n</ol>\n<p>  </p>\n<p>如上所示，子查询语句中包含bid和offer两列，并且这个语句的结果用bidoffer作为别名，所以要想得到bid和offer的具体数据只需要bidoffer.bid和bidoffer.offer即可，简单吧。子查询返回多行数据和返回多列数据类似，只不过数据会以数组形式是返回。</p>\n<p><strong>2.Join</strong></p>\n<p>Join在sql里是很常见的查询方法，EPL也同样支持，并且包含了full outer join &#x2F; left outer join &#x2F; right outer join &#x2F; inner join等。和sql基本无差别。</p>\n<p><strong><em>inner join</em></strong></p>\n<p>在没有任何关键字的修饰下，即为默认join方式，也就是inner join。必须等到所有join的事件都到了才可能输出，因为要是有where关联两个事件，得满足where条件了才能输出。例如：</p>\n<ol>\n<li>select * from Orange.std:lastevent(), Banana.std:lastevent()</li>\n</ol>\n<p>  </p>\n<p>如果只有Orange到或者Banana到都不会输出内容。std:lastevent是一种data window。如果不加特殊修饰的话（特殊修饰？下面会告诉你），事件必须有data window或者view修饰，否则会出现语法错误。当然，不同的事件可以用不同的data window修饰，并没有规定要一样。</p>\n<p>评论里c77_cn有问到：</p>\n<p>为什么”select a.id, b.field from Event as a, method : Static Class . getMethod (a.id) as b”没有window或者view也报错？</p>\n<p>       后来我重读了一下官方文档，没有指明必须要window或者view。我这么写是因为我测时候的时候，错误里说明了需要window或者view（在没有unidirectional修饰的情况下，这个修饰就是刚才说的“特殊修饰”）。这个句子正确我猜测method方法是每到一个事件都会被调用，所以能够完成join的工作。如果不用method，在没有window或者view的情况下，两类不同的事件分先后进入引擎，那先进入的的事件不能暂存的话如何完成join呢？</p>\n<p><strong><em>full outer join</em></strong></p>\n<p>上面看到的默认join方式是要求所有join的事件都必须到达引擎才会输出，并且join的事件之间通过where子句设置了条件判断，还得到达的两个事件满足条件了才能输出，而full outer join正好解决了这个问题，不管哪个事件到达，不管是否符合条件，都会输出。例如：</p>\n<ol>\n<li>select * from Orange.std:lastevent() as o full outer join Banana.std:lastevent() as b on o.price &#x3D; b.price</li>\n</ol>\n<p>  </p>\n<p>输出结果有4种可能：</p>\n<p>a.当只有Orange事件到达，没有满足join条件，会输出Orange事件，且Banana事件为null。</p>\n<p>b.当只有Banana事件到达，没有满足join条件，会输出Banana事件，且Orange事件为null。</p>\n<p>c.当两个事件都到达了，且没有满足join条件，即price不相等，则a，b情况各出现一次。</p>\n<p>d.当两个事件都到达了，且满足join条件，即price相等，即可输出满足条件的事件。</p>\n<p>所以说不管什么情况下，当前进入的事件都会输出，至于join的那个事件，满足即输出事件，不满足即输出null。</p>\n<p><strong><em>left outer join</em></strong></p>\n<p>full outer join输出了所进入的所有事件，不满足join条件的就输出null，而left outer join则规定关键字左边的事件可以即刻输出，而关键字右边的事件必须满足join条件才可输出。示例如下：</p>\n<ol>\n<li>select * from Pink.std:lastevent() as pi left outer join Pear.std:lastevent() as pe on pi.price &#x3D; pe.price</li>\n</ol>\n<p>  </p>\n<p>因为Pink事件在left outer join的左边，所以他的输出不受join条件的限制，即事件到来该怎么输出怎么输出。但是Pear就不同，由于有join条件限制，即两个事件的price要相等，所以如果Pear事件到达的时候，如果没有满足条件的Pink事件，则Pear事件是不会输出的。（注意：输出null也算输出，这里是null都不会输出，即不触发listener）</p>\n<p><strong><em>right outer join</em></strong></p>\n<p>和left outer join相反，在关键字右边的事件不受join条件约束，而左边的事件必须满足join条件才可输出。具体例子我就不举了，大家可以写两个句子试试。</p>\n<p>此外，在使用以上4种join的时候，可以多种join混用。比如：</p>\n<ol>\n<li>select * from Apple.std:lastevent() as a   </li>\n<li>     left outer join Banana.std:lastevent() as b on a.price &#x3D; b.price   </li>\n<li>     full outer join Orange.std:lastevent() as o on o.price &#x3D; a.price</li>\n</ol>\n<p>  </p>\n<p>on后面的表达式是join的限制条件，且只能用“&#x3D;”，如果想用其他操作符，则必须放到where子句中，这点尤其要注意。多个限制条件只能用and连接，不能用逗号，且限制的事件也要一样。比如：</p>\n<ol>\n<li><p>&#x2F;&#x2F; a，b分别是两个事件的别名  </p>\n</li>\n<li><p>&#x2F;&#x2F; 正确写法  </p>\n</li>\n<li><p>……on a.price &#x3D; b.price and a.size &#x3D; b.size……  </p>\n</li>\n<li><p>&#x2F;&#x2F; 错误写法1：不能用逗号连接  </p>\n</li>\n<li><p>……on a.price &#x3D; b.price, a.size &#x3D; b.size……  </p>\n</li>\n<li><p>&#x2F;&#x2F; 错误写法2：必须针对同样的事件进行限制（c是另一个事件的别名）  </p>\n</li>\n<li><p>……on a.price &#x3D; b.price and a.size &#x3D; c.size……</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong><em>Unidirectional Join</em></strong></p>\n<p>之前说到，如果不加特殊修饰，则join的事件都需要data window或者view修饰，目的是为了暂存事件以便等待满足条件的事件并执行join。如果想让某个事件到来时直接触发join，不需要暂存，也就是不需要data window或者view修饰，则需要加上一个特殊关键字——unidirectional。先看一个简单的例子：</p>\n<ol>\n<li>select * from Apple as a unidirectional, Banana.std:lastevent() as b where a.price &#x3D; b.price</li>\n</ol>\n<p>  </p>\n<p>上句的意思是：维持最新的Banana事件，直到一个和Banana的price相等的Apple事件到来时输出两者。</p>\n<p>       由于有unidirectional的修饰，表明Apple事件是即时出发join操作，也就是说进入此EPL的Apple事件是无状态的。所以当Apple事件到来时，如果没有price相等的Banana，则什么输出也没有，即使下一个Banana事件的price和之前来的Apple的price相等也不会有输出，因为那个Apple事件已经从这个句子的上下文中移除了。为了更好的看到效果，我给大家写了一给完整的例子：</p>\n<ol>\n<li><p>class Orange {  </p>\n</li>\n<li><p>    private int price;  </p>\n</li>\n<li><p>    public void setPrice(int price) {  </p>\n</li>\n<li><p>        this.price &#x3D; price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public int getPrice() {  </p>\n</li>\n<li><p>        return price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    @Override  </p>\n</li>\n<li><p>    public String toString() {  </p>\n</li>\n<li><p>        return “Orange price&#x3D;” + price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class Banana {  </p>\n</li>\n<li><p>    private int price;  </p>\n</li>\n<li><p>    public int getPrice() {  </p>\n</li>\n<li><p>        return price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setPrice(int price) {  </p>\n</li>\n<li><p>        this.price &#x3D; price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    @Override  </p>\n</li>\n<li><p>    public String toString() {  </p>\n</li>\n<li><p>        return “Banana price&#x3D;” + price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class JoinUnidirectionalListener implements UpdateListener {  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents) {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null) {  </p>\n</li>\n<li><p>            System.out.println(newEvents[0].get(“o”) + “, “ + newEvents[0].get(“b”));  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class JoinUnidirectionalTest {  </p>\n</li>\n<li><p>    public static void main(String[] args) throws InterruptedException {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “select * from “ + Orange.class.getName() + “ as o unidirectional, “ + Banana.class.getName()  </p>\n</li>\n<li><p>                + “.std:lastevent() as b where o.price &#x3D; b.price”;  </p>\n</li>\n<li><p>        EPStatement stat &#x3D; admin.createEPL(epl1);  </p>\n</li>\n<li><p>        stat.addListener(new JoinUnidirectionalListener());  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        Orange o1 &#x3D; new Orange();  </p>\n</li>\n<li><p>        o1.setPrice(1);  </p>\n</li>\n<li><p>        System.out.println(“Send Orange1”);  </p>\n</li>\n<li><p>        runtime.sendEvent(o1);  </p>\n</li>\n<li><p>        Banana b1 &#x3D; new Banana();  </p>\n</li>\n<li><p>        b1.setPrice(1);  </p>\n</li>\n<li><p>        System.out.println(“Send Banana1”);  </p>\n</li>\n<li><p>        runtime.sendEvent(b1);  </p>\n</li>\n<li><p>        Banana b2 &#x3D; new Banana();  </p>\n</li>\n<li><p>        b2.setPrice(2);  </p>\n</li>\n<li><p>        System.out.println(“Send Banana2”);  </p>\n</li>\n<li><p>        runtime.sendEvent(b2);  </p>\n</li>\n<li><p>        Orange o2 &#x3D; new Orange();  </p>\n</li>\n<li><p>        o2.setPrice(2);  </p>\n</li>\n<li><p>        System.out.println(“Send Orange2”);  </p>\n</li>\n<li><p>        runtime.sendEvent(o2);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li>Send Orange1  </li>\n<li>Send Banana1  </li>\n<li>Send Banana2  </li>\n<li>Send Orange2  </li>\n<li>Orange price&#x3D;2, Banana price&#x3D;2</li>\n</ol>\n<p>  </p>\n<p>可以看到o1和b1的price相等，o2和b2的price相等。o1先于b1进入引擎，由于o1进入时发现没有满足条件的Banana事件，所以什么输出也没有。之后b1进入了，因为满足条件的o1已经移除了，所以也是没有输出。b2先于o2进入引擎，被引擎暂存了起来，然后o2进入后，立刻进行join条件判断，发现暂存的b2的price相等，所以触发了listener并输出满足条件的这两个对象。</p>\n<p>unidirectional使用很简单，但是也有其限制：</p>\n<p>1.在一个join句子中，unidirectional关键字只能用于一个事件流。</p>\n<p>2.用unidirectional修饰的事件流，不能通过esper的查询api查出来，因为该事件流是无状态的，不会暂存在引擎中，所以就没法查了。（关于查询api，后面的章节会详说）</p>\n<p>3.使用了unidirectional修饰的事件流就不能再用data window或者view修饰了，也就是说他们是互斥的。</p>\n","text":"Esper学习之九：EPL语法（五）本篇的内容主要包括了Subquery（也就是子查询）和Join，内容不少，但是不难，基本上和sql差不太多。 1.Subqu...","permalink":"/post/BIGDATA/Esper学习之九：EPL语法（五）","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"price","slug":"price","count":2,"path":"api/categories/price.json"},{"name":"BIGDATA","slug":"price/BIGDATA","count":2,"path":"api/categories/price/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"join","slug":"join","count":1,"path":"api/tags/join.json"},{"name":"from","slug":"from","count":2,"path":"api/tags/from.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Esper%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B9%9D%EF%BC%9AEPL%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89\"><span class=\"toc-text\">Esper学习之九：EPL语法（五）</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Esper学习之十：EPL语法（六）","uid":"404c6135f2e86a9010b5598b38ae4379","slug":"BIGDATA/Esper学习之十：EPL语法（六）","date":"2023-06-09T09:30:55.000Z","updated":"2025-12-05T01:46:06.646Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之十：EPL语法（六）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之十：EPL语法（六） 在esper的文档中，epl访问数据库的配置放在了比较靠后的位置，不过为了方便各位学习，这里会先说明和数据库交互的相关配置...","permalink":"/post/BIGDATA/Esper学习之十：EPL语法（六）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"name","slug":"name","count":1,"path":"api/categories/name.json"},{"name":"BIGDATA","slug":"name/BIGDATA","count":1,"path":"api/categories/name/BIGDATA.json"}],"tags":[{"name":"esper","slug":"esper","count":2,"path":"api/tags/esper.json"},{"name":"sql","slug":"sql","count":1,"path":"api/tags/sql.json"},{"name":"import","slug":"import","count":1,"path":"api/tags/import.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Esper学习之八：EPL语法（四）","uid":"0b518321d13efd904f78fbe39f8f7eba","slug":"BIGDATA/Esper学习之八：EPL语法（四）","date":"2023-06-08T18:08:42.000Z","updated":"2025-12-05T01:46:05.998Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之八：EPL语法（四）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之八：EPL语法（四）关于EPL，已经写了三篇了，预估计了一下，除了今天这篇，后面还有5篇左右。大家可别嫌多，官方的文档对EPL的讲解有将近140...","permalink":"/post/BIGDATA/Esper学习之八：EPL语法（四）","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"insert","slug":"insert","count":1,"path":"api/categories/insert.json"},{"name":"BIGDATA","slug":"insert/BIGDATA","count":1,"path":"api/categories/insert/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"Asus","slug":"Asus","count":1,"path":"api/tags/Asus.json"},{"name":"into","slug":"into","count":1,"path":"api/tags/into.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}