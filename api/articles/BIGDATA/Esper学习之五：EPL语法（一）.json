{"title":"Esper学习之五：EPL语法（一）","uid":"c5c99cbcae7cadf842c021db56097c6a","slug":"BIGDATA/Esper学习之五：EPL语法（一）","date":"2023-06-08T17:50:09.000Z","updated":"2025-09-30T03:26:03.869Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之五：EPL语法（一）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","content":"<h1 id=\"Esper学习之五：EPL语法（一）\"><a href=\"#Esper学习之五：EPL语法（一）\" class=\"headerlink\" title=\"Esper学习之五：EPL语法（一）\"></a>Esper学习之五：EPL语法（一）</h1><p>上篇说到了Esper的Context，要是不了解的同学请参看《<a href=\"http://blog.csdn.net/luonanqin/article/details/10946329\">Esper学习之四：Context</a>》，看过的同学如果还是不理解的话可以给我评论，我将会尽可能的解答。之前有些同学问我Context和Group by有什么区别，其实如果只是很简单的用Context，那么确实没太大区别，无非是在Context下select可以不包含group by修饰的属性。但是Group by明显没有Context强大，很多复杂的分组Group by是没法做到的。不过在能达到同样效果的情况下，我还是建议使用Group by，毕竟Context的名字是不能重复的，而且在高并发的情况下Context会短时间锁住。至于原因，这已经是Esper的高级篇了，这里暂且不说。</p>\n<p>        今天开始讲解Esper的重中之重——EPL。EPL可以说是Esper的核心，要是不会将简单的业务需求转化为EPL，更别说复杂的EPL了，最后就等着被客户骂吧。接下来的很多篇都会围绕EPL讲解，大概会有十来篇吧，毕竟英文文档都有140页了，草草两篇根本就说不完。废话不多说，先简单介绍下什么是EPL，即使第一篇有说过，但是这里有必要细说一下。</p>\n<p>        EPL，全称Event Processing Language，是一种类似SQL的语言，包含了SELECT, FROM, WHERE, GROUP BY, HAVING 和 ORDER BY子句，同时用事件流代替了table作为数据源，并且能像SQL那样join，filtering和aggregation。所以如果各位有SQL基础的话，简单的EPL很容易掌握。除了select，EPL也有insert into，update，delete，不过含义和SQL并不是很接近。另外还有pattern和output子句，这两个是SQL所没有的。EPL还定义了一个叫view的东西，类似SQL的table，来决定哪些数据是可用的，Esper提供了十多个view，并且保证这些view可以被重复使用。而且用户还可以扩展view成为自定义view来满足需求。在view的基础上，EPL还提供了named window的定义，作用和view类似，但是更加灵活。。。还有很多东西，我再列举估计大家都要晕了，就先说说语法吧。</p>\n<p><strong>1.EPL Syntax</strong></p>\n<ol>\n<li>[annotations]  </li>\n<li>[expression_declarations]  </li>\n<li>[context context_name]  </li>\n<li>[insert into insert_into_def]  </li>\n<li>select select_list  </li>\n<li>from stream_def [as name] [, stream_def [as name]] [,…]  </li>\n<li>[where search_conditions]  </li>\n<li>[group by grouping_expression_list]  </li>\n<li>[having grouping_search_conditions]  </li>\n<li>[output output_specification]  </li>\n<li>[order by order_by_expression_list]  </li>\n<li>[limit num_rows]</li>\n</ol>\n<p>  </p>\n<p>        基本上大部分的EPL都是按照这个格式来定义。看过之前几篇的同学应该对里面的某些内容熟悉，比如context context_name，select select_list from stream_def等等。其他的可以先不关心，后面会有详解。比如wher，group by都会有专门的篇幅进行描述。</p>\n<p><strong>2.Time Periods</strong></p>\n<p>这部分的内容说的是Esper中时间的表达形式。语法如下：</p>\n<ol>\n<li>time-period : [year-part] [month-part] [week-part] [day-part] [hour-part]  </li>\n<li>[minute-part] [seconds-part] [milliseconds-part]  </li>\n<li>year-part : (number|variable_name) (“years” | “year”)  </li>\n<li>month-part : (number|variable_name) (“months” | “month”)  </li>\n<li>week-part : (number|variable_name) (“weeks” | “week”)  </li>\n<li>day-part : (number|variable_name) (“days” | “day”)  </li>\n<li>hour-part : (number|variable_name) (“hours” | “hour”)  </li>\n<li>minute-part : (number|variable_name) (“minutes” | “minute” | “min”)  </li>\n<li>seconds-part : (number|variable_name) (“seconds” | “second” | “sec”)  </li>\n<li>milliseconds-part : (number|variable_name) (“milliseconds” | “millisecond” |  </li>\n<li>“msec”)</li>\n</ol>\n<p>  </p>\n<p>与时间相关的EPL基本都会用到上面列出的东西，举几个例子说明下：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 计算过去的5分3秒中进入改语句的Fruit事件的平均price  </p>\n</li>\n<li><p>select avg(price) from Fruit.win:time(5 minute 3 sec)  </p>\n</li>\n<li><p>&#x2F;&#x2F; 每一天输出一次用户的账户总额  </p>\n</li>\n<li><p>select sum(account) from User output every 1 day</p>\n</li>\n</ol>\n<p>  </p>\n<p>用法比较简单，大家可以多试试。要注意的是，Esper规定每月的天数都是30天，所以对准确性要求高的业务，以月为单位进行计算会出现误差的。</p>\n<p><strong>3.Comments</strong></p>\n<p>注释基本上和Java差不多，只不过他没有&#x2F;** <em>&#x2F;和&#x2F;</em> <em>&#x2F;之分，只有&#x2F;</em> <em>&#x2F;和&#x2F;&#x2F;，毕竟不需要生成文档，所以就没那个必要了。&#x2F;&#x2F;只能单行注释，而&#x2F;</em> *&#x2F;可以多行注释。示例如下：</p>\n<ol>\n<li><p>a.单行注释  </p>\n</li>\n<li><p>&#x2F;&#x2F; This comment extends to the end of the line.  </p>\n</li>\n<li><p>&#x2F;&#x2F; Two forward slashes with no whitespace between them begin such comments.  </p>\n</li>\n<li><p>select * from MyEvent  </p>\n</li>\n<li><p>b.多行注释  </p>\n</li>\n<li><p>select * from OtherEvent   </p>\n</li>\n<li><p>&#x2F;* this is a very  </p>\n</li>\n<li><p>*important Event *&#x2F;  </p>\n</li>\n<li><p>c.混合注释  </p>\n</li>\n<li><p>select field1 &#x2F;&#x2F; first comment  </p>\n</li>\n<li><p>&#x2F;* second comment *&#x2F; field2 from MyEvent</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>4.Reserved Keywords</strong></p>\n<p>        EPL里如果某个事件属性，或者事件流的名称和EPL的关键字一样，那么必须要以<code>括起来才可用，</code>在键盘上esc的下面，1的左边，叫什么忘记了，估计说出来也有很多人不知道。比如：</p>\n<ol>\n<li><p>&#x2F;&#x2F; insert和Order是关键字，这个EPL无效  </p>\n</li>\n<li><p>select insert from Order  </p>\n</li>\n<li><p>&#x2F;&#x2F; `insert`和`Order`是属性名称和事件流名称，这个EPL有效  </p>\n</li>\n<li><p>select `insert` from `Order`</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>5.Escaping Strings</strong></p>\n<p>在EPL中，字符串使用单引号或者双引号括起来的，那如果字符串里包含有单引号或者双引号怎么办呢。请看例子：</p>\n<ol>\n<li>select * from OrderEvent(name&#x3D;’John’)  </li>\n<li>&#x2F;&#x2F; 等同于  </li>\n<li>select * from OrderEvent(name&#x3D;”John”)</li>\n</ol>\n<p>  </p>\n<p>如果name&#x3D;John’s，则需要反斜杠进行转义。</p>\n<ol>\n<li>select * from OrderEvent(name&#x3D;”John\\“s”)  </li>\n<li>&#x2F;&#x2F; 或者  </li>\n<li>select * from OrderEvent(name&#x3D;’john\\‘s’)</li>\n</ol>\n<p>  </p>\n<p>除了使用反斜杠，还可以使用unicode来表示单引号和双引号。</p>\n<ol>\n<li>select * from OrderEvent(name&#x3D;”John\\u0022s”)  </li>\n<li>&#x2F;&#x2F; 或者  </li>\n<li>select * from OrderEvent(name&#x3D;’john\\u0027s’)</li>\n</ol>\n<p>  </p>\n<p>注意在Java编写EPL的时候，反斜杠和无含义的双引号还得转义，不然会和String的双引号冲突。比如</p>\n<ol>\n<li>epService.getEPAdministrator().createEPL(“select * from OrderEvent(name&#x3D;’John\\&#39;s’)”);  </li>\n<li>&#x2F;&#x2F; … and for double quotes…  </li>\n<li>epService.getEPAdministrator().createEPL(“select * from OrderEvent(name&#x3D;\\“Quote \\\\&quot;Hello\\\\&quot;\\“)”);</li>\n</ol>\n<p>  </p>\n<p><strong>6.Data Types</strong></p>\n<p>        EPL支持Java所有的数值数据类型，包括基本类型及其包装类，同时还支持java.math.BigInteger和java.math.BigDecimal，并且能自动转换数据类型不丢失精度（比如short转int，int转short则不行）。如果想在EPL内进行数据转换，可以使用cast函数。完整例子如下：</p>\n<ol>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import com.espertech.esper.client.UpdateListener;  </p>\n</li>\n<li><p>class Banana  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    private int price;  </p>\n</li>\n<li><p>    public int getPrice()  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        return price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setPrice(int price)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        this.price &#x3D; price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class CastDataTypeListener1 implements UpdateListener  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null)  </p>\n</li>\n<li><p>        {  </p>\n</li>\n<li><p>            EventBean event &#x3D; newEvents[0];  </p>\n</li>\n<li><p>            System.out.println(“Average Price: “ + event.get(“cast(avg(price), int)”) + “, DataType is “  </p>\n</li>\n<li><p>                    + event.get(“cast(avg(price), int)”).getClass().getName());  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class CastDataTypeListener2 implements UpdateListener  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null)  </p>\n</li>\n<li><p>        {  </p>\n</li>\n<li><p>            EventBean event &#x3D; newEvents[0];  </p>\n</li>\n<li><p>            System.out.println(“Average Price: “ + event.get(“avg(price)”) + “, DataType is “ + event.get(“avg(price)”).getClass().getName());  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class CastDataTypeTest  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public static void main(String[] args) throws InterruptedException  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        String banana &#x3D; Banana.class.getName();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “select cast(avg(price),int) from “ + banana + “.win:length_batch(2)”;  </p>\n</li>\n<li><p>        String epl2 &#x3D; “select avg(price) from “ + banana + “.win:length_batch(2)”;  </p>\n</li>\n<li><p>        EPStatement state1 &#x3D; admin.createEPL(epl1);  </p>\n</li>\n<li><p>        state1.addListener(new CastDataTypeListener1());  </p>\n</li>\n<li><p>        EPStatement state2 &#x3D; admin.createEPL(epl2);  </p>\n</li>\n<li><p>        state2.addListener(new CastDataTypeListener2());  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        Banana b1 &#x3D; new Banana();  </p>\n</li>\n<li><p>        b1.setPrice(1);  </p>\n</li>\n<li><p>        runtime.sendEvent(b1);  </p>\n</li>\n<li><p>        Banana b2 &#x3D; new Banana();  </p>\n</li>\n<li><p>        b2.setPrice(2);  </p>\n</li>\n<li><p>        runtime.sendEvent(b2);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li>Average Price: 1, DataType is java.lang.Integer  </li>\n<li>Average Price: 1.5, DataType is java.lang.Double</li>\n</ol>\n<p>  </p>\n<p>要提醒的是，如果某个数除以0，那么默认会返回正无穷大或者负无穷大，不过可以配置这个结果，比如用null来代替。</p>\n<p><strong>7.Annotation</strong></p>\n<p>EPL也可以写注解，种类不多，大部分简单而有效。不过有些注解内容较多，在这里只是简单介绍，以后会在具体的使用场景进行详细讲解。首先来了解下注解的语法。</p>\n<ol>\n<li><p>&#x2F;&#x2F; 不包含参数或者单个参数的注解  </p>\n</li>\n<li><p>@annotation_name [(annotation_parameters)]  </p>\n</li>\n<li><p>&#x2F;&#x2F; 包含多个属性名-值对的注解  </p>\n</li>\n<li><p>@annotation_name (attribute_name &#x3D; attribute_value, [name&#x3D;value, …])  </p>\n</li>\n<li><p>&#x2F;&#x2F; 多个注解联合使用  </p>\n</li>\n<li><p>@annotation_name [(annotation_parameters)] [@annotation_name [(annotation_parameters)]] […]</p>\n</li>\n</ol>\n<p>  </p>\n<p>下面讲解具体注解时，会结合语法进行说明。</p>\n<p>a) @Name 指定EPL的名称，参数只有一个。例如：@Name(“MyEPL”)</p>\n<p>b) @Description 对EPL进行描述，参数只有一个。例如：@Description(“This is MyEPL”)</p>\n<p>c) @Tag 对EPL进行额外的说明，参数有两个，分别为Tag的名称和Tag的值，用逗号分隔。例如：@Tag(name&#x3D;”author”,value&#x3D;”luonanqin”)</p>\n<p>d) @Priority 指定EPL的优先级，参数只有一个，并且整数（可负可正）。例如：@Priority(10)</p>\n<p>e) @Drop 指定事件经过此EPL后不再参与其他的EPL计算，该注解无参数。</p>\n<p>f) @Hint 为EPL加上某些标记，让引擎对此EPL产生其他的操作，会改变EPL实例的内存占用，但通常不会改变输出。其参数固定，由Esper提供，之后的篇幅会穿插讲解这个注解的使用场景。</p>\n<p>g) @Audit EPL添加此注解后，可以额外输出EPL运行情况，有点类似日志的感觉（当然没有日志的功能全啦），具体使用场景在此先不提。</p>\n<p>h) @Hook 与SQL相关，这里暂且不说</p>\n<p>i) @EventRepresentation 这是用来指定EPL产生的计算结果事件包含的数据形式。参数只有一个，即array&#x3D;true或array&#x3D;false。false为默认值，代表数据形式为Map，若为true，则数据形式为数组。</p>\n<p>针对以上几个简单的注解，例子如下：</p>\n<ol>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import com.espertech.esper.client.UpdateListener;  </p>\n</li>\n<li><p>class Apple  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    private int price;  </p>\n</li>\n<li><p>    public int getPrice()  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        return price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setPrice(int price)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        this.price &#x3D; price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class SomeAnnotationListener implements UpdateListener  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents)  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null)  </p>\n</li>\n<li><p>        {  </p>\n</li>\n<li><p>            EventBean event &#x3D; newEvents[0];  </p>\n</li>\n<li><p>            System.out.println(“Sum Price: “ + event.get(“sum(price)”) + “, Event Type is “ + event.getEventType().getUnderlyingType());  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class SomeAnnotationTest  </p>\n</li>\n<li><p>{  </p>\n</li>\n<li><p>    public static void main(String[] args) throws InterruptedException  </p>\n</li>\n<li><p>    {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        String apple &#x3D; Apple.class.getName();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “@Priority(10)@EventRepresentation(array&#x3D;true) select sum(price) from “ + apple + “.win:length_batch(2)”;  </p>\n</li>\n<li><p>        String epl2 &#x3D; “@Name(\\“EPL2\\“)select sum(price) from “ + apple + “.win:length_batch(2)”;  </p>\n</li>\n<li><p>        String epl3 &#x3D; “@Drop select sum(price) from “ + apple + “.win:length_batch(2)”;  </p>\n</li>\n<li><p>        UpdateListener listenenr &#x3D; new SomeAnnotationListener();  </p>\n</li>\n<li><p>        EPStatement state1 &#x3D; admin.createEPL(epl1);  </p>\n</li>\n<li><p>        state1.addListener(listenenr);  </p>\n</li>\n<li><p>        EPStatement state2 &#x3D; admin.createEPL(epl2);  </p>\n</li>\n<li><p>        state2.addListener(listenenr);  </p>\n</li>\n<li><p>        System.out.println(“epl2’s name is “ + state2.getName());  </p>\n</li>\n<li><p>        EPStatement state3 &#x3D; admin.createEPL(epl3);  </p>\n</li>\n<li><p>        state3.addListener(listenenr);  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        Apple a1 &#x3D; new Apple();  </p>\n</li>\n<li><p>        a1.setPrice(1);  </p>\n</li>\n<li><p>        runtime.sendEvent(a1);  </p>\n</li>\n<li><p>        Apple a2 &#x3D; new Apple();  </p>\n</li>\n<li><p>        a2.setPrice(2);  </p>\n</li>\n<li><p>        runtime.sendEvent(a2);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li>epl2’s name is EPL2  </li>\n<li>Sum Price: 3, Event Type is class [Ljava.lang.Object;  </li>\n<li>Sum Price: 3, Event Type is interface java.util.Map  </li>\n<li>Sum Price: 3, Event Type is interface java.util.Map</li>\n</ol>\n<p>  </p>\n<p>可以发现，@Name和@EventRepresentation都起效果了，但是@Priority和@Drop没用，那是因为这两个是要配置才能生效的。以后讲Esper的Configuration的时候会说到。</p>\n<p><strong>8.Expression</strong></p>\n<p>        Expression类似自定义函数，通常用Lambda表达式来建立的（也有别的方法建立），而Lambda表达式就一个“ &#x3D;&gt; ”符号，表示“gose to”。符号的左边表示输入参数，符号右边表示计算过程，计算结果就是这个表达式的返回值，即Expression的返回值。语法如下：</p>\n<ol>\n<li>expression expression_name { expression_body }</li>\n</ol>\n<p>  </p>\n<p>expression是关键字，expression_name为expression的名称（唯一），expression_body是expression的具体内容。</p>\n<ol>\n<li>expression_body: (input_param [,input_param [,…]]) &#x3D;&gt; expression</li>\n</ol>\n<p>  </p>\n<p>input_param必须为事件流的别名，注意不是事件流名称。参数名写什么都可以（当然最好不用关键字），多个参数用逗号分隔，并用圆括号括起来。同时针对lamdba，举个例子一起说明下：</p>\n<ol>\n<li>expression middle { x &#x3D;&gt; (x.max+x.min)&#x2F;2 } select middle(apple) from Apple as apple</li>\n</ol>\n<p>  </p>\n<p>1. x表示输入参数，而x.max和x.min都是x代表的事件流的属性，如果事件流没这个属性，expression的定义就是错误的。</p>\n<p>2. express的定义必须在使用它的句子之前完成。使用时直接写expression的名字和用圆括号包含要计算的参数即可。再次提醒，expression的参数只能是事件流别名，即apple，别名的定义就如上面那样，事件流之后跟着as，然后再跟别名。</p>\n<p>上面这个句子的执行结果，就是middle的计算结果，各位自己试试吧。</p>\n<p>对于多个参数的expression定义，例子如下：</p>\n<ol>\n<li>expression sumage { (x,y) &#x3D;&gt; x.age+y.age } select sumage(me,you) from Me as me, You as you</li>\n</ol>\n<p>  </p>\n<p>要是两个age的数据类型不一样是什么结果呢？还是请各位自己试试。</p>\n<p>        expression_body除了可以用lambda表达式之外，还可以用聚合函数，变量，常量，子查询语句，甚至另一个表达式。子查询语句在没有in或者exist关键字的情况下，需要圆括号括起来。示例如下：</p>\n<ol>\n<li>expression newsSubq(md) {  </li>\n<li>(select sentiment from NewsEvent.std:unique(symbol) where symbol &#x3D; md.symbol)  </li>\n<li>}  </li>\n<li>select newsSubq(mdstream) from MarketDataEvent mdstream</li>\n</ol>\n<p>  </p>\n<p>针对变量和常量的示例如下：</p>\n<ol>\n<li>expression twoPI { Math.PI * 2} select twoPI() from SampleEvent</li>\n</ol>\n<p>  </p>\n<p>        对于expression里用另一个expression，EPL不允许在一个句子里建立两个expression，所以就出现了Global-Expression。普通的expression只作用于定义它的epl，如上面所有的包含select子句的epl就是如此。Global-Expression的语法如下：</p>\n<ol>\n<li>create expression expression_name { expression_body }</li>\n</ol>\n<p>  </p>\n<p>和普通的expression相比，就是多了个create，不过他不能和别的子句放在一起，即他是单独执行的。例如：</p>\n<ol>\n<li>epService.getEPAdministrator().createEPL(“create expression avgPrice { x &#x3D;&gt; (x.fist+x.last)&#x2F;2 }”);</li>\n</ol>\n<p>  </p>\n<p>最后再举个例子说一下某个expression里用另一个expression。</p>\n<ol start=\"2\">\n<li><p>create expression avgPrice { x &#x3D;&gt; (x.fist+x.last)&#x2F;2 }  </p>\n</li>\n<li><p>expression bananaPrice{ x &#x3D;&gt; avgPrice(x) } select bananaPrice(b) from Banana as b</p>\n</li>\n</ol>\n<p>  </p>\n<p>expression_body里的空格只是为了看着清晰，有没有空格不会有影响。</p>\n","text":"Esper学习之五：EPL语法（一）上篇说到了Esper的Context，要是不了解的同学请参看《Esper学习之四：Context》，看过的同学如果还是不理解...","permalink":"/post/BIGDATA/Esper学习之五：EPL语法（一）","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"EPL","slug":"EPL","count":2,"path":"api/categories/EPL.json"},{"name":"BIGDATA","slug":"EPL/BIGDATA","count":2,"path":"api/categories/EPL/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"expression","slug":"expression","count":1,"path":"api/tags/expression.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Esper%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BA%94%EF%BC%9AEPL%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89\"><span class=\"toc-text\">Esper学习之五：EPL语法（一）</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Esper学习之六：EPL语法（二）","uid":"6e82ad6dc435102e8221e6c49dde0575","slug":"BIGDATA/Esper学习之六：EPL语法（二）","date":"2023-06-08T17:50:28.000Z","updated":"2025-09-30T03:26:03.929Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之六：EPL语法（二）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之六：EPL语法（二） 从上一篇开始说EPL的语法，主要是关于注解的。今天来说说比较常用的语法，Select Clause和From Clause...","permalink":"/post/BIGDATA/Esper学习之六：EPL语法（二）","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"select","slug":"select","count":1,"path":"api/categories/select.json"},{"name":"BIGDATA","slug":"select/BIGDATA","count":1,"path":"api/categories/select/BIGDATA.json"}],"tags":[{"name":"from","slug":"from","count":2,"path":"api/tags/from.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"},{"name":"User","slug":"User","count":1,"path":"api/tags/User.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Esper学习之四：Context","uid":"b92a10e317d46caa8257a30d6cf731e3","slug":"BIGDATA/Esper学习之四：Context","date":"2023-06-08T17:49:42.000Z","updated":"2025-09-30T03:26:04.675Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之四：Context.json","keywords":"XuGuangSheng","cover":"/covers/espercontext.jpg","text":"Esper学习之四：Context Context是Esper里一个很有意思的概念，要是理解为上下文，我觉得有点不妥。以我的理解，Context就像一个框，把不...","permalink":"/post/BIGDATA/Esper学习之四：Context","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"context","slug":"context","count":1,"path":"api/categories/context.json"},{"name":"BIGDATA","slug":"context/BIGDATA","count":1,"path":"api/categories/context/BIGDATA.json"}],"tags":[{"name":"sendEvent","slug":"sendEvent","count":1,"path":"api/tags/sendEvent.json"},{"name":"Context","slug":"Context","count":1,"path":"api/tags/Context.json"},{"name":"price","slug":"price","count":1,"path":"api/tags/price.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}