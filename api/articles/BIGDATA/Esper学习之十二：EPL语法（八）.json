{"title":"Esper学习之十二：EPL语法（八）","uid":"247a554806e84b69903a33066dd8bcf1","slug":"BIGDATA/Esper学习之十二：EPL语法（八）","date":"2023-06-09T10:49:00.000Z","updated":"2025-09-30T03:26:04.088Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之十二：EPL语法（八）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","content":"<h1 id=\"Esper学习之十二：EPL语法（八）\"><a href=\"#Esper学习之十二：EPL语法（八）\" class=\"headerlink\" title=\"Esper学习之十二：EPL语法（八）\"></a>Esper学习之十二：EPL语法（八）</h1><p>  今天的内容十分重要，在Esper的应用中是十分常用的功能之一。它是一种事件集合，我们可以对这个集合进行增删查改，所以在复杂的业务场景中我们肯定不会缺少它。它就是Named Window。</p>\n<p>       由于本篇篇幅较长，希望各位童鞋慢慢阅读，并仔细研究文档中或者我给出的例子。</p>\n<p><strong>1.Create Named Window</strong></p>\n<p>       本篇的开头有说过named window是一种事件集合，它可以存储一种类型或多种类型的事件。如果我们不移除named window中的事件，那么事件应该存在生命周期，否则事件过多会有内存溢出的风险。所以我们在创建named window的时候会附带事件的过期策略，而各种过期策略就是用view来表达。named window的创建方式有三种：a.用已有的事件结构创建；b.自定义named window存放的事件格式；c.将已有的named window中包含的事件写入到新的named window中，即复制named window。</p>\n<p><strong>a</strong>.Creation by Modelling after an Existing Type<br>语法如下：</p>\n<ol>\n<li>[context context_name] create window window_name.view_specifications [as] [select list_of_properties from] event</li>\n</ol>\n<p>  </p>\n<p>1）context是关键字，后面跟着之前定义的context的名称。关于context的内容，请参看<a href=\"http://blog.csdn.net/luonanqin/article/details/10714687\">《Esper学习之三：Context》</a><br>2）create window后跟着要创建的named window的名字，且具有唯一性。名字后面紧跟着的“.”是用来连接事件过期策略的，即view。常用的view有win:length，win:length_batch，win:time，win:time_batch，std:unique，std:groupwin及自定义view等等，并且特定的view可以连用。PS：view的相关内容我打算在EPL语法讲解完之后就为各位呈上，以免影响其他章节的学习。<br>3）select子句表示将某个事件定义中的全部或者某些属性作为named window所维护的事件属性。如果将某个事件的所有属性都加入到named window中，则可以通过select子句前的as连接事件名称，并且省略select子句。这个将在接下来的例子进行说明。</p>\n<p>举几个例子说明下：</p>\n<ol>\n<li><p>&#x2F;&#x2F; FruitWindow保持最近10分钟的Apple事件  </p>\n</li>\n<li><p>create window FruitWindow.win:time(10 min) as Apple  </p>\n</li>\n<li><p>&#x2F;&#x2F; FruitWindow保持最近5分钟的Apple事件，但只包含size和price属性  </p>\n</li>\n<li><p>create window FruitWindow.win:time(5 min) as select size, price from Apple</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>b</strong>.Creation By Defining Columns Names and Types<br>和上一种创建方式不同，Esper允许自己指定named window能维护哪些属性，而不是通过别的事件定义来指定。语法如下：</p>\n<ol>\n<li>[context context_name]  </li>\n<li>create window window_name.view_specifications [as] (column_name column_type[,column_name column_type [,…]])</li>\n</ol>\n<p>  </p>\n<p>column_name表示属性名称，column_type表示属性类型。属性可以是一个，也可以是多个，多个用逗号分隔。示例如下：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 创建包含普通属性的named window  </p>\n</li>\n<li><p>create window SecurityEvent.win:time(30 sec) (ipAddress string, userId String, numAttempts int, properties String[])  </p>\n</li>\n<li><p>&#x2F;&#x2F; 创建包含事件类型属性的named window  </p>\n</li>\n<li><p>create schema SecurityData (name String, roles String[])  </p>\n</li>\n<li><p>create window SecurityEvent.win:time(30 sec) (ipAddress string, userId String, secData SecurityData, historySecData SecurityData[])</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>c</strong>.Populating a Named Window from an Existing Named Window<br>     这一节在文档中并没有放到create named window里，不过我认为这也是一种创建方式，所以就放在这里讲解了。这种创建方式很容易懂，就是将已经存在的named window中的event写到新的named window中。语法如下：</p>\n<ol>\n<li>[context context_name] create window window_name.view_specifications as windowname insert [where filter_expression]</li>\n</ol>\n<p>  </p>\n<p>windowname后面紧跟insert，表示将该window中的事件插入到新建的named window中。where filter_expression表示过滤插入的事件。实例如下：</p>\n<ol>\n<li>create window ScratchBuyOrders.win:time(10) as OrdersNamedWindow insert where side &#x3D; ‘buy’</li>\n</ol>\n<p>  </p>\n<p>以上就是三种创建方式，另外还有一个注解的使用，可以使触发时往Listener中传入的事件是数组或者map形式。这个需要各位自己调试的时候才能看到效果。实例如下：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 以数组形式反馈给UpdateListener  </p>\n</li>\n<li><p>@EventRepresentation(array&#x3D;true)create window FooWindow.win:time(5 sec) as (string prop1)  </p>\n</li>\n<li><p>&#x2F;&#x2F; 以Map形式反馈给UpdateListener  </p>\n</li>\n<li><p>@EventRepresentation(array&#x3D;false)create window FooWindow.win:time(5 sec) as (string prop1)  </p>\n</li>\n<li><p>… equals …  </p>\n</li>\n<li><p>create window FooWindow.win:time(5 sec) as (string prop1)</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>2.Inserting Into Named Windows</strong></p>\n<p>       创建好named window以后，我们就可以往里面插入事件了。插入的语法很简单，基本上和insert into语法一样。关于insert into，请参见《Esper学习之八：EPL语法（四）》。下面直接举几个例子：</p>\n<ol>\n<li><p>1）  </p>\n</li>\n<li><p>&#x2F;&#x2F; create named window with some properties of OrderEvent  </p>\n</li>\n<li><p>create window OrdersWindow.win:keepall() as select symbol, volume, price from OrderEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; insert into events to named window  </p>\n</li>\n<li><p>insert into OrdersWindow(symbol, volume, price) select name, count, price from FXOrderEvent  </p>\n</li>\n<li><p>… equals …  </p>\n</li>\n<li><p>insert into OrdersWindow select name as symbol, vol as volume, price from FXOrderEvent  </p>\n</li>\n<li><p>2）  </p>\n</li>\n<li><p>&#x2F;&#x2F; create named window with POJO  </p>\n</li>\n<li><p>create window OrdersWindow.win:time(30) as com.mycompany.OrderEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; insert into events to named window  </p>\n</li>\n<li><p>insert into OrdersWindow select * from com.mycompany.OrderEvent(symbol&#x3D;’IBM’)  </p>\n</li>\n<li><p>3）  </p>\n</li>\n<li><p>&#x2F;&#x2F; create named window  </p>\n</li>\n<li><p>create window OrdersWindow.win:time(30) as select *, price as derivedPrice from OrderEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; insert into events to named window with custom function  </p>\n</li>\n<li><p>insert into OrdersWindow select *, MyFunc.func(price, percent) as derivedPrice from OrderEvent  </p>\n</li>\n<li><p>4）  </p>\n</li>\n<li><p>&#x2F;&#x2F; create named window  </p>\n</li>\n<li><p>create window OrdersWindow.win:time(30) as select *, price as priceTotal from OrderEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; insert into events to named window  </p>\n</li>\n<li><p>insert into OrdersWindow select *, price * unit as priceTotal from ServiceOrderEvent  </p>\n</li>\n<li><p>5)  </p>\n</li>\n<li><p>&#x2F;&#x2F; create a named window for the base class  </p>\n</li>\n<li><p>create window OrdersWindow.std:unique(name) as select * from ProductBaseEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; The ServiceProductEvent class subclasses the ProductBaseEvent class  </p>\n</li>\n<li><p>insert into OrdersWindow select * from ServiceProductEvent  </p>\n</li>\n<li><p>6）  </p>\n</li>\n<li><p>&#x2F;**  </p>\n</li>\n<li><p> * interface InterfaceEvent {  </p>\n</li>\n<li><p> *         public int getPrice();  </p>\n</li>\n<li><p> *         public String getName();  </p>\n</li>\n<li><p> * }  </p>\n</li>\n<li><p> *&#x2F;  </p>\n</li>\n<li><p>&#x2F;&#x2F; create a named window for the inteface  </p>\n</li>\n<li><p>create window InterfaceWindow.win: time(2 sec) as select * from InterfaceEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; The InterfaceEventImpl is the implements for InterfaceEvent  </p>\n</li>\n<li><p>insert into InterfaceWindow select * from InterfaceEventImpl</p>\n</li>\n</ol>\n<p>  </p>\n<p>       从以上几个例子可以看得出，创建named window时用的事件类型只是用了该事件类型的属性定义，只要insert的事件列出了对应的属性名称就可以，当然属性的数据类型也得对应。如果属性名不对应，可以用as来重命名，就像例3和例4那样。第5个例子表明子类可以插入到父类定义的named window中。第六个例子表明实现类可以插入到用接口定义的named window中。</p>\n<p><strong>3.Selecting From Named Windows</strong></p>\n<p>       这一节主要讲解如何查询named window中的事件。准确来说这并不是一种无条件的查询方式，监听器监听查询语句以后，必须发送对应的事件(创建window时指定的事件类型)，然后先看是否满足named window的输出条件，再看是否满足查询语句的输出条件，所以并不是named window中的事件都会发给监听器。咱们先看一个例子：</p>\n<ol>\n<li><p>&#x2F;&#x2F; first, you should create the AllOrdersNamedWindow  </p>\n</li>\n<li><p>create named window AllOrdersNamedWindow.win:length_batch(3) as OrderEvent  </p>\n</li>\n<li><p>select * from AllOrdersNamedWindow</p>\n</li>\n</ol>\n<p>   </p>\n<p>       这个select句子看似很简单，实际上并不是查询AllOrdersNamedWindow中的事件。实际过程是这样的：首先引擎检查AllOrdersNamedWindow中有多少事件，因为过期策略是length_batch(3），意思是当AllOrdersNamedWindow中包含3个事件，才会将这3个事件同时输出，然后再等待新的3个事件，然后再一起输出这3个事件。。。所以当输入某一个事件时，若不满足3个数量，则select语句不会返回任何内容。若满足3个数量，则监听select语句的监听器会得到AllOrdersNamedWindow中的最新的3各事件。</p>\n<p>下面的几个句子都只有在length_batch(3)满足条件时才能有事件输出。    </p>\n<p>如果想查到上一次过期的3个事件，则查询语句改成下面的样子：</p>\n<ol>\n<li>select rstream * from AllOrdersNamedWindow</li>\n</ol>\n<p>   </p>\n<p>如果只想查询AllOrdernamedWindow里面的某几个属性，并且加上一些限制条件查看特定的事件，则查询语句改成下面的样子：</p>\n<ol>\n<li>select symbol, avg(price) from AllOrdersNamedWindow(sector&#x3D;’energy’)  group by symbol</li>\n</ol>\n<p>  </p>\n<p>       因为上面所说的特点，所以查询语句可以在事件发送后再建立，也就是说我什么时候想查什么时候再建句子，named windows里有多少事件就如实返回多少。下面举个完整的例子总结一下：</p>\n<ol>\n<li><p>package example;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import com.espertech.esper.client.UpdateListener;  </p>\n</li>\n<li><p>class SelectEvent {  </p>\n</li>\n<li><p>    private int price;  </p>\n</li>\n<li><p>    private String name;  </p>\n</li>\n<li><p>    public int getPrice() {  </p>\n</li>\n<li><p>        return price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setPrice(int price) {  </p>\n</li>\n<li><p>        this.price &#x3D; price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public String getName() {  </p>\n</li>\n<li><p>        return name;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setName(String name) {  </p>\n</li>\n<li><p>        this.name &#x3D; name;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    @Override  </p>\n</li>\n<li><p>    public String toString() {  </p>\n</li>\n<li><p>        return “name&#x3D;”+name+”, price&#x3D;”+price;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class SelectNamedWindowListener implements UpdateListener{  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents) {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null) {  </p>\n</li>\n<li><p>            System.out.println(“There is “+newEvents.length+” events to be return!”);  </p>\n</li>\n<li><p>            for (int i &#x3D; 0;  i &lt; newEvents.length;i++) {  </p>\n</li>\n<li><p>                System.out.println(newEvents[i].getUnderlying());  </p>\n</li>\n<li><p>            }  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class SelectNamedWindowTest{  </p>\n</li>\n<li><p>    public static void main(String[] args) {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        String selectEvent &#x3D; SelectEvent.class.getName();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “create window SelectNamedWindow.win:length_batch(3) as “ + selectEvent;  </p>\n</li>\n<li><p>        admin.createEPL(epl1);  </p>\n</li>\n<li><p>        System.out.println(“Create named window: create window SelectNamedWindow.win:length_batch(3) as “+selectEvent);  </p>\n</li>\n<li><p>        String epl2 &#x3D; “insert into SelectNamedWindow select * from “ + selectEvent;  </p>\n</li>\n<li><p>        admin.createEPL(epl2);  </p>\n</li>\n<li><p>        SelectEvent se1 &#x3D; new SelectEvent();  </p>\n</li>\n<li><p>        se1.setName(“se1”);  </p>\n</li>\n<li><p>        se1.setPrice(1);  </p>\n</li>\n<li><p>        System.out.println(“Send SelecEvent1 “ + se1);  </p>\n</li>\n<li><p>        runtime.sendEvent(se1);  </p>\n</li>\n<li><p>        SelectEvent se2 &#x3D; new SelectEvent();  </p>\n</li>\n<li><p>        se2.setName(“se2”);  </p>\n</li>\n<li><p>        se2.setPrice(2);  </p>\n</li>\n<li><p>        System.out.println(“Send SelecEvent2 “ + se2);  </p>\n</li>\n<li><p>        runtime.sendEvent(se2);  </p>\n</li>\n<li><p>        String epl3 &#x3D; “select * from SelectNamedWindow(price&gt;&#x3D;2)”;  </p>\n</li>\n<li><p>        EPStatement state3 &#x3D; admin.createEPL(epl3);  </p>\n</li>\n<li><p>        state3.addListener(new SelectNamedWindowListener());  </p>\n</li>\n<li><p>        System.out.println(“Register select sentence: select * from SelectNamedWindow(price&gt;&#x3D;2)”);  </p>\n</li>\n<li><p>        SelectEvent se3 &#x3D; new SelectEvent();  </p>\n</li>\n<li><p>        se3.setName(“se3”);  </p>\n</li>\n<li><p>        se3.setPrice(3);  </p>\n</li>\n<li><p>        System.out.println(“Send SelecEvent3 “ + se3 + “\\n”);  </p>\n</li>\n<li><p>        runtime.sendEvent(se3);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li><p>Create named window: create window SelectNamedWindow.win:length_batch(3) as example.SelectEvent  </p>\n</li>\n<li><p>Send SelecEvent1 name&#x3D;se1, price&#x3D;1  </p>\n</li>\n<li><p>Send SelecEvent2 name&#x3D;se2, price&#x3D;2  </p>\n</li>\n<li><p>Register select sentence: select * from SelectNamedWindow(price&gt;&#x3D;2)  </p>\n</li>\n<li><p>Send SelecEvent3 name&#x3D;se3, price&#x3D;3  </p>\n</li>\n<li><p>There is 2 events to be return!  </p>\n</li>\n<li><p>name&#x3D;se2, price&#x3D;2  </p>\n</li>\n<li><p>name&#x3D;se3, price&#x3D;3</p>\n</li>\n</ol>\n<p>  </p>\n<p>      上面的例子有一段注释“select * from SelectamedWindow.win:time(3 sec)”，实际上是因为win:time(3 sec)这个东西，之前create named window的时候，已经使用了一个win的view，所以这里就不能再使用win的view了。这个与view相关，就一笔带过了。另外还有一点，在select句子中的filter如果使用了variable，当变量的值在句子创建后改变了，引擎不会读取新的值，这个需要额外注意。</p>\n<p><strong>4.Triggered Select on Named Windows：On Select</strong></p>\n<p>       上一节说到的查询方式实际上并不是很好用，而这一节就提供了一个非常简单的查询办法。他是通过发送一个触发事件即可得到当前window里有些什么事件，你还可以设置这个触发事件满足什么要求才可触发，或者这个触发事件和window中的事件达到某种关联后输出符合这个关联的事件或事件的部分属性。先来看看语法：</p>\n<ol>\n<li>on event_type[(filter_criteria)] [as stream_name]  </li>\n<li>select select_list from window_name [as stream_name]  </li>\n<li>[where criteria_expression] [group by grouping_expression_list] [having grouping_search_conditions] [order by order_by_expression_list]</li>\n</ol>\n<p>  </p>\n<p>       event_type表示用来触发的事件，可以是任何一种事件类型，也可以是pattern（用来表达较为复杂的触发条件）。后面用括号括起来的包含了触发事件的限制条件，必须满足这个里面约定的条件才可用来触发查询。as stream_name为可选参数，主要用于具体的查询语句或者与window做关联用。select语句就不说了，和普通的没太大区别。后面的where条件限制了查询结果，满足结果的才可返回给监听器。group by、having、order by和之前说的用法一样，这里不做说明了。我们先来看几个简单的例子：</p>\n<ol>\n<li><p>&#x2F;&#x2F; QueryEvent作为触发事件，查询OrderNamedWindow中的所有事件，并附带触发的事件作为结果返回（什么意思？）  </p>\n</li>\n<li><p>on QueryEvent select * from OrdersNamedWindow  </p>\n</li>\n<li><p>&#x2F;&#x2F; QueryEvent作为触发事件，查询OrderNamedWindow中的所有事件作为结果返回（懂了吧）  </p>\n</li>\n<li><p>on QueryEvent select win.* from OrdersNamedWindow as win  </p>\n</li>\n<li><p>&#x2F;&#x2F; volume大于0的QueryEvent作为触发事件，查询OrderNamedWindow中的事件，且事件的symbol要与QueryEvent的symbol一样，返回满足条件的window事件的symbol值，以及QueryEvent的symbol和volume值  </p>\n</li>\n<li><p>on QueryEvent(volume&gt;0) as query  </p>\n</li>\n<li><p>select query.symbol, query.volume, win.symbol from OrdersNamedWindow as win  </p>\n</li>\n<li><p>where win.symbol &#x3D; query.symbol  </p>\n</li>\n<li><p>&#x2F;&#x2F; group by, having, order by的用法与前面所讲无差别，都是针对查询出来的事件  </p>\n</li>\n<li><p>on QueryEvent  </p>\n</li>\n<li><p>select symbol, sum(volume) from OrdersNamedWindow as win  </p>\n</li>\n<li><p>group by symbol having volume &gt; 0 order by symbol  </p>\n</li>\n<li><p>&#x2F;&#x2F; 每一次OrderNamedWindow有变化并满足限制条件即可触发监听器返回window中的事件。  </p>\n</li>\n<li><p>on OrdersNamedWindow as trig  </p>\n</li>\n<li><p>select onw.symbol, sum(onw.volume) from OrdersNamedWindow as onw  </p>\n</li>\n<li><p>where onw.symbol &#x3D; trig.symbol</p>\n</li>\n</ol>\n<p>  </p>\n<p>      前两个例子我相信大家已经明白了。如果select子句里是*，则返回的不仅仅是window中的事件，还会返回触发查询的事件，并且返回的多行结果中每行都会包含这个触发事件。第三个例子可以看出as的用法。最后一个例子有些特别，触发的事件就是named window本身，目的就是为了named window变化了就能返回变化后的结果。但是这里的“变化”不是简单的事件有增加或者减少，而是指named window定义时指定的view达到触发条件有输出了，你才能真的看到查询结果。下面列一个完整的例子来概括一下上面说到的几点内容：</p>\n<p>执行结果：</p>\n<ol>\n<li><p>Create Window:create window OnSelectWindow.win:length(2) as select * from example.OnSelectEvent  </p>\n</li>\n<li><p>Trigger sentence: on example.OnSelectTrigger(trigger&gt;&#x3D;2) select osw.* from OnSelectWindow as osw  </p>\n</li>\n<li><p>Send OnSelectEvent 1: name&#x3D;ose1, size&#x3D;1  </p>\n</li>\n<li><p>Send OnSelectEvent 2: name&#x3D;ose2, size&#x3D;2  </p>\n</li>\n<li><p>Send OnSelectEvent 3: name&#x3D;ose3, size&#x3D;3  </p>\n</li>\n<li><p>Send OnSelectTrigger trigger&#x3D;1  </p>\n</li>\n<li><p>Send OnSelectTrigger trigger&#x3D;2  </p>\n</li>\n<li><p>Trigger On Select:  </p>\n</li>\n<li><p>There is 2 OnSelectEvent in OnSelectWindow!  </p>\n</li>\n<li><p>name&#x3D;ose2, size&#x3D;2  </p>\n</li>\n<li><p>name&#x3D;ose3, size&#x3D;3  </p>\n</li>\n<li><p>Trigger sentence: on OnSelectWindow select osw.* from OnSelectWindow as osw  </p>\n</li>\n<li><p>Send OnSelectEvent 4(also a Trigger): name&#x3D;ose4, size&#x3D;4  </p>\n</li>\n<li><p>Trigger On Select:  </p>\n</li>\n<li><p>There is 2 OnSelectEvent in OnSelectWindow!  </p>\n</li>\n<li><p>name&#x3D;ose3, size&#x3D;3  </p>\n</li>\n<li><p>name&#x3D;ose4, size&#x3D;4  </p>\n</li>\n<li><p>Send OnSelectEvent 5(also a Trigger): name&#x3D;ose5, size&#x3D;5  </p>\n</li>\n<li><p>Trigger On Select:  </p>\n</li>\n<li><p>There is 2 OnSelectEvent in OnSelectWindow!  </p>\n</li>\n<li><p>name&#x3D;ose4, size&#x3D;4  </p>\n</li>\n<li><p>name&#x3D;ose5, size&#x3D;5</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>5.Triggered Delete on Named Windows：On Delete</strong></p>\n<p>       除了可以用on select语句查询named window，还可以用on delete语句删除named window中的事件。语法和on select基本一样，同样能够设置一定条件限制触发事件，以及删除符合特定条件的事件。语法如下：</p>\n<ol>\n<li>on event_type[(filter_criteria)] [as stream_name] delete from window_name [as stream_name]  </li>\n<li>[where criteria_expression]</li>\n</ol>\n<p>  </p>\n<p>和on select不同的是，delete后面不跟属性什么的，因为删除的就是事件，不存在删除事件中的某些属性这种情况。filter_criteria用来限制触发事件，where criteria_expression用来限制要删除的事件。而且没有group by, having, Order by。举例如下：</p>\n<p>执行结果：</p>\n<ol>\n<li><p>Create Window: create window OnDeleteWindow.win:keepall() as select * from example.OnDeleteEvent  </p>\n</li>\n<li><p>Delete Trigger: on example.OnDeleteTrigger(trigger&gt;0) as odt delete from OnDeleteWindow as odw where odt.trigger&#x3D;odw.size  </p>\n</li>\n<li><p>Select Trigger: on example.OnDeleteTrigger(trigger&#x3D;0) select odw.* from OnDeleteWindow as odw  </p>\n</li>\n<li><p>Send OnDeleteEvent 1: name&#x3D;ose1, size&#x3D;1  </p>\n</li>\n<li><p>Send OnDeleteEvent 2: name&#x3D;ose2, size&#x3D;2  </p>\n</li>\n<li><p>Send OnDeleteEvent 3: name&#x3D;ose3, size&#x3D;3  </p>\n</li>\n<li><p>Send OnSelectTrigger trigger&#x3D;0  </p>\n</li>\n<li><p>Trigger On Select:  </p>\n</li>\n<li><p>There is 3 OnDeleteEvent in OnDeleteWindow!  </p>\n</li>\n<li><p>name&#x3D;ose1, size&#x3D;1  </p>\n</li>\n<li><p>name&#x3D;ose2, size&#x3D;2  </p>\n</li>\n<li><p>name&#x3D;ose3, size&#x3D;3  </p>\n</li>\n<li><p>Send OnDeleteTrigger trigger&#x3D;2  </p>\n</li>\n<li><p>Trigger On Delete:  </p>\n</li>\n<li><p>There is 1 OnDeleteEvent to be deleted in OnDeleteWindow!  </p>\n</li>\n<li><p>name&#x3D;ose2, size&#x3D;2  </p>\n</li>\n<li><p>Send OnSelectTrigger trigger&#x3D;0  </p>\n</li>\n<li><p>Trigger On Select:  </p>\n</li>\n<li><p>There is 2 OnDeleteEvent in OnDeleteWindow!  </p>\n</li>\n<li><p>name&#x3D;ose1, size&#x3D;1  </p>\n</li>\n<li><p>name&#x3D;ose3, size&#x3D;3</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>6.Triggered Select+Delete on Named Windows: the On Select Delete</strong></p>\n<p>        如果我们想在从named window查询出结果的同时删掉查询结果，那么可以使用on select and delete语句。语法和on select语句几乎是一样的，只是多了个delete。语法如下：</p>\n<ol>\n<li>on trigger  </li>\n<li>select [and] delete select_list…  </li>\n<li>… (please see on-select for from, group by, having, order by)…</li>\n</ol>\n<p>  </p>\n<p>直接上一个完整例子：</p>\n<p>执行结果：</p>\n<ol>\n<li><p>Create Window: create window OnSelectDeleteWindow.win:keepall() as select * from example.OnSelectDeleteEvent  </p>\n</li>\n<li><p>Select and Delete Trigger: on example.OnSelectDeleteTrigger select and delete osw.* from OnSelectDeleteWindow as osw  </p>\n</li>\n<li><p>Send OnSelectDeleteEvent 1: name&#x3D;osde1, size&#x3D;1  </p>\n</li>\n<li><p>Send OnSelectDeleteEvent 2: name&#x3D;osde2, size&#x3D;2  </p>\n</li>\n<li><p>Send OnSelectDeleteEvent 3: name&#x3D;osde3, size&#x3D;3  </p>\n</li>\n<li><p>Send OnSelectDeleteTrigger trigger&#x3D;1  </p>\n</li>\n<li><p>Trigger On Select and Delete:  </p>\n</li>\n<li><p>There is 3 OnSelectDeleteEvent in OnSelectDeleteWindow!  </p>\n</li>\n<li><p>name&#x3D;osde1, size&#x3D;1  </p>\n</li>\n<li><p>name&#x3D;osde2, size&#x3D;2  </p>\n</li>\n<li><p>name&#x3D;osde3, size&#x3D;3  </p>\n</li>\n<li><p>Send OnSelectDeleteEvent 4: name&#x3D;osde4, size&#x3D;4  </p>\n</li>\n<li><p>Send OnSelectDeleteTrigger trigger&#x3D;1  </p>\n</li>\n<li><p>Trigger On Select and Delete:  </p>\n</li>\n<li><p>There is 1 OnSelectDeleteEvent in OnSelectDeleteWindow!  </p>\n</li>\n<li><p>name&#x3D;osde4, size&#x3D;4</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>7.Updating Named Windows: the On Update clause</strong></p>\n<p>除了查询和删除window里的事件，我们还可以更新事件，而且同样也是通过发送一个特定事件来出发更新操作。语法如下：</p>\n<ol>\n<li>on event_type[(filter_criteria)] [as stream_name]  </li>\n<li>update window_name [as stream_name]  </li>\n<li>set property_name &#x3D; expression [, property_name &#x3D; expression [,…]] [where criteria_expression]</li>\n</ol>\n<p>  </p>\n<p>filter_criteria用来过滤触发事件，criteria_expression用来过滤window中的事件不予更改。和sql类似，set后面跟着要修改的属性及要赋的值，多个属性名值对用逗号分隔。先看一个简单的例子：</p>\n<ol>\n<li>on NewOrderEvent(volume&gt;0) as myNewOrders  </li>\n<li>update AllOrdersNamedWindow as myNamedWindow set price &#x3D; myNewOrders.price  </li>\n<li>where myNamedWindow.symbol &#x3D; myNewOrders.symbol</li>\n</ol>\n<p>  </p>\n<p>我想不用做太多解释大家就能很容易看懂。不过下面这个例子呢：</p>\n<ol>\n<li>on UpdateEvent as upd  </li>\n<li>update MyWindow as win  </li>\n<li>set field_a &#x3D; 1,  </li>\n<li>field_b &#x3D; win.field_a, &#x2F;&#x2F; assigns the value 1  </li>\n<li>field_c &#x3D; initial.field_a &#x2F;&#x2F; assigns the field_a original value before update</li>\n</ol>\n<p>  </p>\n<p>       上面的例子中，field_a被更新为1，然后用修改后的field_a赋值给field_b，那么field_b实际上也变成1了。但是如果想用更新前的field_a的值赋给field_c，那么就要写成initial.field_a。initial是关键字，所以不能省略。<br>我们可以用监听器监听on update语句，返回给监听器的就是被更新的事件。结合上面的两点内容，我们来看一个完整的例子：</p>\n<p>执行结果：</p>\n<ol>\n<li><p>Create Window: create window OnUpdateWindow.win:keepall() as select * from example.OnUpdateEvent  </p>\n</li>\n<li><p>Update Trigger sentence: on example.OnUpdateTrigger(trigger&gt;0) as out update OnUpdateWindow as ouw set size&#x3D;out.trigger, price&#x3D;initial.size where out.trigger&lt;ouw.price  </p>\n</li>\n<li><p>Send OnUpdateEvent 1: name&#x3D;oue1, size&#x3D;1, price&#x3D;2  </p>\n</li>\n<li><p>Send OnUpdateEvent 2: name&#x3D;oue2, size&#x3D;2, price&#x3D;3  </p>\n</li>\n<li><p>Send OnUpdateEvent 3: name&#x3D;oue3, size&#x3D;3, price&#x3D;4  </p>\n</li>\n<li><p>Send OnUpdateTrigger trigger&#x3D;0  </p>\n</li>\n<li><p>Trigger On Select:  </p>\n</li>\n<li><p>There is 3 OnUpdateEvent in OnUpdateWindow!  </p>\n</li>\n<li><p>name&#x3D;oue1, size&#x3D;1, price&#x3D;2  </p>\n</li>\n<li><p>name&#x3D;oue2, size&#x3D;2, price&#x3D;3  </p>\n</li>\n<li><p>name&#x3D;oue3, size&#x3D;3, price&#x3D;4  </p>\n</li>\n<li><p>Send OnUpdateTrigger trigger&#x3D;2  </p>\n</li>\n<li><p>Trigger On Update:  </p>\n</li>\n<li><p>There is 2 to be updated in OnUpdateWindow!  </p>\n</li>\n<li><p>name&#x3D;oue2, size&#x3D;2, price&#x3D;2  </p>\n</li>\n<li><p>name&#x3D;oue3, size&#x3D;2, price&#x3D;3  </p>\n</li>\n<li><p>Send OnUpdateTrigger trigger&#x3D;0  </p>\n</li>\n<li><p>Trigger On Select:  </p>\n</li>\n<li><p>There is 3 OnUpdateEvent in OnUpdateWindow!  </p>\n</li>\n<li><p>name&#x3D;oue1, size&#x3D;1, price&#x3D;2  </p>\n</li>\n<li><p>name&#x3D;oue2, size&#x3D;2, price&#x3D;2  </p>\n</li>\n<li><p>name&#x3D;oue3, size&#x3D;2, price&#x3D;3</p>\n</li>\n</ol>\n<p>  </p>\n<p>       OnUpdateEvent和平时我们定义的事件不太一样，它实现了Serializable接口。这是因为update更新属性前会复制一份同样的事件暂存，比如initial这种操作就需要更新前的值，所以就需要我们实现序列化接口。如果不想通过代码完成这个序列化要求，也可以通过配置完成，这个就不在这里说了。另外还有以下几点需要注意：<br>a）需要更新的属性一定要是可写的<br>b）XML格式的事件不能通过此语句更新<br>c）嵌套属性不支持更新</p>\n<p><strong>8.Triggered Upsert using the On-Merge Clause</strong></p>\n<p>       除了上面的on select，on update，on delete操作，esper还支持on merge操作。他可以在满足不同条件的情况下完成对应的window中的事件的insert，update和delete操作，所以语法相对前面几种就复杂很多。语法如下：</p>\n<ol>\n<li>on event_type[(filter_criteria)] [as stream_name] merge [into] window_name [as stream_name]  </li>\n<li>[where criteria_expression]  </li>\n<li>when [not] matched [and search_condition] then [  </li>\n<li>insert [into streamname] [ (property_name [, property_name] [,…]) ]  </li>\n<li>select select_expression [, select_expression[,…]] [where filter_expression]  </li>\n<li>|  </li>\n<li>update set property_name &#x3D; expression [, property_name &#x3D; expression [,…]] [where filter_expression]  </li>\n<li>|  </li>\n<li>delete [where filter_expression]  </li>\n<li>]  </li>\n<li>  [then [insert|update|delete]] [,then …]  </li>\n<li>  [when …  then … […]]</li>\n</ol>\n<p>  </p>\n<p>a.第一行就不多说了，和前面的用法都一样。<br>b.第二行的where语句将事件分为了matched（满足where条件）和not matched（不满足where条件）两类<br>c.第三行的when配合matched或者not matched表示“window中满足where条件的事件，执行下面的操作&#x2F;window中不满足where条件的事件，执行下面的操作”。search_condition为可选字段，表示再次过滤matched或not matched中的事件，只有没被过滤掉的事件才可以被then后面的语句操作。<br>d.第四行的insert语句和之前说的insert into不太一样。虽然都表示插入事件，但是由于into streamname是可选，所以在只有insert关键字的情况下，会将触发的事件插入到当前的named window中。如果要指明插入到别的named window中就要在insert之后带上into及window的名字。再之后的圆括号中的内容表示要插入的事件的属性，一般情况是在将事件插入到别的window中时，用它来重命名第五行中列出的属性。<br>e.第五行实际是配合第四行一起使用的。select子句不可少，不然引擎就不知道要往window中插入什么内容了。select的内容可以是*，也可以是属性列表。where语句再一次限制可插入的触发事件。注意select后面没有from，因为事件来源就是当时的触发事件。<br>f.第七行用来更新符合条件的事件，可更新单个或多个属性，where条件判断是否可进行更新操作。<br>g.第九行用来删除符合条件的事件，只包含关键字delete以及可选的where语句。<br>h.最后两行表示on merge中可以有多个when，每个when可以有多个then及insert或updata或delete语句，这样就能组成一个非常复杂的merge操作了。</p>\n<p>语法内容有点多，但是应该都还容易理解吧。除了语法，还有几点需要注意的：<br>1. when not matched后面只能跟insert语句，而when matched则没有任何限制。<br>2. select语句中不能使用聚合函数。<br>3. 当某一个when matched或者no matched和其search_condition满足，则这个when下的所有then都会执行，并且按照顺序执行。<br>4. 避免在一个when中同时使用update和delete，esper不能保证两个都有效执行。</p>\n<p>接下来我给大家一个完整的例子，各位可以好好揣摩一下上面所讲的要点。</p>\n<ol>\n<li><p>package example;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import com.espertech.esper.client.UpdateListener;  </p>\n</li>\n<li><p>import java.io.Serializable;  </p>\n</li>\n<li><p>import java.util.HashMap;  </p>\n</li>\n<li><p>import java.util.Map;  </p>\n</li>\n<li><p>class MergeEvent implements Serializable {  </p>\n</li>\n<li><p>    private int mergeId;  </p>\n</li>\n<li><p>    private String mergeStr;  </p>\n</li>\n<li><p>    private int mergeSize;  </p>\n</li>\n<li><p>    private boolean deleteFlag;  </p>\n</li>\n<li><p>    public int getMergeId() {  </p>\n</li>\n<li><p>        return mergeId;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setMergeId(int mergeId) {  </p>\n</li>\n<li><p>        this.mergeId &#x3D; mergeId;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public String getMergeStr() {  </p>\n</li>\n<li><p>        return mergeStr;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setMergeStr(String mergeStr) {  </p>\n</li>\n<li><p>        this.mergeStr &#x3D; mergeStr;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public int getMergeSize() {  </p>\n</li>\n<li><p>        return mergeSize;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setMergeSize(int mergeSize) {  </p>\n</li>\n<li><p>        this.mergeSize &#x3D; mergeSize;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public boolean isDeleteFlag() {  </p>\n</li>\n<li><p>        return deleteFlag;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setDeleteFlag(boolean deleteFlag) {  </p>\n</li>\n<li><p>        this.deleteFlag &#x3D; deleteFlag;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public String toString() {  </p>\n</li>\n<li><p>        return “mergeId&#x3D;” + mergeId + “, mergeStr&#x3D;” + mergeStr + “, mergeSize&#x3D;” + mergeSize + “, deleteFlag&#x3D;” + deleteFlag;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class OnMergeWindowlistener implements UpdateListener {  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents) {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null) {  </p>\n</li>\n<li><p>            System.out.println(“Trigger MergeWindow:”);  </p>\n</li>\n<li><p>            for (int i &#x3D; 0; i &lt; newEvents.length; i++) {  </p>\n</li>\n<li><p>                System.out.println(newEvents[i].getUnderlying());  </p>\n</li>\n<li><p>            }  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class SelectLogWindowlistener implements UpdateListener {  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents) {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null) {  </p>\n</li>\n<li><p>            for (int i &#x3D; 0; i &lt; newEvents.length; i++) {  </p>\n</li>\n<li><p>                System.out.println(newEvents[i].getUnderlying());  </p>\n</li>\n<li><p>            }  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class SelectMergeWindowlistener implements UpdateListener {  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents) {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null) {  </p>\n</li>\n<li><p>            for (int i &#x3D; 0; i &lt; newEvents.length; i++) {  </p>\n</li>\n<li><p>                System.out.println(newEvents[i].getUnderlying());  </p>\n</li>\n<li><p>            }  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class OnMergeWindowTest {  </p>\n</li>\n<li><p>    public static void main(String[] args) {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        String mergeEvent &#x3D; MergeEvent.class.getName();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “create window MergeWindow.win:keepall() select * from “ + mergeEvent;  </p>\n</li>\n<li><p>        String epl2 &#x3D; “create schema LogEvent as (id int, name string)”;  </p>\n</li>\n<li><p>        String epl3 &#x3D; “create window LogWindow.win:keepall() as LogEvent”;  </p>\n</li>\n<li><p>        String epl4 &#x3D; “on “ + mergeEvent + “(mergeSize &gt; 0) me merge MergeWindow mw where me.mergeId &#x3D; mw.mergeId “  </p>\n</li>\n<li><p>                + “when matched and me.deleteFlag &#x3D; true then delete “  </p>\n</li>\n<li><p>                + “when matched then update set mergeSize &#x3D; mergeSize + me.mergeSize where mw.mergeSize &gt; 3 “  </p>\n</li>\n<li><p>                + “when not matched then insert select * then insert into LogWindow(id, name) select me.mergeId, me.mergeStr”;  </p>\n</li>\n<li><p>        String epl5 &#x3D; “on LogEvent(id&#x3D;0) select lw.* from LogWindow as lw”;  </p>\n</li>\n<li><p>        String epl6 &#x3D; “on “ + mergeEvent + “(mergeSize &#x3D; 0) select mw.* from MergeWindow as mw”;  </p>\n</li>\n<li><p>        System.out.println(“Create Window: “ + epl1);  </p>\n</li>\n<li><p>        System.out.println(“Merge Trigger: “ + epl4);  </p>\n</li>\n<li><p>        System.out.println();  </p>\n</li>\n<li><p>        admin.createEPL(epl1);  </p>\n</li>\n<li><p>        admin.createEPL(epl2);  </p>\n</li>\n<li><p>        admin.createEPL(epl3);  </p>\n</li>\n<li><p>        EPStatement state1 &#x3D; admin.createEPL(epl4);  </p>\n</li>\n<li><p>        state1.addListener(new OnMergeWindowlistener());  </p>\n</li>\n<li><p>        EPStatement state2 &#x3D; admin.createEPL(epl5);  </p>\n</li>\n<li><p>        state2.addListener(new SelectLogWindowlistener());  </p>\n</li>\n<li><p>        EPStatement state3 &#x3D; admin.createEPL(epl6);  </p>\n</li>\n<li><p>        state3.addListener(new SelectMergeWindowlistener());  </p>\n</li>\n<li><p>        Map&lt;String, Object&gt; selectLog &#x3D; new HashMap&lt;String, Object&gt;();  </p>\n</li>\n<li><p>        selectLog.put(“id”, 0);  </p>\n</li>\n<li><p>        MergeEvent selectMerge &#x3D; new MergeEvent();  </p>\n</li>\n<li><p>        selectMerge.setMergeSize(0);  </p>\n</li>\n<li><p>        MergeEvent me1 &#x3D; new MergeEvent();  </p>\n</li>\n<li><p>        me1.setDeleteFlag(false);  </p>\n</li>\n<li><p>        me1.setMergeId(1);  </p>\n</li>\n<li><p>        me1.setMergeSize(2);  </p>\n</li>\n<li><p>        me1.setMergeStr(“me1”);  </p>\n</li>\n<li><p>        System.out.println(“Send MergeEvent 1: “ + me1);  </p>\n</li>\n<li><p>        runtime.sendEvent(me1);  </p>\n</li>\n<li><p>        MergeEvent me2 &#x3D; new MergeEvent();  </p>\n</li>\n<li><p>        me2.setDeleteFlag(false);  </p>\n</li>\n<li><p>        me2.setMergeId(2);  </p>\n</li>\n<li><p>        me2.setMergeSize(3);  </p>\n</li>\n<li><p>        me2.setMergeStr(“me2”);  </p>\n</li>\n<li><p>        System.out.println(“Send MergeEvent 2: “ + me2);  </p>\n</li>\n<li><p>        runtime.sendEvent(me2);  </p>\n</li>\n<li><p>        MergeEvent me3 &#x3D; new MergeEvent();  </p>\n</li>\n<li><p>        me3.setDeleteFlag(false);  </p>\n</li>\n<li><p>        me3.setMergeId(3);  </p>\n</li>\n<li><p>        me3.setMergeSize(4);  </p>\n</li>\n<li><p>        me3.setMergeStr(“me3”);  </p>\n</li>\n<li><p>        System.out.println(“Send MergeEvent 3: “ + me3);  </p>\n</li>\n<li><p>        runtime.sendEvent(me3);  </p>\n</li>\n<li><p>        System.out.println(“\\nSend MergeEvent to Select MergeWindow!”);  </p>\n</li>\n<li><p>        runtime.sendEvent(selectMerge);  </p>\n</li>\n<li><p>        System.out.println(“\\nSend LogEvent to Select LogWindow!”);  </p>\n</li>\n<li><p>        runtime.sendEvent(selectLog, “LogEvent”);  </p>\n</li>\n<li><p>        MergeEvent me4 &#x3D; new MergeEvent();  </p>\n</li>\n<li><p>        me4.setDeleteFlag(false);  </p>\n</li>\n<li><p>        me4.setMergeId(3);  </p>\n</li>\n<li><p>        me4.setMergeSize(5);  </p>\n</li>\n<li><p>        me4.setMergeStr(“me4”);  </p>\n</li>\n<li><p>        System.out.println(“\\nSend MergeEvent 4: “ + me4);  </p>\n</li>\n<li><p>        runtime.sendEvent(me4);  </p>\n</li>\n<li><p>        System.out.println(“\\nSend MergeEvent to Select MergeWindow!”);  </p>\n</li>\n<li><p>        runtime.sendEvent(selectMerge);  </p>\n</li>\n<li><p>        MergeEvent me5 &#x3D; new MergeEvent();  </p>\n</li>\n<li><p>        me5.setDeleteFlag(true);  </p>\n</li>\n<li><p>        me5.setMergeId(1);  </p>\n</li>\n<li><p>        me5.setMergeSize(6);  </p>\n</li>\n<li><p>        me5.setMergeStr(“me5”);  </p>\n</li>\n<li><p>        System.out.println(“\\nSend MergeEvent 5: “ + me5);  </p>\n</li>\n<li><p>        runtime.sendEvent(me5);  </p>\n</li>\n<li><p>        System.out.println(“\\nSend MergeEvent to Select MergeWindow!”);  </p>\n</li>\n<li><p>        runtime.sendEvent(selectMerge);  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li><p>Create Window: create window MergeWindow.win:keepall() select * from example.MergeEvent  </p>\n</li>\n<li><p>Merge Trigger: on example.MergeEvent(mergeSize &gt; 0) me merge MergeWindow mw where me.mergeId &#x3D; mw.mergeId when matched and me.deleteFlag &#x3D; true then delete when matched then update set mergeSize &#x3D; mergeSize + me.mergeSize where mw.mergeSize &gt; 3 when not matched then insert select * then insert into LogWindow(id, name) select me.mergeId, me.mergeStr  </p>\n</li>\n<li><p>Send MergeEvent 1: mergeId&#x3D;1, mergeStr&#x3D;me1, mergeSize&#x3D;2, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Trigger MergeWindow:  </p>\n</li>\n<li><p>mergeId&#x3D;1, mergeStr&#x3D;me1, mergeSize&#x3D;2, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Send MergeEvent 2: mergeId&#x3D;2, mergeStr&#x3D;me2, mergeSize&#x3D;3, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Trigger MergeWindow:  </p>\n</li>\n<li><p>mergeId&#x3D;2, mergeStr&#x3D;me2, mergeSize&#x3D;3, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Send MergeEvent 3: mergeId&#x3D;3, mergeStr&#x3D;me3, mergeSize&#x3D;4, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Trigger MergeWindow:  </p>\n</li>\n<li><p>mergeId&#x3D;3, mergeStr&#x3D;me3, mergeSize&#x3D;4, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Send MergeEvent to Select MergeWindow!  </p>\n</li>\n<li><p>mergeId&#x3D;1, mergeStr&#x3D;me1, mergeSize&#x3D;2, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>mergeId&#x3D;2, mergeStr&#x3D;me2, mergeSize&#x3D;3, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>mergeId&#x3D;3, mergeStr&#x3D;me3, mergeSize&#x3D;4, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Send LogEvent to Select LogWindow!  </p>\n</li>\n<li><p>{id&#x3D;1, name&#x3D;me1}  </p>\n</li>\n<li><p>{id&#x3D;2, name&#x3D;me2}  </p>\n</li>\n<li><p>{id&#x3D;3, name&#x3D;me3}  </p>\n</li>\n<li><p>Send MergeEvent 4: mergeId&#x3D;3, mergeStr&#x3D;me4, mergeSize&#x3D;5, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Trigger MergeWindow:  </p>\n</li>\n<li><p>mergeId&#x3D;3, mergeStr&#x3D;me3, mergeSize&#x3D;9, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Send MergeEvent to Select MergeWindow!  </p>\n</li>\n<li><p>mergeId&#x3D;1, mergeStr&#x3D;me1, mergeSize&#x3D;2, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>mergeId&#x3D;2, mergeStr&#x3D;me2, mergeSize&#x3D;3, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>mergeId&#x3D;3, mergeStr&#x3D;me3, mergeSize&#x3D;9, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>Send MergeEvent 5: mergeId&#x3D;1, mergeStr&#x3D;me5, mergeSize&#x3D;6, deleteFlag&#x3D;true  </p>\n</li>\n<li><p>Send MergeEvent to Select MergeWindow!  </p>\n</li>\n<li><p>mergeId&#x3D;2, mergeStr&#x3D;me2, mergeSize&#x3D;3, deleteFlag&#x3D;false  </p>\n</li>\n<li><p>mergeId&#x3D;3, mergeStr&#x3D;me3, mergeSize&#x3D;9, deleteFlag&#x3D;false</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>9.Selecting&#x2F;Updating&#x2F;Deleting From Named Windows Using Fire-And-Forget Queries</strong></p>\n<p>       上面对于named window的所有操作，都是要发送一个事件到引擎才可达到目的。那是否可以不发送事件直接执行select&#x2F;update&#x2F;delete语句达到目的呢？Esper确实为大家提供了一种简单的方式来操作named window。和之前说的有很大的不同，首先不需要发送任何事件到引擎即可select&#x2F;update&#x2F;delete，其次不需要监听器就可立即获得操作结果。4.9版本只支持这三种操作，不过现在的4.11已经增加了很多别的操作，详细内容请各位自己去看官方文档吧。由于本节内容较为简单，所以我直接给大家展示语法及一个完整的例子。</p>\n<ol>\n<li><p>&#x2F;&#x2F; select  </p>\n</li>\n<li><p>select *[, property_name[,…]] from window_name [where criteria_expression] [oder by] [having] [subquery]  </p>\n</li>\n<li><p>&#x2F;&#x2F; update 子查询，聚合函数等不能用于expression  </p>\n</li>\n<li><p>update window_name [as stream_name]  </p>\n</li>\n<li><p>set property_name &#x3D; expression [, property_name &#x3D; expression [,…]] [where criteria_expression]  </p>\n</li>\n<li><p>&#x2F;&#x2F; delete  </p>\n</li>\n<li><p>delete from window_name [as stream_name] [where criteria_expression]</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li><p>Send SelectEvent 1: name&#x3D;se1, size&#x3D;1  </p>\n</li>\n<li><p>Send SelectEvent 2: name&#x3D;se2, size&#x3D;2  </p>\n</li>\n<li><p>Select SelectWindow!  </p>\n</li>\n<li><p>name&#x3D;se1, size&#x3D;1  </p>\n</li>\n<li><p>name&#x3D;se2, size&#x3D;2  </p>\n</li>\n<li><p>Update SelectEvent(size &#x3D; 2) in SelectWindow!  </p>\n</li>\n<li><p>name&#x3D;update1, size&#x3D;2  </p>\n</li>\n<li><p>Select SelectWindow!  </p>\n</li>\n<li><p>name&#x3D;se1, size&#x3D;1  </p>\n</li>\n<li><p>name&#x3D;update1, size&#x3D;2  </p>\n</li>\n<li><p>Delete SelectEvent(size &lt; 2) in SelectWindow!  </p>\n</li>\n<li><p>name&#x3D;se1, size&#x3D;1  </p>\n</li>\n<li><p>Select SelectWindow!  </p>\n</li>\n<li><p>name&#x3D;update1, size&#x3D;2</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>10.Explicitly Indexing Named Windows</strong></p>\n<p>       因为named window中可以存放事件，所以对存有大量的事件的window进行操作时，效率肯定是一个很大的问题。因此Esper支持对named window建立索引，具体来说是对named window中存放的事件的属性建立索引。我没有实际测试过加过索引之后操作时间有没有缩短，所以如果有人测试过并的确有好效果，希望能在本篇评论里向我反馈下，谢谢。<br>语法如下：</p>\n<ol>\n<li>create [unique] index index_name on named_window_name (property [hash| btree] [, property] [hash|btree] [,…] )</li>\n</ol>\n<p>  </p>\n<p>       unique代表建立唯一索引，如果插入了重复的行，则会抛出异常并阻止重复行插入。如果不使用此关键字，则表示可以插入重复行。index_name为索引的名称，named_window_name是要建立索引的named window。<br>后面的括号中包含named window中的属性以及索引类型。索引类型分两种，hash索引不会排序，如果有&#x3D;操作，建议使用此类型索引。btree索引基于排序二叉树，适合&lt;, &gt;, &gt;&#x3D;, &lt;&#x3D;, between, in等操作。如果不显式声明hash或者btree，则默认为hash索引。举例如下：</p>\n<ol>\n<li><p>&#x2F;&#x2F; create a unique index on user id（hash） and profile id（hash）  </p>\n</li>\n<li><p>create unique index UserProfileIndex on UserProfileWindow(userId, profileId)  </p>\n</li>\n<li><p>&#x2F;&#x2F; create a non-unique index on symbol（hash） and buyPrice（btree）  </p>\n</li>\n<li><p>create index idx1 on TickEventWindow(symbol hash, buyPrice btree)</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>11.Dropping or Removing Named Windows</strong></p>\n<p>       注销named window的方式是直接调用EPStatement对象的destroy方法。虽然注销，但是named window的名字仍然被占用着，所以你只能重新建立和之前的named window一样结构的window，否则会抛出异常。例如：</p>\n<ol>\n<li><p>&#x2F;&#x2F; Create DropWindow  </p>\n</li>\n<li><p>create window DropWindow.win:keepall() as select * from DropEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; Destroy DropWindow  </p>\n</li>\n<li><p>EPStatement state &#x3D; admin.createEPL(“create window DropWindow.win:keepall() as select * from DropEvent”);  </p>\n</li>\n<li><p>state.destroy();  </p>\n</li>\n<li><p>&#x2F;&#x2F; Create DropEvent again(different with prior epl)  </p>\n</li>\n<li><p>create window DropWindow.win:keepall() as select name from DropEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; throw Exception</p>\n</li>\n</ol>\n","text":"Esper学习之十二：EPL语法（八） 今天的内容十分重要，在Esper的应用中是十分常用的功能之一。它是一种事件集合，我们可以对这个集合进行增删查改，所以在复...","permalink":"/post/BIGDATA/Esper学习之十二：EPL语法（八）","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"window","slug":"window","count":1,"path":"api/categories/window.json"},{"name":"BIGDATA","slug":"window/BIGDATA","count":1,"path":"api/categories/window/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"},{"name":"named","slug":"named","count":1,"path":"api/tags/named.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Esper%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8D%81%E4%BA%8C%EF%BC%9AEPL%E8%AF%AD%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89\"><span class=\"toc-text\">Esper学习之十二：EPL语法（八）</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Esper学习之十四：Pattern（一）","uid":"bdf0bc79680e5abcf1a951c9276dec8c","slug":"BIGDATA/Esper学习之十四：Pattern（一）","date":"2023-06-09T11:31:58.000Z","updated":"2025-09-30T03:26:04.344Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之十四：Pattern（一）.json","keywords":"XuGuangSheng","cover":"/covers/esperpattern.jpg","text":"Esper学习之十四：Pattern（一）1. Pattern Atoms and Pattern operatorsPattern是通过原子事件和操作符组合在...","permalink":"/post/BIGDATA/Esper学习之十四：Pattern（一）","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"ConsumeEvent","slug":"ConsumeEvent","count":1,"path":"api/categories/ConsumeEvent.json"},{"name":"BIGDATA","slug":"ConsumeEvent/BIGDATA","count":1,"path":"api/categories/ConsumeEvent/BIGDATA.json"}],"tags":[{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"},{"name":"age","slug":"age","count":1,"path":"api/tags/age.json"},{"name":"every","slug":"every","count":1,"path":"api/tags/every.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Esper学习之十一：EPL语法（七）","uid":"6131b419f4b67eaeeae93021cf6fda95","slug":"BIGDATA/Esper学习之十一：EPL语法（七）","date":"2023-06-09T09:35:27.000Z","updated":"2025-09-30T03:26:03.979Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之十一：EPL语法（七）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之十一：EPL语法（七） 上一篇说到了EPL如何访问关系型数据库这种数据源，实际上别的数据源，比如：webservice、分布式缓存、非关系型数据...","permalink":"/post/BIGDATA/Esper学习之十一：EPL语法（七）","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"schema","slug":"schema","count":1,"path":"api/categories/schema.json"},{"name":"BIGDATA","slug":"schema/BIGDATA","count":1,"path":"api/categories/schema/BIGDATA.json"}],"tags":[{"name":"class","slug":"class","count":2,"path":"api/tags/class.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"},{"name":"String","slug":"String","count":1,"path":"api/tags/String.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}