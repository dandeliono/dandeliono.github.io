{"title":"Esper学习之八：EPL语法（四）","uid":"0b518321d13efd904f78fbe39f8f7eba","slug":"BIGDATA/Esper学习之八：EPL语法（四）","date":"2023-06-08T18:08:42.000Z","updated":"2025-09-30T03:26:03.899Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之八：EPL语法（四）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","content":"<h1 id=\"Esper学习之八：EPL语法（四）\"><a href=\"#Esper学习之八：EPL语法（四）\" class=\"headerlink\" title=\"Esper学习之八：EPL语法（四）\"></a>Esper学习之八：EPL语法（四）</h1><p>关于EPL，已经写了三篇了，预估计了一下，除了今天这篇，后面还有5篇左右。大家可别嫌多，官方的文档对EPL的讲解有将近140页，我已经尽量将废话都干掉了，再配合我附上的例子，看我的10篇文章比那140页英文文档肯定舒服多了吧。也请各位原谅我一周一篇的速度，毕竟我还要学习，生活，工作，一个都不能少。</p>\n<p>        今天讲解的内容包括三块：Order by，Limit，Insert into。大家会SQL的应该很熟悉这三个东西，前两个比较简单，Insert into会有一些差别，篇幅也相对多些。</p>\n<p><strong>1.Order by</strong></p>\n<p>EPL的Order by和SQL的几乎一模一样，作用都是对输出结果进行排序，但是也有一些需要注意的地方。语法如下：</p>\n<ol>\n<li>order by expression [asc | desc] [, expression [asc | desc]] [, …]</li>\n</ol>\n<p>  </p>\n<p>expreession表示要排序的字段，asc表示升序排列（从小到大），desc表示降序排列（从大到小）。举个例子：</p>\n<ol>\n<li>&#x2F;&#x2F; 每进入5个事件输出一次，并且先按照name升序排列，再按照age降序排列。  </li>\n<li>select * from User output every 5 events order by name, age desc</li>\n</ol>\n<p>  </p>\n<p>使用方法很简单，除了和SQL相似的特点外，还有他自己需要注意的几点：</p>\n<p>a. 如果不特别说明是升序还是降序，默认情况下按照升序排列。</p>\n<p>b. 如果order by的子句中出现了聚合函数，那么该聚合函数必须出现在select的子句中。</p>\n<p>c. 出现在select中的expression或者在select中定义的expression，在order by中也有效。</p>\n<p>d. 如果order by所在的句子没有join或者没有group by，则排序结果幂等，否则为非幂等。</p>\n<p><strong>2. Limit</strong></p>\n<p>Limit在EPL中和在SQL中也基本一样，不过SQL中是用具体的数字来表示限制范围，而EPL可以是常量或者变量来表示限制范围。语法如下：</p>\n<ol>\n<li>limit row_count [offset offset_count]</li>\n</ol>\n<p>  </p>\n<p>row_count表示输出多少行，可以是一个整型常量，也可以是一个整型变量，以方便运行时修改。</p>\n<p>offset_count表示在当前结果集中跳过n行然后再输出，同样也可以是一个整型变量。如果不使用此参数，则表示跳过0行，即从第一行输出。举例如下：</p>\n<ol>\n<li>&#x2F;&#x2F; 输出结果集的第3行到第10行  </li>\n<li>select uri, count(<em>) from WebEvent group by uri output snapshot every 1 minute order by count(</em>) desc limit 8 offset 2</li>\n</ol>\n<p>  </p>\n<p>除了以上的语法，limit还有一种简化的写法，实际上是参照SQL的标准。</p>\n<ol>\n<li>limit offset_count[, row_count]</li>\n</ol>\n<p>  </p>\n<p>两个参数的含义和上面的一样，并且我们将上面的例子改写一下：</p>\n<ol>\n<li>&#x2F;&#x2F; 输出结果集的第3行到第10行  </li>\n<li>select uri, count(<em>) from WebEvent group by uri output snapshot every 1 minute order by count(</em>) desc limit 2, 8</li>\n</ol>\n<p>  </p>\n<p>如果这个两个参数是负数会怎么样呢？</p>\n<p>row_count为负数，则无限制输出，若为0，则不输出。当row_count是变量表示并且变量为null，则无限制输出。</p>\n<p>offset _count是不允许负数的，如果是变量表示，并且变量值为null或者负数，则EPL会把他假设为0。</p>\n<p><strong>3. Insert into</strong></p>\n<p><em>3.1 简单用法</em></p>\n<p>        EPL的Insert into和SQL的有比较大的区别。SQL是往一张表里插入数据，而EPL是把一个事件流的计算结果放入另一个事件流，然后可以对这个事件流进行别的计算。所以Insert into的一个好处就是可以将是事件流的计算结果不断级联，对于那种需要将上一个业务的结果数据放到下一个业务处理的场景再适合不过了。除此之外，Insert into还有合并多个计算结果的作用。到这里相信大家已经对他越来越好奇了，不急，咱们先来看看语法：</p>\n<ol>\n<li>insert [istream | irstream | rstream] into event_stream_name [ (property_name [, property_name] ) ]</li>\n</ol>\n<p>  </p>\n<p>event_stream_name定义了事件流的名称，在执行完insert的定义之后，我们可以使用select对这个事件流进行别的计算。</p>\n<p>istream | irstream | rstream表示该事件流允许另一个事件的输入&#x2F;输入和输出&#x2F;输出数据能够进入（解释好像很绕。。一会儿看例子就能明白了）</p>\n<p>property_name表示该事件流里包含的属性名称，多个属性名之间用逗号分割，并且用小括号括起来。</p>\n<p>上面的说明可能不是很好理解，咱们先看个例子：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 将新进入的Asus事件传递到Computer，且Asus的id，size和Computer的cid，csize对应  </p>\n</li>\n<li><p>insert into Computer(cid,csize) select id,size from Asus  </p>\n</li>\n<li><p>&#x2F;&#x2F; 第二种写法  </p>\n</li>\n<li><p>insert into Computer select id as cid, size as csize Asus</p>\n</li>\n</ol>\n<p>  </p>\n<p>        从例子中可以看到，insert into需要配合select进行使用，以表明前一个事件流有哪些计算结果将进入insert into定义的事件流。并且在select中的字段要和insert里的事件流的属性要对应（这里指的对应是数据类型对应，而且属性数量也必须一样）。如果说insert定义的事件流名称在之前已经定义过（insert into中定义的除外），重名是不允许的。</p>\n<p>        我个人推荐第二种写法，通过as设置的别名即为insert定义的事件流的属性，这样可以避免属性的个数不一致的错误。</p>\n<p>刚才说了istream | irstream | rstream的用法，可能有点表述不清楚，这里看一个完整的例子。</p>\n<p>执行结果：</p>\n<ol>\n<li><p>Send Asus: id: 1, size: 1  </p>\n</li>\n<li><p>Send Asus: id: 2, size: 1  </p>\n</li>\n<li><p>Send Asus: id: 3, size: 3  </p>\n</li>\n<li><p>Insert Asus: cid: 1  </p>\n</li>\n<li><p>Insert Asus: cid: 2  </p>\n</li>\n<li><p>Send Asus: id: 4, size: 4  </p>\n</li>\n<li><p>Send Asus: id: 5, size: 3  </p>\n</li>\n<li><p>Insert Asus: cid: 3  </p>\n</li>\n<li><p>Insert Asus: cid: 4  </p>\n</li>\n<li><p>Send Asus: id: 6, size: 4</p>\n</li>\n</ol>\n<p>  </p>\n<p>        这个例子中，insertEPL表示当Asus事件从length为1的view中移除时，把移除的事件放入Computer。insertSelectEPL是对Computer的事件流进行计算，这里只是在每进入两个事件时才输出这两个事件的cid。而rstream在这里的表现，从执行结果中可以看到，在进入id为1 2 3的事件后，insertSelectEPL的监听器被触发，因为id为1和2的事件是在发送了Asus的id为2和3的事件之后被移除了，之后就进入了Computer，并满足了length&#x3D;2，因此在监听器里看到有id为1和2的事件进入了Computer。</p>\n<p>        如果不显示指定rstream，则insert into只允许istream的事件流进入Computer。如果指定为irstream，那么进入的和移除的Asus都会进入到Computer。</p>\n<p>上面的例子都是指定了insert into里事件流会有什么属性，如果不指定会是什么结果呢？请看例句：</p>\n<ol>\n<li>insert into Computer select * from Asus</li>\n</ol>\n<p>  </p>\n<p>        很容易想到，这里实际上是把进入引擎的Asus事件都传递到Computer定义的事件流中，并且属性什么的完全和Asus一样，可以说是Asus的一个复制版本，只是名字不一样。也许有人觉得这么做没什么意思，直接计算Asus事件流不就可以了么，实际上在业务处理数据时，这种做法就可以屏蔽掉外部的数据来源，做到业务层上的隔离。</p>\n<p>        假设Asus中还包含其他的JavaBean，同样也可以将这个Bean的数据传递到另一个事件流中。例句如下：</p>\n<ol>\n<li>&#x2F;&#x2F; Lenovo中包含了thinkpad这个JavaBean  </li>\n<li>insert into Computer select thinkpad.* from Lenovo</li>\n</ol>\n<p>  </p>\n<p><em>3.2 Merge Event Stream</em></p>\n<p>        insert into除了接收一个流的事件，同时也支持多个流的合并。通俗一点来说，合并的流数据要一致才可以合并。而且在第一次定义insert的事件流以后，别的事件流想要被合并就必须和之前定义的属性数量和数据类型对应。举例如下：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 定义Computer并把Asus的数据输入  </p>\n</li>\n<li><p>insert into Computer(cid, csize) select aid,asize from Asus  </p>\n</li>\n<li><p>&#x2F;&#x2F; 根据之前的Computer定义将Lenovo对应的属性输入  </p>\n</li>\n<li><p>insert into Computer(cid, csize) select lid,lsize from Lenovo</p>\n</li>\n</ol>\n<p>  </p>\n<p>如果说select了多个事件流，但是你只想输入其中一个，应该像下面这样写：</p>\n<ol>\n<li>insert into Computer select l.* from Asus as a, Lenovo as l</li>\n</ol>\n<p>  </p>\n<p>除此之外，EPL还支持调用函数转换事件后再输入insert into：</p>\n<ol>\n<li>&#x2F;&#x2F; 将Lenovo事件转换后输入Computer  </li>\n<li>insert into Computer select Converter.convert(l) from Lenovo as l</li>\n</ol>\n<p>  </p>\n<p>注意，使用自定义函数一定要返回javabean，map，或者Object数组，且不能用as来为转换后的结果设置别名。</p>\n<p><em>3.3 Decorated Events</em></p>\n<p>之前所见到的不是将事件流整体输入insert，就是将事件流的部分属性输入insert。实际上可以将事件流整体和事件流属性组成的复杂表达式一起放入insert。示例如下：</p>\n<ol>\n<li>insert into Computer select <em>, size</em>price as sp from Asus  </li>\n<li>&#x2F;&#x2F; 第一个*表示Asus，size*price的*表示乘法，两者互不影响</li>\n</ol>\n<p>  </p>\n<p>如果说别的事件流想进入此insert，那么事件流属性一定要和第一个*表示的所有属性相同。</p>\n<p><em>3.4 Event Objects Instantiated by insert into</em></p>\n<p>        前面的所有例子中，对于insert into的事件结构都是在insert子句中配合select子句进行定义的。如果我们想用已经定义好的事件结构是否可以呢？答案是肯定的。但是如果事件是javabean，并且事先没有注册到引擎，则需要insert子句中写上类的全名。例如：</p>\n<ol>\n<li>insert into test.computer.Computer …</li>\n</ol>\n<p>  </p>\n<p>当然，如果在使用之前有注册过，那么使用注册时的名称也是可以的。</p>\n<p>        因为事件结构是早就定义好的，所以在写select的时候就必须符合insert事件中的属性了，如果属性名称不一样需要使用as加上别名，一样的可以不用设置别名，且数据类型也要一一对应。例如：</p>\n<ol>\n<li>&#x2F;&#x2F; Computer中包含cid和csize属性  </li>\n<li>insert into test.computer.Computer select aid as cid, asize as csize from Dell</li>\n</ol>\n<p>  </p>\n<p>但是这种用法在Computer存在包含了参数的构造方法时就显得没那么必须了。先看一个完整例子，你也许就会明白了。</p>\n<p>执行结果：</p>\n<ol>\n<li>AutoSize: 1, AutoName: car1  </li>\n<li>BenzSize: 1, BenzName: car1  </li>\n<li>AutoSize: 2, AutoName: car2  </li>\n<li>BenzSize: 2, BenzName: car2</li>\n</ol>\n<p>  </p>\n<p>这里的执行结果很容易理解，关键是carToAutoEpl和carToBenzEpl两个句子。</p>\n<p>        对于Auto的JavaBean，我们可以发现它包含一个有参数的构造函数且没有属性对应的set方法，在carToAutoEpl中，select的内容并没有和属性名称对应起来。这种写法确实是正确的，正因为Auto中定了含参的构造函数，才使得select可以写的更随意。但是一定要记住，构造函数里的参数顺序一定要和select中的属性的数据类型对应起来，如果这里把name和size互换位置，必定报错！</p>\n<p>        对于Benz的JavaBean，可以看到每个属性都有对应的set方法，而没有含参的构造函数，所以select中属性的名称需要as来设置别名。当然，像benzEpl2那种写法，同样可以避免select中设置别名。</p>\n<p>        一句话总结，如果JavaBean中有含参的构造函数，EPL中不需要显示写出属性名称。如果没有构造函数，那么必须包含set方法，且select中要写出具体的属性。这几种写法各有各的好处，大家使用时可针对具体的情况选择性使用。</p>\n","text":"Esper学习之八：EPL语法（四）关于EPL，已经写了三篇了，预估计了一下，除了今天这篇，后面还有5篇左右。大家可别嫌多，官方的文档对EPL的讲解有将近140...","permalink":"/post/BIGDATA/Esper学习之八：EPL语法（四）","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"insert","slug":"insert","count":1,"path":"api/categories/insert.json"},{"name":"BIGDATA","slug":"insert/BIGDATA","count":1,"path":"api/categories/insert/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"Asus","slug":"Asus","count":1,"path":"api/tags/Asus.json"},{"name":"into","slug":"into","count":1,"path":"api/tags/into.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Esper%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%AB%EF%BC%9AEPL%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89\"><span class=\"toc-text\">Esper学习之八：EPL语法（四）</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Esper学习之九：EPL语法（五）","uid":"c610892d4b9e5d360c3a54bc62d56b3a","slug":"BIGDATA/Esper学习之九：EPL语法（五）","date":"2023-06-09T09:25:57.000Z","updated":"2025-09-30T03:26:03.760Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之九：EPL语法（五）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之九：EPL语法（五）本篇的内容主要包括了Subquery（也就是子查询）和Join，内容不少，但是不难，基本上和sql差不太多。 1.Subqu...","permalink":"/post/BIGDATA/Esper学习之九：EPL语法（五）","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"price","slug":"price","count":2,"path":"api/categories/price.json"},{"name":"BIGDATA","slug":"price/BIGDATA","count":2,"path":"api/categories/price/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"join","slug":"join","count":1,"path":"api/tags/join.json"},{"name":"from","slug":"from","count":2,"path":"api/tags/from.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Esper学习之七：EPL语法（三）","uid":"7e07be7bd570848d0be5a40e5365e5e4","slug":"BIGDATA/Esper学习之七：EPL语法（三）","date":"2023-06-08T17:52:30.000Z","updated":"2025-09-30T03:26:03.424Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之七：EPL语法（三）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之七：EPL语法（三）1.Aggregation 和SQL一样，EPL也有Aggregation，即聚合函数。语法如下： aggregate_fu...","permalink":"/post/BIGDATA/Esper学习之七：EPL语法（三）","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"price","slug":"price","count":2,"path":"api/categories/price.json"},{"name":"BIGDATA","slug":"price/BIGDATA","count":2,"path":"api/categories/price/BIGDATA.json"}],"tags":[{"name":"Apple","slug":"Apple","count":2,"path":"api/tags/Apple.json"},{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"color","slug":"color","count":1,"path":"api/tags/color.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}