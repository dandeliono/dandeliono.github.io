{"title":"Esper学习之十一：EPL语法（七）","uid":"6131b419f4b67eaeeae93021cf6fda95","slug":"BIGDATA/Esper学习之十一：EPL语法（七）","date":"2023-06-09T09:35:27.000Z","updated":"2025-09-30T03:26:03.979Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之十一：EPL语法（七）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","content":"<h1 id=\"Esper学习之十一：EPL语法（七）\"><a href=\"#Esper学习之十一：EPL语法（七）\" class=\"headerlink\" title=\"Esper学习之十一：EPL语法（七）\"></a>Esper学习之十一：EPL语法（七）</h1><p> 上一篇说到了EPL如何访问关系型数据库这种数据源，实际上别的数据源，比如：webservice、分布式缓存、非关系型数据库等等，Esper提供了统一的数据访问接口。然后今天会讲解如何创建另外一种事件类型——<a href=\"http://blog.csdn.net/luonanqin/article/details/19576633#t1\">Schema</a>。</p>\n<p><strong>1.Joining Method Invocation Results</strong><br>和执行sql的语法类似，调用方法的一种触发方式也是通过join别的事件的属性来达到效果，且调用方法的句子为from子句。语法如下：</p>\n<ol>\n<li>method:class_name.method_name(parameter_expressions)</li>\n</ol>\n<p>  </p>\n<p>method是固定关键字，class_name为类全名，方法名为返回外部数据的方法名，parameter_expressions为方法的参数列表，对应join的事件属性，多个属性之间用逗号分隔，参数整体用圆括号括起来。例如：</p>\n<ol>\n<li>select * from AssetMoveEvent, method:MyLookupLib.lookupAsset(assetId) &#x2F;&#x2F; assetId为AssetMoveEvent的属性之一</li>\n</ol>\n<p>  </p>\n<p>除了简单join，还可以为join加上where条件过滤一些返回结果。例如：</p>\n<ol>\n<li>select assetId, assetDesc from AssetMoveEvent as asset,  </li>\n<li>    method:MyLookupLib.getAssetDescriptions() as desc    &#x2F;&#x2F;调用的方法无参  </li>\n<li>        where asset.assetid &#x3D; desc.assetid</li>\n</ol>\n<p>  </p>\n<p>Esper不仅能缓存执行sql的查询结果，也能缓存执行方法的查询结果，并且缓存策略也是两种：LRU和Expire Time。具体可以参考上一篇缓存配置章节。若存在返回结果，且缓存生效后，Esper会自动为返回结果简历索引，加快查询速度。配置范例如下：</p>\n<ol>\n<li><p>&#x2F;&#x2F; LRU Cache  </p>\n</li>\n<li><p><method-reference class-name=\"MyFromClauseWebServiceLib\">  </p>\n</li>\n<li><p>    <lru-cache size=\"1000\"/>  </p>\n</li>\n<li><p></method-reference>  </p>\n</li>\n<li><p>&#x2F;&#x2F; Expire Time Cache  </p>\n</li>\n<li><p><method-reference class-name=\"com.mycompany.MyFromClauseLookupLib\">  </p>\n</li>\n<li><p>    <expiry-time-cache max-age-seconds=\"10\" purge-interval-seconds=\"10\" ref-type=\"weak\"/>  </p>\n</li>\n<li></method-reference></li>\n</ol>\n<p>  </p>\n<p>class-name表示方法所在的类，可以是类全名，可以只有类名，前提是包已经import。其他参数的解释请参见上一篇缓存配置章节</p>\n<p><strong>2.Polling Method Invocation Results via Iterator</strong><br>除了Join别的事件来触发查询方法，进而触发Listener，Esper还支持通过API直接执行方法。例如：</p>\n<ol>\n<li>select * from method:MyLookupLib.getAssetDescriptions(category_var)   &#x2F;&#x2F; category_var为注册到引擎的变量。</li>\n</ol>\n<p>  </p>\n<p><strong>3.Method Definition</strong><br>为了能够以一种统一的结构访问外部数据（RDBMS除外），Esper提供了调用静态方法的形式访问外部数据。具体解释如下：<br>**a.**返回数据的方法必须是公共静态方法。方法参数可以有多个也可以没有。<br>**b.**如果返回一条数据或无返回数据，则方法的返回类型可以是Java类或者Map类型数据。如果返回多条数据（包括一条），则方法返回类型必须是Java类的数组或者Map数组。<br>**c.**如果方法的返回类型是Java类或者Java类数组，则Java的类定义必须包含针对属性的get方法。<br>**d.**如果方法的返回类型是Map或者Map数组，则Map的key-value定义固定为&lt;String, Object&gt;。<br>**e.**如果返回的数据是Map或者Map数组，除了定义返回数据的方法外，还要定义返回元数据的方法（这个元数据针对返回的数据）。方法是公共静态方法，且必须是无参数方法。方法返回类型为Map&lt;String, Class&gt;，String表示返回的数据的名称，Class表示返回的数据的类型。返回元数据的方法名称&#x3D;返回数据的方法名称+Metadata。</p>\n<p>下面举一个完整的例子总结前面说的三点：</p>\n<ol>\n<li><p>package example;  </p>\n</li>\n<li><p>class JavaObject {  </p>\n</li>\n<li><p>    private String name;  </p>\n</li>\n<li><p>    private int size;  </p>\n</li>\n<li><p>    public String getName() {  </p>\n</li>\n<li><p>        return name;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setName(String name) {  </p>\n</li>\n<li><p>        this.name &#x3D; name;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public int getSize() {  </p>\n</li>\n<li><p>        return size;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setSize(int size) {  </p>\n</li>\n<li><p>        this.size &#x3D; size;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public String toString() {  </p>\n</li>\n<li><p>        return “JavaObject{“ + “name&#x3D;’” + name + ‘&#39;‘ + “, size&#x3D;” + size + ‘}’;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class InvocationMethodJava {  </p>\n</li>\n<li><p>    public static JavaObject[] getJavaObject(int times) {  </p>\n</li>\n<li><p>        JavaObject[] javaObjects &#x3D; new JavaObject[2];  </p>\n</li>\n<li><p>        JavaObject javaObject1 &#x3D; new JavaObject();  </p>\n</li>\n<li><p>        javaObject1.setName(“javaObject1”);  </p>\n</li>\n<li><p>        javaObject1.setSize(1 * times);  </p>\n</li>\n<li><p>        JavaObject javaObject2 &#x3D; new JavaObject();  </p>\n</li>\n<li><p>        javaObject2.setName(“javaObject2”);  </p>\n</li>\n<li><p>        javaObject2.setSize(2 * times);  </p>\n</li>\n<li><p>        javaObjects[0] &#x3D; javaObject1;  </p>\n</li>\n<li><p>        javaObjects[1] &#x3D; javaObject2;  </p>\n</li>\n<li><p>        return javaObjects;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>package example;  </p>\n</li>\n<li><p>import java.util.HashMap;  </p>\n</li>\n<li><p>import java.util.Map;  </p>\n</li>\n<li><p>public class InvocationMethodMap {  </p>\n</li>\n<li><p>    public static Map&lt;String, Object&gt; getMapObject() {  </p>\n</li>\n<li><p>        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();  </p>\n</li>\n<li><p>        map.put(“name”, “mapObject1”);  </p>\n</li>\n<li><p>        map.put(“size”, 1);  </p>\n</li>\n<li><p>        return map;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public static Map&lt;String, Class&gt; getMapObjectMetadata() {  </p>\n</li>\n<li><p>        Map&lt;String, Class&gt; map &#x3D; new HashMap&lt;String, Class&gt;();  </p>\n</li>\n<li><p>        map.put(“name”, String.class);  </p>\n</li>\n<li><p>        map.put(“size”, int.class);  </p>\n</li>\n<li><p>        return map;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>package example;  </p>\n</li>\n<li><p>import java.util.Iterator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import com.espertech.esper.client.UpdateListener;  </p>\n</li>\n<li><p>class Times {  </p>\n</li>\n<li><p>    private int times;  </p>\n</li>\n<li><p>    public int getTimes() {  </p>\n</li>\n<li><p>        return times;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public void setTimes(int times) {  </p>\n</li>\n<li><p>        this.times &#x3D; times;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>class InvocationMethodListener implements UpdateListener {  </p>\n</li>\n<li><p>    public void update(EventBean[] newEvents, EventBean[] oldEvents) {  </p>\n</li>\n<li><p>        if (newEvents !&#x3D; null) {  </p>\n</li>\n<li><p>            System.out.println(newEvents[0].getUnderlying());  </p>\n</li>\n<li><p>            System.out.println(newEvents[1].getUnderlying());  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>public class InvocationMethodTest {  </p>\n</li>\n<li><p>    public static void main(String arg[]) {  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider();  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        String timesName &#x3D; Times.class.getName();  </p>\n</li>\n<li><p>        String ijName &#x3D; InvocationMethodJava.class.getName();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “select ij.* from “ + timesName + “ as t, method:” + ijName + “.getJavaObject(times) as ij”;  </p>\n</li>\n<li><p>        System.out.println(epl1+”\\n”);  </p>\n</li>\n<li><p>        EPStatement state1 &#x3D; admin.createEPL(epl1);  </p>\n</li>\n<li><p>        state1.addListener(new InvocationMethodListener());  </p>\n</li>\n<li><p>        Times times &#x3D; new Times();  </p>\n</li>\n<li><p>        times.setTimes(2);  </p>\n</li>\n<li><p>        runtime.sendEvent(times);  </p>\n</li>\n<li><p>        System.out.println(“”);  </p>\n</li>\n<li><p>        String imName &#x3D; InvocationMethodMap.class.getName();  </p>\n</li>\n<li><p>        String epl2 &#x3D; “select * from method:” + imName + “.getMapObject()”;  </p>\n</li>\n<li><p>        System.out.println(epl2+”\\n”);  </p>\n</li>\n<li><p>        EPStatement state2 &#x3D; admin.createEPL(epl2);  </p>\n</li>\n<li><p>        Iterator<EventBean> iter &#x3D; state2.iterator();  </p>\n</li>\n<li><p>        while (iter.hasNext()) {  </p>\n</li>\n<li><p>            EventBean event &#x3D; iter.next();  </p>\n</li>\n<li><p>            System.out.println(event.getUnderlying());  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>4.Declare an Event Type by Providing Names and Types</strong><br>       我曾经在<a href=\"http://blog.csdn.net/luonanqin/article/details/10046499\">《Esper学习之二：事件类型》</a>里说过，事件类型的定义可以是POJO，数组，Map，或者XML。实际上还有另一种定义事件类型的方法，那就是schema。这个schema可不是数据库中的schema，而是用EPL定义的事件类型，所以说此类事件类型是针对Esper设计的，并不能拿出来通用。</p>\n<p>我们先从语法开始说起。</p>\n<ol>\n<li>create [map | objectarray] schema schema_name [as]  </li>\n<li> (property_name property_type [,property_name property_type [,…])  </li>\n<li> [inherits inherited_event_type[, inherited_event_type] [,…]] [starttimestamp timestamp_property_name]  </li>\n<li> [endtimestamp timestamp_property_name]  </li>\n<li> [copyfrom copy_type_name [, copy_type_name] [,…]]</li>\n</ol>\n<p>  </p>\n<p>解释如下：</p>\n<p>**a.**map objectarray分别表示当前定义的schema是map结构还是数组结构。<br>**b.**schema_name表示schema的名字，全局唯一。as为可选内容。<br>**c.**property_name表示schema所包含的属性名称，property_type为属性的类型，多个属性用逗号分隔，所有属性用圆括号括起来可以使用的类型有：int、String等已经内置的Java类型；已经通过Configuration接口注册的事件类型，比如Map，数组，schema等；可以使用POJO类，如果没有import就要写全名，否则写类名即可。<br>**d.**inherits表示继承别的事件类型，后面跟着的是要继承的事件类型。如果使用了继承，则当前定义的schema包含了继承的事件类型的所有属性。并且可以继承多个，用逗号分隔。<br>**e.**starttimestamp和endtimestamp是两个特殊的关键字。单独使用starttimestamp时，表示为schema记一个时间戳。后面跟着已经声明的属性并且能够返回一个data-time值。如果联合endtimestamp使用，则表示这个schema只能在某段事件内使用。后面跟着的同样也是已经声明的属性并且能够返回一个data-time值。注意endtimestamp不能单独使用。<br>**f.**copyfrom表示复制别的事件的所有属性到当前定义的schema中，并且可以copy多个事件，用逗号分隔。</p>\n<p>下面用几个例子来一一展示如何使用上面的语法：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 声明SecurityEvent  </p>\n</li>\n<li><p>create schema SecurityEvent as (ipAddress string, userId String, numAttempts int)  </p>\n</li>\n<li><p>&#x2F;&#x2F; 声明AuthorizationEvent，并且包含com.mycompany.HostNameInfo类型的hostinfo属性  </p>\n</li>\n<li><p>create schema AuthorizationEvent(group String, roles String[], hostinfo com.mycompany.HostNameInfo)  </p>\n</li>\n<li><p>&#x2F;&#x2F; 声明CompositeEvent，并且包含了SecurityEvent数组作为innerEvents属性的类型  </p>\n</li>\n<li><p>create schema CompositeEvent(group String, innerEvents SecurityEvent[])  </p>\n</li>\n<li><p>&#x2F;&#x2F; 声明WebPageVisitEvent，自己定义了userId属性，并且继承了PageHitEvent的所有属性  </p>\n</li>\n<li><p>create schema WebPageVisitEvent(userId String) inherits PageHitEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; 声明RoboticArmMovement，并且开始于startts，结束于endts  </p>\n</li>\n<li><p>create schema RoboticArmMovement (robotId string, startts long, endts long) starttimestamp startts endtimestamp endts  </p>\n</li>\n<li><p>&#x2F;&#x2F; 声明ExtendedSecurityEvent，并且复制SecurityEvent事件的所有属性到ExtendedSecurityEvent  </p>\n</li>\n<li><p>create schema ExtendedSecurityEvent (userName string) copyfrom SecurityEvent  </p>\n</li>\n<li><p>&#x2F;&#x2F; 声明WebSecurityEvent，并且复制SecurityEvent和WebPageVisitEvent事件的所有属性到WebSecurityEvent  </p>\n</li>\n<li><p>create schema WebSecurityEvent (userName string) copyfrom SecurityEvent, WebPageVisitEvent</p>\n</li>\n</ol>\n<p>  </p>\n<p>这里要额外说一下，继承不仅仅继承了事件的属性，如果被继承的事件定义了starttimestamp或者endtimestamp，同样也会被继承下来。但是copyfrom是不会吧starttimestamp和endtimestamp复制的。这点一定要注意。</p>\n<p>对于map和objectarray这两个关键字，可以用注解达到同样的效果。例如：</p>\n<ol>\n<li><p>&#x2F;&#x2F; 声明数组类型的schema  </p>\n</li>\n<li><p>create objectarray schema SchemaTest1 as (prop1 string);  </p>\n</li>\n<li><p>… equals …  </p>\n</li>\n<li><p>@EventRepresentation(array&#x3D;true)create schema SchemaTest1 as (prop1 string);  </p>\n</li>\n<li><p>&#x2F;&#x2F; 声明Map类型的schema  </p>\n</li>\n<li><p>create map schema SchemaTest2 as (prop1 string);  </p>\n</li>\n<li><p>… equals …  </p>\n</li>\n<li><p>@EventRepresentation(array&#x3D;false)create schema SchemaTest2 as (prop1 string);</p>\n</li>\n</ol>\n<p>  </p>\n<p><strong>5.Declare Variant Stream</strong><br>Variant Stream简单来说就是包含了各种不同的事件类型的事件类型。所以语法也很明了：</p>\n<ol>\n<li>create variant schema schema_name [as] eventtype_name|* [, eventtype_name|*] [,…]</li>\n</ol>\n<p>  </p>\n<p>variant为关键字，表明这是Variant Stream，eventtype_name为事件的定义名，多个事件定义用逗号分隔开。*表示接收任何的事件类型，不过一般来说没有需求会到这种程度。举例如下：</p>\n<ol>\n<li>&#x2F;&#x2F; 声明SecurityVariant，包含了LoginEvent和LogoutEvent  </li>\n<li>create variant schema SecurityVariant as LoginEvent, LogoutEvent  </li>\n<li>&#x2F;&#x2F; 声明AnyEvent，包含任何类型的事件  </li>\n<li>create variant schema AnyEvent as *</li>\n</ol>\n<p>  </p>\n<p>以上就是调用外部方法以及schema的创建讲解，尤其是schema的创建，可能大家会用的更多一些，最好能记住。</p>\n","text":"Esper学习之十一：EPL语法（七） 上一篇说到了EPL如何访问关系型数据库这种数据源，实际上别的数据源，比如：webservice、分布式缓存、非关系型数据...","permalink":"/post/BIGDATA/Esper学习之十一：EPL语法（七）","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"schema","slug":"schema","count":1,"path":"api/categories/schema.json"},{"name":"BIGDATA","slug":"schema/BIGDATA","count":1,"path":"api/categories/schema/BIGDATA.json"}],"tags":[{"name":"class","slug":"class","count":2,"path":"api/tags/class.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"},{"name":"String","slug":"String","count":1,"path":"api/tags/String.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Esper%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8D%81%E4%B8%80%EF%BC%9AEPL%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89\"><span class=\"toc-text\">Esper学习之十一：EPL语法（七）</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Esper学习之十二：EPL语法（八）","uid":"247a554806e84b69903a33066dd8bcf1","slug":"BIGDATA/Esper学习之十二：EPL语法（八）","date":"2023-06-09T10:49:00.000Z","updated":"2025-09-30T03:26:04.088Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之十二：EPL语法（八）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之十二：EPL语法（八） 今天的内容十分重要，在Esper的应用中是十分常用的功能之一。它是一种事件集合，我们可以对这个集合进行增删查改，所以在复...","permalink":"/post/BIGDATA/Esper学习之十二：EPL语法（八）","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"window","slug":"window","count":1,"path":"api/categories/window.json"},{"name":"BIGDATA","slug":"window/BIGDATA","count":1,"path":"api/categories/window/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"},{"name":"named","slug":"named","count":1,"path":"api/tags/named.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Esper学习之十：EPL语法（六）","uid":"404c6135f2e86a9010b5598b38ae4379","slug":"BIGDATA/Esper学习之十：EPL语法（六）","date":"2023-06-09T09:30:55.000Z","updated":"2025-09-30T03:26:04.389Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之十：EPL语法（六）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之十：EPL语法（六） 在esper的文档中，epl访问数据库的配置放在了比较靠后的位置，不过为了方便各位学习，这里会先说明和数据库交互的相关配置...","permalink":"/post/BIGDATA/Esper学习之十：EPL语法（六）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"name","slug":"name","count":1,"path":"api/categories/name.json"},{"name":"BIGDATA","slug":"name/BIGDATA","count":1,"path":"api/categories/name/BIGDATA.json"}],"tags":[{"name":"esper","slug":"esper","count":2,"path":"api/tags/esper.json"},{"name":"sql","slug":"sql","count":1,"path":"api/tags/sql.json"},{"name":"import","slug":"import","count":1,"path":"api/tags/import.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}