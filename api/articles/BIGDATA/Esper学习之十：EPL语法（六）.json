{"title":"Esper学习之十：EPL语法（六）","uid":"404c6135f2e86a9010b5598b38ae4379","slug":"BIGDATA/Esper学习之十：EPL语法（六）","date":"2023-06-09T09:30:55.000Z","updated":"2025-09-30T03:26:04.389Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之十：EPL语法（六）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","content":"<h1 id=\"Esper学习之十：EPL语法（六）\"><a href=\"#Esper学习之十：EPL语法（六）\" class=\"headerlink\" title=\"Esper学习之十：EPL语法（六）\"></a>Esper学习之十：EPL语法（六）</h1><p>  在esper的文档中，epl访问数据库的配置放在了比较靠后的位置，不过为了方便各位学习，这里会先说明和数据库交互的相关配置，然后再说epl怎么访问数据库。</p>\n<p>配置文件在官方esper包的etc文件夹下，大家可以参考着学习。</p>\n<p><strong>1.连接数据库</strong></p>\n<p><em>a.JNDI获取连接</em></p>\n<p>配置如下：</p>\n<ol>\n<li><database-reference name=\"mydb1\">  </li>\n<li>  <datasource-connection context-lookup-name=\"java:comp/env/jdbc/mydb\">  </li>\n<li>    <env-property name=\"java.naming.factory.initial\" value =\"com.myclass.CtxFactory\"/>  </li>\n<li>    &lt;env-property name&#x3D;”java.naming.provider.url” value &#x3D;”iiop:&#x2F;&#x2F;localhost:1050”&#x2F; &gt;  </li>\n<li>  </datasource-connection>  </li>\n<li></database-reference></li>\n</ol>\n<p>  </p>\n<p>database-reference的name是要连接的数据库名字，其余的配置可参考JNDI的文档</p>\n<p>使用方法：</p>\n<ol>\n<li>if (envProperties.size() &gt; 0) {  </li>\n<li>  initialContext &#x3D; new InitialContext(envProperties);  </li>\n<li>} else {  </li>\n<li>  initialContext &#x3D; new InitialContext();  </li>\n<li>}  </li>\n<li>DataSource dataSource &#x3D; (DataSource) initialContext.lookup(lookupName);  </li>\n<li>Connection connection &#x3D; dataSource.getConnection();</li>\n</ol>\n<p>  </p>\n<p>更多内容可参考JNDI的文档</p>\n<p><em>b.从连接池获取连接</em></p>\n<p>配置如下：（以dbcp为例）</p>\n<ol>\n<li><p><database-reference name=\"mydb3\">  </p>\n</li>\n<li><p>  <datasourcefactory-connection class-name=\"org.apache.commons.dbcp.BasicDataSourceFactory\">  </p>\n</li>\n<li><p>    <env-property name=\"username\" value =\"myusername\"/>  </p>\n</li>\n<li><p>    <env-property name=\"password\" value =\"mypassword\"/>  </p>\n</li>\n<li><p>    <env-property name=\"driverClassName\" value =\"com.mysql.jdbc.Driver\"/>  </p>\n</li>\n<li><p>    <env-property name=\"url\" value =\"jdbc:mysql://localhost/test\"/>  </p>\n</li>\n<li><p>    <env-property name=\"initialSize\" value =\"2\"/>  </p>\n</li>\n<li><p>    <env-property name=\"validationQuery\" value =\"select 1 from dual\"/>  </p>\n</li>\n<li><p>  </datasourcefactory-connection>  </p>\n</li>\n<li><p><connection-lifecycle value=\"pooled\"/></p>\n</li>\n</ol>\n<p>  </p>\n</database-reference>\n\n<p>相同的配置可以使用esper的api达到同样的效果。代码如下：</p>\n<ol>\n<li><p>Properties props &#x3D; new Properties();  </p>\n</li>\n<li><p>props.put(“username”, “myusername”);  </p>\n</li>\n<li><p>props.put(“password”, “mypassword”);  </p>\n</li>\n<li><p>props.put(“driverClassName”, “com.mysql.jdbc.Driver”);  </p>\n</li>\n<li><p>props.put(“url”, “jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;test”);  </p>\n</li>\n<li><p>props.put(“initialSize”, 2);  </p>\n</li>\n<li><p>props.put(“validationQuery”, “select 1 from dual”);  </p>\n</li>\n<li><p>ConfigurationDBRef configDB &#x3D; new ConfigurationDBRef();  </p>\n</li>\n<li><p>configDB.setDataSourceFactory(props, BasicDataSourceFactory.class.getName());  </p>\n</li>\n<li><p>configDB.setConnectionLifecycleEnum(ConfigurationDBRef.ConnectionLifecycleEnum.POOLED);  </p>\n</li>\n<li><p>Configuration configuration &#x3D; new Configuration();  </p>\n</li>\n<li><p>configuration.addDatabaseReference(“mydb3”, configDB);</p>\n</li>\n</ol>\n<p>  </p>\n<p>同样，也可以自己实现数据源。示例如下：</p>\n<ol>\n<li>configDB.setDataSourceFactory(props, MyOwnDataSourceFactory.class.getName());  </li>\n<li>…  </li>\n<li>class MyOwnDataSourceFactory {  </li>\n<li>  public static DataSource createDataSource(Properties properties) {  </li>\n<li>    return new MyDataSourceImpl(properties);  </li>\n<li>  }   </li>\n<li>}</li>\n</ol>\n<p>  </p>\n<p><em>c.JDBC获取连接</em></p>\n<p>前提是要将对应的jdbc驱动假如classpath</p>\n<ol>\n<li><database-reference name=\"mydb2\">  </li>\n<li>  <drivermanager-connection class-name=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/mydb2\" user=\"myuser\" password=\"mypassword\">  </li>\n<li>    <connection-arg name=\"user\" value =\"myuser\"/>  </li>\n<li>    <connection-arg name=\"password\" value =\"mypassword\"/>  </li>\n<li>    <connection-arg name=\"somearg\" value =\"someargvalue\"/>  </li>\n<li>  </drivermanager-connection>  </li>\n<li></database-reference></li>\n</ol>\n<p>  </p>\n<p>注意：drivermanager-connection中的user和password属性必须填写，即使增加了connection-arg参数也不行。所以实际上connection-arg的user和password是不需要写的。这点我觉得esper做的不够人性化。</p>\n<p><em>d.其他关于数据库连接的配置</em></p>\n<p>下面是一些和数据库交互的配置，更多配置可参考Javadoc</p>\n<ol>\n<li><database-reference name=\"mydb2\">  </li>\n<li>… configure data source or driver manager settings…  </li>\n<li>  <connection-settings auto-commit=\"true\" catalog=\"mycatalog\" read-only=\"true\" transaction-isolation=\"1\" />  </li>\n<li></database-reference></li>\n</ol>\n<p>  </p>\n<p>下面是关于连接的生命周期的配置</p>\n<ol>\n<li><database-reference name=\"mydb2\">  </li>\n<li>… configure data source or driver manager settings…  </li>\n<li>    <connection-lifecycle value=\"pooled\"/></li>\n<li></database-reference></li>\n</ol>\n<p>  </p>\n<p>如果参数值为pooled，当配置了连接池，则会将每次获取的连接还给连接池。若没配置连接池，则每次获取的连接用完后就关闭。</p>\n<p>如果参数值为retain，则会将连接缓存到esper引擎中，这个epl用完后，另一个epl可以接着用</p>\n<p><strong>2.查询结果缓存策略</strong><br>EPL和数据库交互时会产生查询结果，所以引擎若能缓存查询结果将大大提高执行效率，因此esper提供了两种缓存模式。</p>\n<p><em>a.LRU Cache</em><br>LRU即least-recently-used，中文释义为“最近最少使用”，学过OS的应该知道内存缓存策略里也有这个算法，不明白的请自行搜索。配置如下：</p>\n<ol>\n<li><database-reference name=\"mydb\">  </li>\n<li>… configure data source or driver manager settings…  </li>\n<li>    <lru-cache size=\"1000\"/>  </li>\n<li></database-reference></li>\n</ol>\n<p>  </p>\n<p>size的参数值表示最多能缓存多少条查询结果，而不是大小</p>\n<p><em>b.Expiry-time Cache</em><br>该策略为每一次的查询结果设置了存活期（注意不是每一条查询结果），并且定期清理过期的查询结果。配置如下：</p>\n<ol>\n<li><database-reference name=\"mydb\">  </li>\n<li>… configure data source or driver manager settings…  </li>\n<li>    <expiry-time-cache max-age-seconds=\"60\" purge-interval-seconds=\"120\" ref-type=\"soft\"/>  </li>\n<li></database-reference></li>\n</ol>\n<p>  </p>\n<p>max-age-seconds表示存活时间，purge-interval-seconds表示每隔多久清理一次过期的内容，两者单位都是秒。<br>ref-type有三个参数值：weak，soft，hard。表示查询结果的引用级别，JVM垃圾回收的时候，会根据此参数决定何时释放缓存。具体解释如下：<br>1).weak表示弱引用，JVM在垃圾回收的时候将清除所有的缓存，释放内存。<br>2).soft表示软引用，JVM在垃圾回收的时候，只有当所有的弱引用都被回收了才会清除所有的缓存并释放空间。<br>3).hard表示强引用，JVM的垃圾回收不会清除缓存，所以引擎将按照规定的存活期和清理时间管理缓存。</p>\n<p><strong>3.Column Change Case</strong><br>通常情况下，表字段是大小写不敏感的，但是也有设置为小写敏感的情况，我们可以通过设置使得查询返回的列结果为大写或者小写。配置如下：</p>\n<ol>\n<li><column-change-case value=\"lowercase\"/></li>\n</ol>\n<p>  </p>\n<p><strong>4.SQL Types Mapping</strong><br>默认的数据库字段类型映射可以满足需求，不过想修改也是可以的。配置如下：</p>\n<ol>\n<li><sql-types-mapping sql-type=\"2\" java-type=\"int\" /></li>\n</ol>\n<p>  </p>\n<p>sql-type表示数据库字段类型，这里的2映射了具体类型，可在java.sql.Types类中查到，并且这个类里包含了大部分的数据库字段类型。java-type表示对应的java数据类型，大小写不敏感。</p>\n<p>以上就是EPL和数据库交互的相关配置，下面来讲解EPL是怎么和数据库交互的。</p>\n<p>EPL和数据库交互有两个前提，一是JDBC驱动能够预编译sql，而是JDBC驱动能获取数据库的元数据。</p>\n<p><strong>5.Joining SQL Query Results</strong><br>通常我们想要的一种交互方式是：输入某个事件到引擎，然后引擎把事件的某个属性作为sql的查询条件交给JDBC驱动，执行sql。正好esper为此提供了相应的解决办法，参看语法：</p>\n<ol>\n<li>sql:database_name [“ parameterized_sql_query “]</li>\n</ol>\n<p>  </p>\n<p>sql是关键字不可少，parameterized_sql_query为sql语句，只与具体的DB有关，无关esper，所以数据库的那些个函数都可以用。先看一个简单的例子：</p>\n<ol>\n<li>select custId, cust_name from CustomerCallEvent, sql:MyCustomerDB [‘ select cust_name from Customer where cust_id &#x3D; ${custId} ‘]</li>\n</ol>\n<p>  </p>\n<p>引擎接收CustomerCallEvent事件，将事件的custId属性作为查询值，执行MyCustomerDB数据库的Customer表，其中查询条件为Customer的cust_id字段值存在，然后返回相应的custId属性值和cust_name字段值给监听器</p>\n<p>该语法有几点需要注意：<br><strong>a</strong>.sql需要用单引号或者双引号引起来，然后再用方括号括起来。<br><strong>b</strong>.${expression}中可以是事件属性，可以是变量、常量等，也可以是用户自定义的函数。例如：</p>\n<ol>\n<li>select * from LimitEvent le,  </li>\n<li>  sql:MyCustomerDB [‘ select cust_name from Customer where  </li>\n<li>      amount &gt; ${max(varLowerLimit, MyLib.getLimit(le))} ‘]</li>\n</ol>\n<p>  </p>\n<p><strong>c</strong>.join的事件可以使用view，但是sql不可使用。不过可以将sql的查询结果通过insert into输出到另外的事件，然后再使用view。例如：</p>\n<ol>\n<li>select customerId, customerName from CustomerCallEvent.win:time(30 sec) as cce,  </li>\n<li>  sql:MyCustomerDB [“select cust_id as customerId, cust_name as customerName  </li>\n<li>    from Customer  </li>\n<li>  where cust_id &#x3D; ${cce.custId}”] as cq</li>\n</ol>\n<p>  </p>\n<p><strong>d</strong>.可以用as为表的字段设置别名，例如：</p>\n<ol>\n<li>select custId, custName from CustomerCallEvent, sql:MyCustomerDB [‘ select cust_name as custName from Customer where cust_id &#x3D; ${custId} ‘]</li>\n</ol>\n<p>  </p>\n<p><strong>e</strong>.当使用事件的属性作为查询值是，属性名不要和字段名重名，否则会报错，esper无法识别<br><strong>f</strong>.join的sql语句没有限制，并且可以使用where子句。例如：</p>\n<ol>\n<li>select symbol, symbolDesc from OrderEvent as orders,  </li>\n<li>  sql:My_Oracle_DB [‘select symbolDesc from SymbolReference’] as reference,  </li>\n<li>  sql:My_MySQL_DB [‘select orderList from orderHistory’] as history  </li>\n<li>    where reference.symbol &#x3D; orders.symbol  </li>\n<li>    and history.symbol &#x3D; orders.symbol</li>\n</ol>\n<p>  </p>\n<p>除了普通的join，EPL也支持outer join sql语句，语法也没有什么改变。例如：</p>\n<ol>\n<li>select custId, custName from  </li>\n<li>  CustomerCallEvent as cce  </li>\n<li>    left outer join  </li>\n<li>  sql:MyCustomerDB [“select cust_id, cust_name as custName from Customer where cust_id &#x3D; ${cce.custId}”] as cq  </li>\n<li>    on cce.custId &#x3D; cq.cust_id</li>\n</ol>\n<p>  </p>\n<p><strong>6.Using Patterns to Request Data</strong><br>除了通过传递外部数据查询数据库，也可以用pattern定时或者以固定频率查询数据库。例如：</p>\n<ol>\n<li>insert into NewOrders  </li>\n<li>select orderId, orderAmount from  </li>\n<li>  pattern [every timer:interval(5 sec)],  </li>\n<li>    sql:MyCustomerDB [‘select orderId, orderAmount from NewOrders’]</li>\n</ol>\n<p>  </p>\n<p>pattern语法之后再说，这里只让大家知道有这么一个用法。</p>\n<p><strong>7.Polling SQL Queries via API</strong><br>Esper提供了API直接执行EPL来达到访问数据库的目的。请看下面的代码：</p>\n<ol>\n<li><p>package example;  </p>\n</li>\n<li><p>import com.espertech.esper.client.Configuration;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPRuntime;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import java.util.Iterator;  </p>\n</li>\n<li><p>public class IteratorSQLTest {  </p>\n</li>\n<li><p>    public static void main(String[] args) throws InterruptedException {  </p>\n</li>\n<li><p>        Configuration config &#x3D; new Configuration();  </p>\n</li>\n<li><p>        config.configure(“esper.examples.cfg.xml”);  </p>\n</li>\n<li><p>        config.addVariable(“vari”, Integer.class, 1);  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider(config);  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        EPRuntime runtime &#x3D; epService.getEPRuntime();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “select id, name from sql:test[‘select id, name from test1 where id&#x3D;${vari}’]“;  </p>\n</li>\n<li><p>        EPStatement state &#x3D; admin.createEPL(epl1);  </p>\n</li>\n<li><p>        Iterator<EventBean> iter &#x3D; state.iterator(); </p>\n</li>\n<li><p>        while (iter.hasNext()) {  </p>\n</li>\n<li><p>            EventBean eventBean &#x3D; iter.next();  </p>\n</li>\n<li><p>            System.out.println(eventBean.get(“id”) + “ “ + eventBean.get(“name”));  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<p><strong>8.SQL Input Parameter and Column Output Conversion</strong><br>刚才数据库配置里面有说到可以修改数据库字段类型和java数据类型的映射关系，但是那只是针对全局的设置，如果想针对EPL来设置映射关系，可以实现SQLColumnTypeConversion接口，然后通过注解Hook调用实现类。具体代码及解释如下：</p>\n<ol>\n<li><p>import com.espertech.esper.client.hook.SQLColumnTypeContext;  </p>\n</li>\n<li><p>import com.espertech.esper.client.hook.SQLColumnTypeConversion;  </p>\n</li>\n<li><p>import com.espertech.esper.client.hook.SQLColumnValueContext;  </p>\n</li>\n<li><p>import com.espertech.esper.client.hook.SQLInputParameterContext;  </p>\n</li>\n<li><p>public class MySQLColumnTypeConvertor implements SQLColumnTypeConversion{  </p>\n</li>\n<li><p>    public Class getColumnType(SQLColumnTypeContext context) {  </p>\n</li>\n<li><p>        Class clazz &#x3D; context.getColumnClassType();  </p>\n</li>\n<li><p>        return clazz;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public Object getColumnValue(SQLColumnValueContext context) {  </p>\n</li>\n<li><p>        Object obj &#x3D; context.getColumnValue();  </p>\n</li>\n<li><p>        return obj;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public Object getParameterValue(SQLInputParameterContext context) {  </p>\n</li>\n<li><p>        Object obj &#x3D; context.getParameterValue();  </p>\n</li>\n<li><p>        return obj;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>package example;  </p>\n</li>\n<li><p>import com.espertech.esper.client.Configuration;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import java.util.Iterator;  </p>\n</li>\n<li><p>public class SQLColumnTypeConversionTest {  </p>\n</li>\n<li><p>    public static void main(String[] args) throws InterruptedException {  </p>\n</li>\n<li><p>        Configuration config &#x3D; new Configuration();  </p>\n</li>\n<li><p>        config.configure(“esper.examples.cfg.xml”);  </p>\n</li>\n<li><p>        config.addVariable(“vari”, Integer.class, 1);  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider(config);  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “@Hook(type&#x3D;HookType.SQLCOL, hook&#x3D;’” + MySQLColumnTypeConvertor.class.getName()  </p>\n</li>\n<li><p>                + “‘)select id, name from sql:test[‘select id, name from test1 where id&#x3D;${vari}’]“;  </p>\n</li>\n<li><p>        System.out.println(epl1);  </p>\n</li>\n<li><p>        EPStatement state1 &#x3D; admin.createEPL(epl1);  </p>\n</li>\n<li><p>        Iterator<EventBean> iter &#x3D; state1.iterator();  </p>\n</li>\n<li><p>        while (iter.hasNext()) {  </p>\n</li>\n<li><p>            EventBean eventBean &#x3D; iter.next();  </p>\n</li>\n<li><p>            System.out.println(eventBean.get(“id”) + “ “ + eventBean.get(“name”));  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li>@Hook(type&#x3D;HookType.SQLCOL, hook&#x3D;’example.MySQLColumnTypeConvertor’)select id, name from sql:test[‘select id, name from test1 where id&#x3D;${vari}’]  </li>\n<li>1 luonq</li>\n</ol>\n<p>  </p>\n<p><strong>9.SQL Row POJO Conversion</strong><br>刚才说的列类型的转换以及列结果的转换，只是普通的转换。Esper还支持表的查询结果按行转换，比如说转换为POJO，而不像之前那样只能针对每一个字段结果单独进行转换。用法也是通过Hook注解来调用转换类。代码如下：</p>\n<ol>\n<li><p>import java.sql.ResultSet;  </p>\n</li>\n<li><p>import java.sql.SQLException;  </p>\n</li>\n<li><p>import com.espertech.esper.client.hook.SQLOutputRowConversion;  </p>\n</li>\n<li><p>import com.espertech.esper.client.hook.SQLOutputRowTypeContext;  </p>\n</li>\n<li><p>import com.espertech.esper.client.hook.SQLOutputRowValueContext;  </p>\n</li>\n<li><p>public class MySQLOutputRowConvertor implements SQLOutputRowConversion {  </p>\n</li>\n<li><p>    public Class getOutputRowType(SQLOutputRowTypeContext context) {  </p>\n</li>\n<li><p>        return String.class;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>    public Object getOutputRow(SQLOutputRowValueContext context) {  </p>\n</li>\n<li><p>        ResultSet result &#x3D; context.getResultSet();  </p>\n</li>\n<li><p>        Object obj1 &#x3D; null;  </p>\n</li>\n<li><p>        Object obj2 &#x3D; null;  </p>\n</li>\n<li><p>        try {  </p>\n</li>\n<li><p>            obj1 &#x3D; result.getObject(“id”);  </p>\n</li>\n<li><p>            obj2 &#x3D; result.getObject(“name”);  </p>\n</li>\n<li><p>        } catch (SQLException e) {  </p>\n</li>\n<li><p>            e.printStackTrace();  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>        return obj1 + “ and “ + obj2;  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}  </p>\n</li>\n<li><p>package example;  </p>\n</li>\n<li><p>import com.espertech.esper.client.Configuration;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPAdministrator;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProvider;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPServiceProviderManager;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EPStatement;  </p>\n</li>\n<li><p>import com.espertech.esper.client.EventBean;  </p>\n</li>\n<li><p>import java.util.Iterator;  </p>\n</li>\n<li><p>public class SQLOutputRowConversionTest {  </p>\n</li>\n<li><p>    public static void main(String[] args) throws InterruptedException {  </p>\n</li>\n<li><p>        Configuration config &#x3D; new Configuration();  </p>\n</li>\n<li><p>        config.configure(“esper.examples.cfg.xml”);  </p>\n</li>\n<li><p>        config.addVariable(“vari”, Integer.class, 1);  </p>\n</li>\n<li><p>        EPServiceProvider epService &#x3D; EPServiceProviderManager.getDefaultProvider(config);  </p>\n</li>\n<li><p>        EPAdministrator admin &#x3D; epService.getEPAdministrator();  </p>\n</li>\n<li><p>        String epl1 &#x3D; “@Hook(type&#x3D;HookType.SQLROW, hook&#x3D;’” + MySQLOutputRowConvertor.class.getName()  </p>\n</li>\n<li><p>                + “‘)select * from sql:test[‘select id, name from test1 where id&#x3D;${vari}’]“;  </p>\n</li>\n<li><p>        System.out.println(epl1);  </p>\n</li>\n<li><p>        EPStatement state1 &#x3D; admin.createEPL(epl1);  </p>\n</li>\n<li><p>        Iterator<EventBean> iter &#x3D; state1.iterator();  </p>\n</li>\n<li><p>        while (iter.hasNext()) {  </p>\n</li>\n<li><p>            EventBean eventBean &#x3D; iter.next();  </p>\n</li>\n<li><p>            System.out.println(eventBean.getUnderlying());  </p>\n</li>\n<li><p>        }  </p>\n</li>\n<li><p>    }  </p>\n</li>\n<li><p>}</p>\n</li>\n</ol>\n<p>  </p>\n<p>执行结果：</p>\n<ol>\n<li>@Hook(type&#x3D;HookType.SQLROW, hook&#x3D;’example.MySQLOutputRowConvertor’)select * from sql:test[‘select id, name from test1 where id&#x3D;${vari}’]  </li>\n<li>1 and luonq</li>\n</ol>\n<p>  </p>\n<p>以上就是EPL和数据库交互的内容，针对普通的查询需求来说还是够用的，至于insert，update，delete我没有举例子，各位可以自己试试看可不可行。</p>\n","text":"Esper学习之十：EPL语法（六） 在esper的文档中，epl访问数据库的配置放在了比较靠后的位置，不过为了方便各位学习，这里会先说明和数据库交互的相关配置...","permalink":"/post/BIGDATA/Esper学习之十：EPL语法（六）","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"name","slug":"name","count":1,"path":"api/categories/name.json"},{"name":"BIGDATA","slug":"name/BIGDATA","count":1,"path":"api/categories/name/BIGDATA.json"}],"tags":[{"name":"esper","slug":"esper","count":2,"path":"api/tags/esper.json"},{"name":"sql","slug":"sql","count":1,"path":"api/tags/sql.json"},{"name":"import","slug":"import","count":1,"path":"api/tags/import.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Esper%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8D%81%EF%BC%9AEPL%E8%AF%AD%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89\"><span class=\"toc-text\">Esper学习之十：EPL语法（六）</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Esper学习之十一：EPL语法（七）","uid":"6131b419f4b67eaeeae93021cf6fda95","slug":"BIGDATA/Esper学习之十一：EPL语法（七）","date":"2023-06-09T09:35:27.000Z","updated":"2025-09-30T03:26:03.979Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之十一：EPL语法（七）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之十一：EPL语法（七） 上一篇说到了EPL如何访问关系型数据库这种数据源，实际上别的数据源，比如：webservice、分布式缓存、非关系型数据...","permalink":"/post/BIGDATA/Esper学习之十一：EPL语法（七）","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"schema","slug":"schema","count":1,"path":"api/categories/schema.json"},{"name":"BIGDATA","slug":"schema/BIGDATA","count":1,"path":"api/categories/schema/BIGDATA.json"}],"tags":[{"name":"class","slug":"class","count":2,"path":"api/tags/class.json"},{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"},{"name":"String","slug":"String","count":1,"path":"api/tags/String.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Esper学习之九：EPL语法（五）","uid":"c610892d4b9e5d360c3a54bc62d56b3a","slug":"BIGDATA/Esper学习之九：EPL语法（五）","date":"2023-06-09T09:25:57.000Z","updated":"2025-09-30T03:26:03.760Z","comments":true,"path":"api/articles/BIGDATA/Esper学习之九：EPL语法（五）.json","keywords":"XuGuangSheng","cover":"/covers/esperepl.jpg","text":"Esper学习之九：EPL语法（五）本篇的内容主要包括了Subquery（也就是子查询）和Join，内容不少，但是不难，基本上和sql差不太多。 1.Subqu...","permalink":"/post/BIGDATA/Esper学习之九：EPL语法（五）","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"price","slug":"price","count":2,"path":"api/categories/price.json"},{"name":"BIGDATA","slug":"price/BIGDATA","count":2,"path":"api/categories/price/BIGDATA.json"}],"tags":[{"name":"select","slug":"select","count":5,"path":"api/tags/select.json"},{"name":"join","slug":"join","count":1,"path":"api/tags/join.json"},{"name":"from","slug":"from","count":2,"path":"api/tags/from.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}