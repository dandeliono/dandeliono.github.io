{"title":"ES 操作之批量写-BulkProcessor 原理浅析","uid":"bd22547b0a0201a36c471a9e283ced81","slug":"JAVA/ES 操作之批量写-BulkProcessor 原理浅析","date":"2021-08-05T23:32:23.000Z","updated":"2025-12-05T01:46:14.726Z","comments":true,"path":"api/articles/JAVA/ES 操作之批量写-BulkProcessor 原理浅析.json","keywords":"XuGuangSheng","cover":"/covers/es-bulkprocessor.jpg","content":"<h1 id=\"ES-操作之批量写-BulkProcessor-原理浅析\"><a href=\"#ES-操作之批量写-BulkProcessor-原理浅析\" class=\"headerlink\" title=\"ES 操作之批量写-BulkProcessor 原理浅析\"></a>ES 操作之批量写-BulkProcessor 原理浅析</h1><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/115096988/edit\">BulkProcessor</a></p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/115096988/edit\">创建流程</a></p>\n</li>\n<li><p>[内部逻辑实现]</p>\n</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最近对线上业务进行重构，涉及到ES同步这一块，在重构过程中，为了ES 写入 性能考虑，大量的采取了 bulk的方式，来保证整体的一个同步速率，针对BulkProcessor 来深入一下，了解下 是如何实现，基于请求数，请求数据量大小 和 固定时间，刷新写入ES 的原理</span><br><span class=\"line\"></span><br><span class=\"line\">针对ES 批量写入， 提供了3种方式，在 high-rest-client 中</span><br><span class=\"line\">分别是 bulk bulkAsync  bulkProcessor 3种方式。</span><br><span class=\"line\">本文主要针对 bulkProcessor 来进行一些讲述</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"BulkProcessor\"><a href=\"#BulkProcessor\" class=\"headerlink\" title=\"BulkProcessor\"></a><strong>BulkProcessor</strong></h2><p><strong>官方介绍</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BulkProcessor是一个线程安全的批量处理类,允许方便地设置 刷新 一个新的批量请求 </span><br><span class=\"line\">(基于数量的动作,根据大小,或时间),</span><br><span class=\"line\">容易控制并发批量的数量</span><br><span class=\"line\">请求允许并行执行。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建流程\"><a href=\"#创建流程\" class=\"headerlink\" title=\"创建流程\"></a><strong>创建流程</strong></h3><p><strong>How To use ？</strong></p>\n<p><strong>来看个 demo</strong> <code>创建 BulkProcessor</code></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean(name = &quot;bulkProcessor&quot;) // 可以封装为一个bean，非常方便其余地方来进行 写入 操作</span><br><span class=\"line\">  public BulkProcessor bulkProcessor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        BiConsumer&lt;BulkRequest, ActionListener&lt;BulkResponse&gt;&gt; bulkConsumer =</span><br><span class=\"line\">                (request, bulkListener) -&gt; Es6XServiceImpl.getClient().bulkAsync(request, RequestOptions.DEFAULT, bulkListener);</span><br><span class=\"line\"></span><br><span class=\"line\">        return BulkProcessor.builder(bulkConsumer, new BulkProcessor.Listener() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void beforeBulk(long executionId, BulkRequest request) &#123;</span><br><span class=\"line\">              \t\t// todo do something</span><br><span class=\"line\">                int i = request.numberOfActions();</span><br><span class=\"line\">                log.error(&quot;ES 同步数量&#123;&#125;&quot;,i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void afterBulk(long executionId, BulkRequest request, BulkResponse response) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t// todo do something</span><br><span class=\"line\">                Iterator&lt;BulkItemResponse&gt; iterator = response.iterator();</span><br><span class=\"line\">                while (iterator.hasNext())&#123;</span><br><span class=\"line\">                    System.out.println(JSON.toJSONString(iterator.next()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void afterBulk(long executionId, BulkRequest request, Throwable failure) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t// todo do something</span><br><span class=\"line\">                log.error(&quot;写入ES 重新消费&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).setBulkActions(1000) //  达到刷新的条数</span><br><span class=\"line\">                .setBulkSize(new ByteSizeValue(1, ByteSizeUnit.MB)) // 达到 刷新的大小</span><br><span class=\"line\">                .setFlushInterval(TimeValue.timeValueSeconds(5)) // 固定刷新的时间频率</span><br><span class=\"line\">                .setConcurrentRequests(1) //并发线程数</span><br><span class=\"line\">                .setBackoffPolicy(BackoffPolicy.exponentialBackoff(TimeValue.timeValueMillis(100), 3)) // 重试补偿策略</span><br><span class=\"line\">                .build(); </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>使用 BulkProcessor</code></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bulkProcessor.add(xxxRequest)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>创建过程做了些什么？</strong></p>\n<ol>\n<li><p>创建一个 consumer 对象用来封装传递参数，和请求操作<br>BiConsumer&lt;BulkRequest, ActionListener<BulkResponse>&gt; bulkConsumer &#x3D;<br>(request, bulkListener) -&gt; Es6XServiceImpl.getClient().bulkAsync(request, RequestOptions.DEFAULT, bulkListener);</p>\n<p>我们可以看到用了 java 8 的函数式编程接口 BiConsumer 关于 BiConsumer 的用法，可以自行百度，因为也是采取的 异步刷新策略， 所以，是一个返回结果的 Listener ActionListener</p>\n</li>\n<li><p>构建并 BulkProcess<br>return BulkProcessor.builder(bulkConsumer, new BulkProcessor.Listener() {<br>****</p>\n<p>}).setBulkActions(1000)<br>.setBulkSize(new ByteSizeValue(1, ByteSizeUnit.MB))<br>.setFlushInterval(TimeValue.timeValueSeconds(5))<br>.setConcurrentRequests(1)<br>.setBackoffPolicy(BackoffPolicy.exponentialBackoff(TimeValue.timeValueMillis(100), 3))<br>.build();</p>\n<p>}</p>\n<p>可以很清楚的看到，在 build 操作中，我们看到，在 build 中，除了 之前定义的 consumer，还实现了一个 Listener 接口 （稍后会具体讲到），用来做一些 在批量求情之前和请求之后的处理。</p>\n</li>\n</ol>\n<p>至此为止，BulkProcessor 创建，就 OK 啦～。</p>\n<h3 id=\"内部逻辑实现\"><a href=\"#内部逻辑实现\" class=\"headerlink\" title=\"内部逻辑实现\"></a><strong>内部逻辑实现</strong></h3><p><strong>先不说话，我们先上张类图</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/4314b24759cf2b25ddff661a16107bc7.jpeg\"></p>\n<p>可以看到，在 BulkProcessor 中，有这样的一些类和接口</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Listener</span><br><span class=\"line\">Builder</span><br><span class=\"line\">BulkProcessor</span><br><span class=\"line\">Flush</span><br><span class=\"line\">===== 华丽的分界线</span><br><span class=\"line\">BulkProcessor 实现了 Closeable --&gt; 继承自  AutoCloseable （关于AutoCloseable 本文不做过多说明，具体的可以百度，或者等待后续）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>那么先从构建开始，我们来看下 Builder</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 简单的构建，可以看到，就是一个client 和 listener 这个不会做刷新策略，</span><br><span class=\"line\">*/</span><br><span class=\"line\">public static Builder builder(Client client, Listener listener) &#123;</span><br><span class=\"line\">        Objects.requireNonNull(client, &quot;client&quot;);</span><br><span class=\"line\">        Objects.requireNonNull(listener, &quot;listener&quot;);</span><br><span class=\"line\">        return new Builder(client::bulk, listener, client.threadPool(), () -&gt; &#123;&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 所有功能的builder 实现方法</span><br><span class=\"line\">* ScheduledThreadPoolExecutor 用来实现 按照时间频率，来进行 刷新，如 每5s </span><br><span class=\"line\">*</span><br><span class=\"line\">*/</span><br><span class=\"line\">    public static Builder builder(BiConsumer&lt;BulkRequest, ActionListener&lt;BulkResponse&gt;&gt; consumer, Listener listener) &#123;</span><br><span class=\"line\">        Objects.requireNonNull(consumer, &quot;consumer&quot;);</span><br><span class=\"line\">        Objects.requireNonNull(listener, &quot;listener&quot;);</span><br><span class=\"line\">        final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = Scheduler.initScheduler(Settings.EMPTY); // 接口静态方式，来实现 Executor 的初始化</span><br><span class=\"line\">        return new Builder(consumer, listener,</span><br><span class=\"line\">                (delay, executor, command) -&gt; scheduledThreadPoolExecutor.schedule(command, delay.millis(), TimeUnit.MILLISECONDS), //</span><br><span class=\"line\">                () -&gt; Scheduler.terminate(scheduledThreadPoolExecutor, 10, TimeUnit.SECONDS));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 构造函数 </span><br><span class=\"line\">* @param consumer 前文定义的consumer request response action</span><br><span class=\"line\">* @param listener listener  BulkProcessor 内置监听器</span><br><span class=\"line\">* @param scheduler elastic 定时调度 类scheduler  </span><br><span class=\"line\">* @paran onClose 关闭时候的运行</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">    private Builder(BiConsumer&lt;BulkRequest, ActionListener&lt;BulkResponse&gt;&gt; consumer, Listener listener,</span><br><span class=\"line\">                        Scheduler scheduler, Runnable onClose) &#123;</span><br><span class=\"line\">            this.consumer = consumer;</span><br><span class=\"line\">            this.listener = listener;</span><br><span class=\"line\">            this.scheduler = scheduler;</span><br><span class=\"line\">            this.onClose = onClose;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>通过上述的代码片段，可以很明显的看到，关于初始化构建的一些关键点和要素</p>\n<p><strong>看完 builder 接下来，我们看下 bulkprocessor 是如何工作的</strong></p>\n<p><em>先看下构造方法</em></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BulkProcessor(BiConsumer&lt;BulkRequest, ActionListener&lt;BulkResponse&gt;&gt; consumer, BackoffPolicy backoffPolicy, Listener listener,</span><br><span class=\"line\">               int concurrentRequests, int bulkActions, ByteSizeValue bulkSize, @Nullable TimeValue flushInterval,</span><br><span class=\"line\">               Scheduler scheduler, Runnable onClose) &#123;</span><br><span class=\"line\">     this.bulkActions = bulkActions;</span><br><span class=\"line\">     this.bulkSize = bulkSize.getBytes();</span><br><span class=\"line\">     this.bulkRequest = new BulkRequest();</span><br><span class=\"line\">     this.scheduler = scheduler;</span><br><span class=\"line\">     this.bulkRequestHandler = new BulkRequestHandler(consumer, backoffPolicy, listener, scheduler, concurrentRequests); // BulkRequestHandler 批量执行 handler 操作</span><br><span class=\"line\">     // Start period flushing task after everything is setup</span><br><span class=\"line\">     this.cancellableFlushTask = startFlushTask(flushInterval, scheduler); //开始刷新任务</span><br><span class=\"line\">     this.onClose = onClose;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>startFlushTask 如何进行工作</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private Scheduler.Cancellable startFlushTask(TimeValue flushInterval, Scheduler scheduler) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // 如果 按照时间刷新 为空，则直接返回 任务为取消状态</span><br><span class=\"line\">   if (flushInterval == null) &#123;</span><br><span class=\"line\">            return new Scheduler.Cancellable() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void cancel() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public boolean isCancelled() &#123;</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        final Runnable flushRunnable = scheduler.preserveContext(new Flush());</span><br><span class=\"line\">        return scheduler.scheduleWithFixedDelay(flushRunnable, flushInterval, ThreadPool.Names.GENERIC);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void executeIfNeeded() &#123;</span><br><span class=\"line\">        ensureOpen();</span><br><span class=\"line\">        if (!isOverTheLimit()) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 刷新线程</span><br><span class=\"line\">class Flush implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            synchronized (BulkProcessor.this) &#123;</span><br><span class=\"line\">                if (closed) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (bulkRequest.numberOfActions() == 0) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                execute(); // 下面方法</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">*  刷新执行</span><br><span class=\"line\">*</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\"> // (currently) needs to be executed under a lock</span><br><span class=\"line\">    private void execute() &#123;</span><br><span class=\"line\">        final BulkRequest bulkRequest = this.bulkRequest;</span><br><span class=\"line\">        final long executionId = executionIdGen.incrementAndGet();</span><br><span class=\"line\">\t\t\t\t// 刷新 bulkRequest 为下一批做准备</span><br><span class=\"line\">        this.bulkRequest = new BulkRequest();</span><br><span class=\"line\">        this.bulkRequestHandler.execute(bulkRequest, executionId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>看到这里，关于时间的定时调度，我们其实是很清楚了，那么 关于数据量 和 大小的判断策略在哪儿？</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* 各种添加操作</span><br><span class=\"line\">*/</span><br><span class=\"line\">public BulkProcessor add(DocWriteRequest request, @Nullable Object payload) &#123;</span><br><span class=\"line\">        internalAdd(request, payload);</span><br><span class=\"line\">        return this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t* 我们可以看到，在添加之后，会做一个操作</span><br><span class=\"line\">\t* executeIfNeeded 如果需要，则进行执行</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">    private synchronized void internalAdd(DocWriteRequest request, @Nullable Object payload) &#123;</span><br><span class=\"line\">        ensureOpen();</span><br><span class=\"line\">        bulkRequest.add(request, payload);</span><br><span class=\"line\">        executeIfNeeded();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 如果超过限制，则执行刷新操作</span><br><span class=\"line\">*/</span><br><span class=\"line\"> private void executeIfNeeded() &#123;</span><br><span class=\"line\">        ensureOpen();</span><br><span class=\"line\">        if (!isOverTheLimit()) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        execute();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t* 这这儿，我们终于看到了 关于action 和 size 的判断操作，</span><br><span class=\"line\">\t*</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">    private boolean isOverTheLimit() &#123;</span><br><span class=\"line\">        if (bulkActions != -1 &amp;&amp; bulkRequest.numberOfActions() &gt;= bulkActions) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (bulkSize != -1 &amp;&amp; bulkRequest.estimatedSizeInBytes() &gt;= bulkSize) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong><code>通过上述的分析，关于按照时间，数据 size，大小来进行 flush 执行的入口我们都已经很清楚了</code></strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">针对数据大小的设置。在每次添加的时候，做判断是否 超过限制</span><br><span class=\"line\">针对 时间的频次控制，交由ScheduledThreadPoolExecutor 来去做监控</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>下来，让我们看下具体的执行以及重试策略，和 返回值的处理</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void execute(BulkRequest bulkRequest, long executionId) &#123;</span><br><span class=\"line\">        Runnable toRelease = () -&gt; &#123;&#125;;</span><br><span class=\"line\">        boolean bulkRequestSetupSuccessful = false;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">          // listener 填充 request 和执行ID</span><br><span class=\"line\">            listener.beforeBulk(executionId, bulkRequest);</span><br><span class=\"line\">          \t//通过信号量来进行资源的控制 来自于我们设置的 setConcurrentRequests</span><br><span class=\"line\">            semaphore.acquire();</span><br><span class=\"line\">            toRelease = semaphore::release;</span><br><span class=\"line\">            CountDownLatch latch = new CountDownLatch(1);</span><br><span class=\"line\">          // 进行执行并按照补偿重试策略如果失败</span><br><span class=\"line\">            retry.withBackoff(consumer, bulkRequest, new ActionListener&lt;BulkResponse&gt;() &#123;</span><br><span class=\"line\">\t\t\t\t\t\t \t//结果写入  ActionListener --&gt; BulkProcessor.Listener 的转换</span><br><span class=\"line\">              @Override</span><br><span class=\"line\">                public void onResponse(BulkResponse response) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        listener.afterBulk(executionId, bulkRequest, response);</span><br><span class=\"line\">                    &#125; finally &#123;</span><br><span class=\"line\">                        semaphore.release();</span><br><span class=\"line\">                        latch.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public void onFailure(Exception e) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        listener.afterBulk(executionId, bulkRequest, e);</span><br><span class=\"line\">                    &#125; finally &#123;</span><br><span class=\"line\">                        semaphore.release();</span><br><span class=\"line\">                        latch.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, Settings.EMPTY);</span><br><span class=\"line\">            bulkRequestSetupSuccessful = true;</span><br><span class=\"line\">            if (concurrentRequests == 0) &#123;</span><br><span class=\"line\">                latch.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">            logger.info(() -&gt; new ParameterizedMessage(&quot;Bulk request &#123;&#125; has been cancelled.&quot;, executionId), e);</span><br><span class=\"line\">            listener.afterBulk(executionId, bulkRequest, e);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            logger.warn(() -&gt; new ParameterizedMessage(&quot;Failed to execute bulk request &#123;&#125;.&quot;, executionId), e);</span><br><span class=\"line\">            listener.afterBulk(executionId, bulkRequest, e);</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            if (bulkRequestSetupSuccessful == false) &#123;  // if we fail on client.bulk() release the semaphore</span><br><span class=\"line\">                toRelease.run();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>最终的执行，在 RetryHandler 中，继续往下看</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void execute(BulkRequest bulkRequest) &#123;</span><br><span class=\"line\">            this.currentBulkRequest = bulkRequest;</span><br><span class=\"line\">            consumer.accept(bulkRequest, this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>对，没错，只有一个操作， consumer.accept(bulkRequest, this);</p>\n<p>再一次展现了 java 8 函数式接口的功能强大之处 此处 consumer.accept(bulkRequest, this);</p>\n<p>执行的操作即 Es6XServiceImpl.getClient().bulkAsync(request, RequestOptions.DEFAULT, bulkListener);</p>\n<p><strong>如何设置重试策略，以及数据的筛选</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">        public void onResponse(BulkResponse bulkItemResponses) &#123;</span><br><span class=\"line\">            if (!bulkItemResponses.hasFailures()) &#123;</span><br><span class=\"line\">                // we&#x27;re done here, include all responses</span><br><span class=\"line\">                addResponses(bulkItemResponses, (r -&gt; true));</span><br><span class=\"line\">                finishHim();</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                if (canRetry(bulkItemResponses)) &#123;</span><br><span class=\"line\">                    addResponses(bulkItemResponses, (r -&gt; !r.isFailed()));</span><br><span class=\"line\">                    retry(createBulkRequestForRetry(bulkItemResponses));</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    addResponses(bulkItemResponses, (r -&gt; true));</span><br><span class=\"line\">                    finishHim();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* 只针对失败的请求，放入到重试策略中</span><br><span class=\"line\">*/</span><br><span class=\"line\">   private void addResponses(BulkResponse response, Predicate&lt;BulkItemResponse&gt; filter) &#123;</span><br><span class=\"line\">            for (BulkItemResponse bulkItemResponse : response) &#123;</span><br><span class=\"line\">                if (filter.test(bulkItemResponse)) &#123;</span><br><span class=\"line\">                    // Use client-side lock here to avoid visibility issues. This method may be called multiple times</span><br><span class=\"line\">                    // (based on how many retries we have to issue) and relying that the response handling code will be</span><br><span class=\"line\">                    // scheduled on the same thread is fragile.</span><br><span class=\"line\">                    synchronized (responses) &#123;</span><br><span class=\"line\">                        responses.add(bulkItemResponse);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>再一次展示了函数式接口的强大之处</p>\n<p><strong>补充一张流程图</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/6a029407457c8607e529246c3993ee5c.jpeg\"></p>\n","text":"ES 操作之批量写-BulkProcessor 原理浅析 BulkProcessor 创建流程 [内部逻辑实现] 123456最近对线上业务进行重构，涉及到ES...","permalink":"/post/JAVA/ES 操作之批量写-BulkProcessor 原理浅析","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"BulkProcessor","slug":"BulkProcessor","count":1,"path":"api/categories/BulkProcessor.json"},{"name":"JAVA","slug":"BulkProcessor/JAVA","count":1,"path":"api/categories/BulkProcessor/JAVA.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"consumer","slug":"consumer","count":2,"path":"api/tags/consumer.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ES-%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%89%B9%E9%87%8F%E5%86%99-BulkProcessor-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90\"><span class=\"toc-text\">ES 操作之批量写-BulkProcessor 原理浅析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BulkProcessor\"><span class=\"toc-text\">BulkProcessor</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">创建流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">内部逻辑实现</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Spring Boot配置文件指定包外文件","uid":"dd1cc8cb9e1a5d913e3dce35e0f864ee","slug":"JAVA/Spring Boot配置文件指定包外文件","date":"2021-08-07T15:16:44.000Z","updated":"2025-12-05T01:46:31.242Z","comments":true,"path":"api/articles/JAVA/Spring Boot配置文件指定包外文件.json","keywords":"XuGuangSheng","cover":"/covers/spring-boot.jpg","text":"Spring Boot配置文件指定包外文件通过命令行指定#SpringApplication 会默认将命令行选项参数转换为配置信息例如，启动时命令参数指定： j...","permalink":"/post/JAVA/Spring Boot配置文件指定包外文件","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"jar","slug":"jar","count":1,"path":"api/categories/jar.json"},{"name":"JAVA","slug":"jar/JAVA","count":1,"path":"api/categories/jar/JAVA.json"}],"tags":[{"name":"properties","slug":"properties","count":1,"path":"api/tags/properties.json"},{"name":"config","slug":"config","count":1,"path":"api/tags/config.json"},{"name":"application","slug":"application","count":1,"path":"api/tags/application.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JVM上的实时监控类库-Metrics","uid":"23169170d295b05eedfba9152181b026","slug":"JAVA/JVM上的实时监控类库-Metrics","date":"2021-08-04T23:26:15.000Z","updated":"2025-12-05T01:46:18.206Z","comments":true,"path":"api/articles/JAVA/JVM上的实时监控类库-Metrics.json","keywords":"XuGuangSheng","cover":"/covers/jvm-metrics.jpg","text":"JVM上的实时监控类库-Metrics一、使用 Metrics系统开发到一定的阶段，线上的机器越来越多，就需要一些监控了，除了服务器的监控，业务方面也需要一些监...","permalink":"/post/JAVA/JVM上的实时监控类库-Metrics","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[{"name":"Metrics","slug":"Metrics","count":1,"path":"api/categories/Metrics.json"},{"name":"JAVA","slug":"Metrics/JAVA","count":1,"path":"api/categories/Metrics/JAVA.json"}],"tags":[{"name":"MetricRegistry","slug":"MetricRegistry","count":1,"path":"api/tags/MetricRegistry.json"},{"name":"Histogram","slug":"Histogram","count":1,"path":"api/tags/Histogram.json"},{"name":"Meter","slug":"Meter","count":1,"path":"api/tags/Meter.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}