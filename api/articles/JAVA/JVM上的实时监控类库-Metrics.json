{"title":"JVM上的实时监控类库-Metrics","uid":"23169170d295b05eedfba9152181b026","slug":"JAVA/JVM上的实时监控类库-Metrics","date":"2021-08-04T23:26:15.000Z","updated":"2025-12-05T01:46:18.206Z","comments":true,"path":"api/articles/JAVA/JVM上的实时监控类库-Metrics.json","keywords":"XuGuangSheng","cover":"/covers/jvm-metrics.jpg","content":"<h1 id=\"JVM上的实时监控类库-Metrics\"><a href=\"#JVM上的实时监控类库-Metrics\" class=\"headerlink\" title=\"JVM上的实时监控类库-Metrics\"></a>JVM上的实时监控类库-Metrics</h1><h2 id=\"一、使用-Metrics\"><a href=\"#一、使用-Metrics\" class=\"headerlink\" title=\"一、使用 Metrics\"></a>一、使用 Metrics</h2><p>系统开发到一定的阶段，线上的机器越来越多，就需要一些监控了，除了服务器的监控，业务方面也需要一些监控服务。<code>Metrics</code>作为一款<code>监控指标</code>的度量<strong>类库</strong>，提供了许多工具帮助开发者来完成自定义的监控工作。</p>\n<p>通过构建一个<code>Spring Boot</code>的基本应用来演示<code>Metrics</code>的工作方式。</p>\n<p>在 Maven 的<code>pom.xml</code>中引入<code>Metrics</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt;&lt;artifactId&gt;metrics-core&lt;/artifactId&gt;&lt;version&gt;$&#123;metrics.version&#125;&lt;/version&gt;```</span><br><span class=\"line\"></span><br><span class=\"line\">目前`Metrics`的最新版本是`3.1.2`。</span><br><span class=\"line\"></span><br><span class=\"line\">二、Metrics的基本工具</span><br><span class=\"line\">--------------</span><br><span class=\"line\"></span><br><span class=\"line\">`Metrics`提供了五个基本的度量类型：</span><br><span class=\"line\"></span><br><span class=\"line\">1.  Gauges（度量）</span><br><span class=\"line\">2.  Counters（计数器）</span><br><span class=\"line\">3.  Histograms（直方图数据）</span><br><span class=\"line\">4.  Meters（TPS计算器）</span><br><span class=\"line\">5.  Timers（计时器）</span><br><span class=\"line\"></span><br><span class=\"line\">`Metrics`中`MetricRegistry`是中心容器，它是程序中所有度量的容器，所有新的度量工具都要注册到一个`MetricRegistry`实例中才可以使用，尽量在一个应用中保持让这个`MetricRegistry`实例保持单例。</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.1 MetricRegistry 容器</span><br><span class=\"line\"></span><br><span class=\"line\">在代码中配置好这个`MetricRegistry`容器：</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">public MetricRegistry metrics() &#123;return new MetricRegistry();```</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.2 Meters TPS计算器</span><br><span class=\"line\"></span><br><span class=\"line\">`TPS计算器`这个名称并不准确，`Meters`工具会帮助我们统计系统中某一个事件的速率。比如每秒请求数（TPS），每秒查询数（QPS）等等。这个指标能反应系统当前的处理能力，帮助我们判断资源是否已经不足。`Meters`本身是一个自增计数器。</span><br><span class=\"line\"></span><br><span class=\"line\">通过`MetricRegistry`可以获得一个`Meter`：</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">public Meter requestMeter(MetricRegistry metrics) &#123;return metrics.meter(&quot;request&quot;);```</span><br><span class=\"line\"></span><br><span class=\"line\">在请求中调用`mark()`方法，来增加计数，我们可以在不同的请求中添加不同的`Meter`，针对自己的系统完成定制的监控需求。</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">@RequestMapping(&quot;/hello&quot;)public String helloWorld() &#123;```</span><br><span class=\"line\"></span><br><span class=\"line\">应用运行的过程中，在console中反馈的信息：</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">-- Meters ----------------------------------------------------------------------         mean rate = 133.35 events/second1-minute rate = 121.66 events/second5-minute rate = 36.99 events/second15-minute rate = 13.33 events/second```</span><br><span class=\"line\"></span><br><span class=\"line\">从以上信息中可以看出`Meter`可以为我们提供平均速率，以及采样后的1分钟，5分钟，15分钟的速率。</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.3 Histogram 直方图数据</span><br><span class=\"line\"></span><br><span class=\"line\">直方图是一种非常常见的统计图表，`Metrics`通过这个`Histogram`这个度量类型提供了一些方便实时绘制直方图的**数据**。</span><br><span class=\"line\"></span><br><span class=\"line\">和之前的`Meter`相同，我们可以通过`MetricRegistry`来获得一个`Histogram`。</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">public Histogram responseSizes(MetricRegistry metrics) &#123;return metrics.histogram(&quot;response-sizes&quot;);```</span><br><span class=\"line\"></span><br><span class=\"line\">在应用中，需要统计的位置调用`Histogram`的`update()`方法。</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">responseSizes.update(new Random().nextInt(10));</span><br></pre></td></tr></table></figure>\n\n<p>比如我们需要统计某个方法的网络流量，通过<code>Histogram</code>就非常的方便。</p>\n<p>在 console 中<code>Histogram</code>反馈的信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- Histograms ------------------------------------------------------------------```</span><br><span class=\"line\"></span><br><span class=\"line\">`Histogram`为我们提供了最大值，最小值和平均值等数据，利用这些数据，我们就可以开始绘制自定义的直方图了。</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.4 Counter 计数器</span><br><span class=\"line\"></span><br><span class=\"line\">`Counter`的本质就是一个`AtomicLong`实例，可以增加或者减少值，可以用它来统计队列中Job的总数。</span><br><span class=\"line\"></span><br><span class=\"line\">通过`MetricRegistry`也可以获得一个`Counter`实例。</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">public Counter pendingJobs(MetricRegistry metrics) &#123;return metrics.counter(&quot;requestCount&quot;);```</span><br><span class=\"line\"></span><br><span class=\"line\">在需要统计数据的位置调用`inc()`和`dec()`方法。</span><br><span class=\"line\"></span><br><span class=\"line\">console的输出非常简单：</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">-- Counters --------------------------------------------------------------------```</span><br><span class=\"line\"></span><br><span class=\"line\">只是输出了当前度量的值。</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.5 Timer 计时器</span><br><span class=\"line\"></span><br><span class=\"line\">`Timer`是一个`Meter`和`Histogram`的组合。这个度量单位可以比较方便地统计请求的速率和处理时间。对于接口中调用的延迟等信息的统计就比较方便了。如果发现一个方法的`RPS（请求速率）`很低，而且平均的处理时间**很长**，那么这个方法八成出问题了。</span><br><span class=\"line\"></span><br><span class=\"line\">同样，通过`MetricRegistry`获取一个`Timer`的实例：</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">public Timer responses(MetricRegistry metrics) &#123;return metrics.timer(&quot;executeTime&quot;);```</span><br><span class=\"line\"></span><br><span class=\"line\">在需要统计信息的位置使用这样的代码：</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">final Timer.Context context = responses.time();```</span><br><span class=\"line\"></span><br><span class=\"line\">console中就会实时返回这个`Timer`的信息：</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">-- Timers ----------------------------------------------------------------------mean rate = 133.39 calls/second1-minute rate = 122.22 calls/second5-minute rate = 37.11 calls/second15-minute rate = 13.37 calls/secondstddev = 0.00 millisecondsmedian = 0.00 milliseconds99.9% &lt;= 0.01 milliseconds```</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.6 Gauges 度量</span><br><span class=\"line\"></span><br><span class=\"line\">除了`Metrics`提供的几个度量类型，我们可以通过`Gauges`完成自定义的度量类型。比方说很简单的，我们想看我们缓存里面的数据大小，就可以自己定义一个`Gauges`。</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">                MetricRegistry.name(ListManager.class, &quot;cache&quot;, &quot;size&quot;),                (Gauge&lt;Integer&gt;) () -&gt; cache.size()```</span><br><span class=\"line\"></span><br><span class=\"line\">这样`Metrics`就会一直监控`Cache`的大小。</span><br><span class=\"line\"></span><br><span class=\"line\">除此之外有时候，我们需要计算自己定义的一直单位，比如消息队列里面**消费者(consumers)**消费的**速率**和**生产者(producers)**的生产**速率**的比例，这也是一个度量。</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">public class CompareRatio extends RatioGauge &#123;private final Meter consumers;private final Meter producers;    public CacheHitRatio(Meter consumers, Meter producers) &#123;this.consumers = consumers;this.producers = producers;protected Ratio getRatio() &#123;return Ratio.of(consumers.getOneMinuteRate(),                producers.getOneMinuteRate());```</span><br><span class=\"line\"></span><br><span class=\"line\">把这个类也注册到`Metrics`容器里面：</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">public CompareRatio cacheHitRatio(MetricRegistry metrics, Meter requestMeter, Meter producers) &#123;    CompareRatio compareRatio = new CompareRatio(consumers, producers);    metrics.register(&quot;生产者消费者比率&quot;, compareRatio);```</span><br><span class=\"line\"></span><br><span class=\"line\">三、Reporter 报表</span><br><span class=\"line\">-------------</span><br><span class=\"line\"></span><br><span class=\"line\">`Metrics`通过报表，将采集的数据展现到不同的位置,这里比如我们注册一个`ConsoleReporter`到`MetricRegistry`中，那么console中就会打印出对应的信息。</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">public ConsoleReporter consoleReporter(MetricRegistry metrics) &#123;return ConsoleReporter.forRegistry(metrics).convertRatesTo(TimeUnit.SECONDS).convertDurationsTo(TimeUnit.MILLISECONDS)```</span><br><span class=\"line\"></span><br><span class=\"line\">除此之外`Metrics`还支持`JMX`、`HTTP`、`Slf4j`等等，可以访问 [http://metrics.dropwizard.io/3.1.0/manual/core/#reporters](https://link.jianshu.com/?t=http://metrics.dropwizard.io/3.1.0/manual/core/#reporters) 来查看`Metrics`提供的报表，如果还是不能满足自己的业务，也可以自己继承`Metrics`提供的`ScheduledReporter`类完成自定义的报表类。</span><br><span class=\"line\"></span><br><span class=\"line\">四、完整的代码</span><br><span class=\"line\">-------</span><br><span class=\"line\"></span><br><span class=\"line\">这个demo是在一个很简单的spring boot下运行的，关键的几个类完整代码如下。</span><br><span class=\"line\"></span><br><span class=\"line\">配置类`MetricConfig.java`</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">package demo.metrics.config;import com.codahale.metrics.*;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.concurrent.TimeUnit;public class MetricConfig &#123;public MetricRegistry metrics() &#123;return new MetricRegistry();public ConsoleReporter consoleReporter(MetricRegistry metrics) &#123;return ConsoleReporter.forRegistry(metrics)                .convertRatesTo(TimeUnit.SECONDS)                .convertDurationsTo(TimeUnit.MILLISECONDS)public Slf4jReporter slf4jReporter(MetricRegistry metrics) &#123;return Slf4jReporter.forRegistry(metrics)                .outputTo(LoggerFactory.getLogger(&quot;demo.metrics&quot;))                .convertRatesTo(TimeUnit.SECONDS)                .convertDurationsTo(TimeUnit.MILLISECONDS)public JmxReporter jmxReporter(MetricRegistry metrics) &#123;return JmxReporter.forRegistry(metrics).build();public ListManager listManager(MetricRegistry metrics) &#123;return new ListManager(metrics);public Meter requestMeter(MetricRegistry metrics) &#123;return metrics.meter(&quot;request&quot;);public Histogram responseSizes(MetricRegistry metrics) &#123;return metrics.histogram(&quot;response-sizes&quot;);public Counter pendingJobs(MetricRegistry metrics) &#123;return metrics.counter(&quot;requestCount&quot;);public Timer responses(MetricRegistry metrics) &#123;return metrics.timer(&quot;executeTime&quot;);```</span><br><span class=\"line\"></span><br><span class=\"line\">接收请求的类`MainController.java`</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">package demo.metrics.action;import com.codahale.metrics.Counter;import com.codahale.metrics.Histogram;import com.codahale.metrics.Meter;import com.codahale.metrics.Timer;import demo.metrics.config.ListManager;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;public class MainController &#123;private Meter requestMeter;private Histogram responseSizes;private Counter pendingJobs;private ListManager listManager;@RequestMapping(&quot;/hello&quot;)public String helloWorld() &#123;        responseSizes.update(new Random().nextInt(10));        listManager.getList().add(1);final Timer.Context context = responses.time();```</span><br><span class=\"line\"></span><br><span class=\"line\">项目启动类`DemoApplication.java`：</span><br><span class=\"line\"></span><br><span class=\"line\">```null</span><br><span class=\"line\">import com.codahale.metrics.ConsoleReporter;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import java.util.concurrent.TimeUnit;public class DemoApplication &#123;public static void main(String[] args) &#123;ApplicationContext ctx = SpringApplication.run(DemoApplication.class, args);        ConsoleReporter reporter = ctx.getBean(ConsoleReporter.class);        reporter.start(1, TimeUnit.SECONDS);``` </span><br><span class=\"line\"> [https://blog.csdn.net/yz18931904/article/details/105612166](https://blog.csdn.net/yz18931904/article/details/105612166)</span><br></pre></td></tr></table></figure>\n","text":"JVM上的实时监控类库-Metrics一、使用 Metrics系统开发到一定的阶段，线上的机器越来越多，就需要一些监控了，除了服务器的监控，业务方面也需要一些监...","permalink":"/post/JAVA/JVM上的实时监控类库-Metrics","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[{"name":"Metrics","slug":"Metrics","count":1,"path":"api/categories/Metrics.json"},{"name":"JAVA","slug":"Metrics/JAVA","count":1,"path":"api/categories/Metrics/JAVA.json"}],"tags":[{"name":"MetricRegistry","slug":"MetricRegistry","count":1,"path":"api/tags/MetricRegistry.json"},{"name":"Histogram","slug":"Histogram","count":1,"path":"api/tags/Histogram.json"},{"name":"Meter","slug":"Meter","count":1,"path":"api/tags/Meter.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM%E4%B8%8A%E7%9A%84%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E7%B1%BB%E5%BA%93-Metrics\"><span class=\"toc-text\">JVM上的实时监控类库-Metrics</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8-Metrics\"><span class=\"toc-text\">一、使用 Metrics</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"ES 操作之批量写-BulkProcessor 原理浅析","uid":"bd22547b0a0201a36c471a9e283ced81","slug":"JAVA/ES 操作之批量写-BulkProcessor 原理浅析","date":"2021-08-05T23:32:23.000Z","updated":"2025-12-05T01:46:14.726Z","comments":true,"path":"api/articles/JAVA/ES 操作之批量写-BulkProcessor 原理浅析.json","keywords":"XuGuangSheng","cover":"/covers/es-bulkprocessor.jpg","text":"ES 操作之批量写-BulkProcessor 原理浅析 BulkProcessor 创建流程 [内部逻辑实现] 123456最近对线上业务进行重构，涉及到ES...","permalink":"/post/JAVA/ES 操作之批量写-BulkProcessor 原理浅析","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"BulkProcessor","slug":"BulkProcessor","count":1,"path":"api/categories/BulkProcessor.json"},{"name":"JAVA","slug":"BulkProcessor/JAVA","count":1,"path":"api/categories/BulkProcessor/JAVA.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"consumer","slug":"consumer","count":2,"path":"api/tags/consumer.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CompletableFuture使用","uid":"0b57f40a39dc96ad8c50ffa681e75949","slug":"JAVA/CompletableFuture使用","date":"2021-08-04T23:08:01.000Z","updated":"2025-12-05T01:46:12.141Z","comments":true,"path":"api/articles/JAVA/CompletableFuture使用.json","keywords":"XuGuangSheng","cover":"/covers/completablefuture.jpg","text":"使用异步神器CompletableFuture前提概要 在 java8 以前，我们使用 java 的多线程编程, 一般是通过 Runnable 中的 run 方...","permalink":"/post/JAVA/CompletableFuture使用","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"CompletableFuture","slug":"CompletableFuture","count":1,"path":"api/categories/CompletableFuture.json"},{"name":"JAVA","slug":"CompletableFuture/JAVA","count":1,"path":"api/categories/CompletableFuture/JAVA.json"}],"tags":[{"name":"whenComplete","slug":"whenComplete","count":1,"path":"api/tags/whenComplete.json"},{"name":"exceptionally","slug":"exceptionally","count":1,"path":"api/tags/exceptionally.json"},{"name":"handle","slug":"handle","count":1,"path":"api/tags/handle.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}