{"title":"一次完整的JVM堆外内存泄漏故障排查记录","uid":"d1455563815fa1914c63f89b230d2e22","slug":"JAVA/一次完整的JVM堆外内存泄漏故障排查记录","date":"2024-04-03T11:02:02.000Z","updated":"2025-09-30T03:26:23.837Z","comments":true,"path":"api/articles/JAVA/一次完整的JVM堆外内存泄漏故障排查记录.json","keywords":"XuGuangSheng","cover":"/covers/jvm.jpg","content":"<h1 id=\"一次完整的JVM堆外内存泄漏故障排查记录\"><a href=\"#一次完整的JVM堆外内存泄漏故障排查记录\" class=\"headerlink\" title=\"一次完整的JVM堆外内存泄漏故障排查记录\"></a>一次完整的JVM堆外内存泄漏故障排查记录</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>记录一次线上JVM堆外内存泄漏问题的排查过程与思路，其中夹带一些<strong>JVM内存分配机制</strong>以及<strong>常用的JVM问题排查指令和工具分享</strong>，希望对大家有所帮助。</p>\n<p>在整个排查过程中，我也走了不少弯路，但是在文章中我仍然会把完整的思路和想法写出来，当做一次经验教训，给后人参考，文章最后也总结了下内存泄漏问题快速排查的几个原则。</p>\n<p><strong>本文的主要内容：</strong> </p>\n<ul>\n<li>故障描述和排查过程</li>\n<li>故障原因和解决方案分析</li>\n<li>JVM堆内内存和堆外内存分配原理</li>\n<li>常用的进程内存泄漏排查指令和工具介绍和使用</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>文章撰写不易，请大家多多支持我的原创技术公众号：后端技术漫谈</p></blockquote>\n<h2 id=\"故障描述\"><a href=\"#故障描述\" class=\"headerlink\" title=\"故障描述\"></a>故障描述</h2><p>8月12日中午午休时间，我们商业服务收到告警，服务进程占用容器的物理内存（16G）超过了80%的阈值，并且还在不断上升。</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435041985-image.png\"></p>\n<p>监控系统调出图表查看：</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435048057-image.png\"></p>\n<p>像是Java进程发生了内存泄漏，而我们堆内存的限制是4G，这种大于4G快要吃满内存应该是JVM堆外内存泄漏。</p>\n<p>确认了下当时服务进程的启动配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms4g -Xmx4g -Xmn2g -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=80</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>虽然当天没有上线新代码，但是<strong>当天上午我们正在使用消息队列推送历史数据的修复脚本，该任务会大量调用我们服务其中的某一个接口</strong>，所以初步怀疑和该接口有关。</p>\n<p>下图是该调用接口当天的访问量变化：</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435062131-image.png\"></p>\n<p>可以看到案发当时调用量相比正常情况（每分钟200+次）提高了很多（每分钟5000+次）。</p>\n<p><strong>我们暂时让脚本停止发送消息，该接口调用量下降到每分钟200+次，容器内存不再以极高斜率上升，一切似乎恢复了正常。</strong> </p>\n<p>接下来排查这个接口是不是发生了内存泄漏。</p>\n<h2 id=\"排查过程\"><a href=\"#排查过程\" class=\"headerlink\" title=\"排查过程\"></a>排查过程</h2><p>首先我们先回顾下Java进程的内存分配，方便我们下面排查思路的阐述。</p>\n<p><strong>以我们线上使用的JDK1.8版本为例</strong>。JVM内存分配网上有许多<a href=\"https://www.cnblogs.com/duanxz/p/3520829.html\">总结</a>，我就不再进行二次创作。</p>\n<p>JVM内存区域的划分为两块：堆区和非堆区。</p>\n<ul>\n<li>堆区：就是我们熟知的新生代老年代。</li>\n<li>非堆区：非堆区如图中所示，有元数据区和直接内存。</li>\n</ul>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435068322-image.png\"></p>\n<p><strong>这里需要额外注意的是：永久代（JDK8的原生去）存放JVM运行时使用的类，永久代的对象在full GC时进行垃圾收集。</strong> </p>\n<p>复习完了JVM的内存分配，让我们回到故障上来。</p>\n<h3 id=\"堆内存分析\"><a href=\"#堆内存分析\" class=\"headerlink\" title=\"堆内存分析\"></a>堆内存分析</h3><p>虽说一开始就基本确认与堆内存无关，因为泄露的内存占用超过了堆内存限制4G，但是我们为了保险起见先看下堆内存有什么线索。</p>\n<p>我们观察了新生代和老年代内存占用曲线以及回收次数统计，和往常一样没有大问题，我们接着在事故现场的容器上dump了一份JVM堆内存的日志。</p>\n<h4 id=\"堆内存Dump\"><a href=\"#堆内存Dump\" class=\"headerlink\" title=\"堆内存Dump\"></a>堆内存Dump</h4><p>堆内存快照dump命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -dump:live,format=b,file=xxxx.hprof pid</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>画外音：你也可以使用jmap -histo:live pid直接查看堆内存存活的对象。</p></blockquote>\n<p>导出后，将Dump文件下载回本地，然后可以使用Eclipse的MAT（Memory Analyzer）或者JDK自带的JVisualVM打开日志文件。</p>\n<p>使用MAT打开文件如图所示：</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435074818-image.png\"></p>\n<p><strong>可以看到堆内存中，有一些nio有关的大对象，比如正在接收消息队列消息的nioChannel，还有nio.HeapByteBuffer，但是数量不多，不能作为判断的依据，先放着观察下。</strong> </p>\n<p>下一步，我开始浏览该接口代码，接口内部主要逻辑是调用集团的WCS客户端，将数据库表中数据查表后写入WCS，没有其他额外逻辑</p>\n<p>发觉没有什么特殊逻辑后，我开始怀疑WCS客户端封装是否存在内存泄漏，这样怀疑的理由是，WCS客户端底层是由SCF客户端封装的，作为RPC框架，其底层通讯传输协议有可能会申请直接内存。</p>\n<p><strong>是不是我的代码出发了WCS客户端的Bug，导致不断地申请直接内存的调用，最终吃满内存。</strong> </p>\n<p>我联系上了WCS的值班人，将我们遇到的问题和他们描述了一下，他们回复我们，会在他们本地执行下写入操作的压测，看看能不能复现我们的问题。</p>\n<p>既然等待他们的反馈还需要时间，我们就准备先自己琢磨下原因。</p>\n<p><strong>我将怀疑的目光停留在了直接内存上，怀疑是由于接口调用量过大，客户端对nio使用不当，导致使用ByteBuffer申请过多的直接内存。</strong> </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>画外音：最终的结果证明，这一个先入为主的思路导致排查过程走了弯路。在问题的排查过程中，用合理的猜测来缩小排查范围是可以的，但最好先把每种可能性都列清楚，在发现自己深入某个可能性无果时，要及时回头仔细审视其他可能性。</strong> </p></blockquote>\n<h3 id=\"沙箱环境复现\"><a href=\"#沙箱环境复现\" class=\"headerlink\" title=\"沙箱环境复现\"></a>沙箱环境复现</h3><p>为了能还原当时的故障场景，我在沙箱环境申请了一台压测机器，来确保和线上环境一致。</p>\n<p><strong>首先我们先模拟内存溢出的情况（大量调用接口）：</strong> </p>\n<p>我们让脚本继续推送数据，调用我们的接口，我们持续观察内存占用。</p>\n<p>当开始调用后，内存便开始持续增长，并且看起来没有被限制住（没有因为限制触发Full GC）。</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435095529-image.png\"></p>\n<p><strong>接着我们来模拟下平时正常调用量的情况（正常量调用接口）：</strong> </p>\n<p>我们将该接口平时正常的调用量（比较小，且每10分钟进行一次批量调用）切到该压测机器上，得到了下图这样的老生代内存和物理内存趋势：</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435101147-image.png\"></p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435105945-image.png\"></p>\n<p><strong>问题来了：为何内存会不断往上走吃满内存呢？</strong></p>\n<p>当时猜测是由于JVM进程并没有对于直接内存大小进行限制（-XX:MaxDirectMemorySize），所以堆外内存不断上涨，并不会触发FullGC操作。</p>\n<p><strong>上图能够得出两个结论：</strong> </p>\n<ul>\n<li>在内存泄露的接口调用量很大的时候，如果恰好堆内老生代等其他情况一直不满足FullGC条件，就一直不会FullGC，直接内存一路上涨。</li>\n<li>而在平时低调用量的情况下， 内存泄漏的比较慢，FullGC总会到来，回收掉泄露的那部分，这也是平时没有出问题，正常运行了很久的原因。</li>\n</ul>\n<p><strong>由于上面提到，我们进程的启动参数中并没有限制直接内存，于是我们将-XX:MaxDirectMemorySize配置加上，再次在沙箱环境进行了测验。</strong> </p>\n<p>结果发现，进程占用的物理内存依然会不断上涨，超出了我们设置的限制，“看上去”配置似乎没起作用。</p>\n<p>这让我很讶异，难道JVM对内存的限制出现了问题？</p>\n<p><strong>到了这里，能够看出我排查过程中思路执着于直接内存的泄露，一去不复返了。</strong> </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>画外音：我们应该相信JVM对内存的掌握，如果发现参数失效，多从自己身上找原因，看看是不是自己使用参数有误。</strong> </p></blockquote>\n<h3 id=\"直接内存分析\"><a href=\"#直接内存分析\" class=\"headerlink\" title=\"直接内存分析\"></a>直接内存分析</h3><p>为了更进一步的调查清楚直接内存里有什么，我开始对直接内存下手。由于直接内存并不能像堆内存一样，很容易的看出所有占用的对象，我们需要一些命令来对直接内存进行排查，我有用了几种办法，来查看直接内存里到底出现了什么问题。</p>\n<h4 id=\"查看进程内存信息-pmap\"><a href=\"#查看进程内存信息-pmap\" class=\"headerlink\" title=\"查看进程内存信息 pmap\"></a>查看进程内存信息 pmap</h4><p>pmap - report memory map of a process(查看进程的内存映像信息)</p>\n<p>pmap命令用于报告进程的内存映射关系，是Linux调试及运维一个很好的工具。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pmap -x pid 如果需要排序  | sort -n -k3**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>执行后我得到了下面的输出，删减输出如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">..</span><br><span class=\"line\">00007fa2d4000000    8660    8660    8660 rw</span><br><span class=\"line\">00007fa65f12a000    8664    8664    8664 rw</span><br><span class=\"line\">00007fa610000000    9840    9832    9832 rw</span><br><span class=\"line\">00007fa5f75ff000   10244   10244   10244 rw</span><br><span class=\"line\">00007fa6005fe000   59400   10276   10276 rw</span><br><span class=\"line\">00007fa3f8000000   10468   10468   10468 rw</span><br><span class=\"line\">00007fa60c000000   10480   10480   10480 rw</span><br><span class=\"line\">00007fa614000000   10724   10696   10696 rw</span><br><span class=\"line\">00007fa6e1c59000   13048   11228       0 r-x</span><br><span class=\"line\">00007fa604000000   12140   12016   12016 rw</span><br><span class=\"line\">00007fa654000000   13316   13096   13096 rw</span><br><span class=\"line\">00007fa618000000   16888   16748   16748 rw</span><br><span class=\"line\">00007fa624000000   37504   18756   18756 rw</span><br><span class=\"line\">00007fa62c000000   53220   22368   22368 rw</span><br><span class=\"line\">00007fa630000000   25128   23648   23648 rw</span><br><span class=\"line\">00007fa63c000000   28044   24300   24300 rw</span><br><span class=\"line\">00007fa61c000000   42376   27348   27348 rw</span><br><span class=\"line\">00007fa628000000   29692   27388   27388 rw</span><br><span class=\"line\">00007fa640000000   28016   28016   28016 rw</span><br><span class=\"line\">00007fa620000000   28228   28216   28216 rw</span><br><span class=\"line\">00007fa634000000   36096   30024   30024 rw</span><br><span class=\"line\">00007fa638000000   65516   40128   40128 rw</span><br><span class=\"line\">00007fa478000000   46280   46240   46240 rw</span><br><span class=\"line\">0000000000f7e000   47980   47856   47856 rw</span><br><span class=\"line\">00007fa67ccf0000   52288   51264   51264 rw</span><br><span class=\"line\">00007fa6dc000000   65512   63264   63264 rw</span><br><span class=\"line\">00007fa6cd000000   71296   68916   68916 rwx</span><br><span class=\"line\">00000006c0000000 4359360 2735484 2735484 rw</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以看出，最下面一行是堆内存的映射，占用4G，其他上面有非常多小的内存占用，不过通过这些信息我们依然看不出问题。</p>\n<h4 id=\"堆外内存跟踪-NativeMemoryTracking\"><a href=\"#堆外内存跟踪-NativeMemoryTracking\" class=\"headerlink\" title=\"堆外内存跟踪 NativeMemoryTracking\"></a>堆外内存跟踪 NativeMemoryTracking</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Native Memory Tracking (NMT) 是Hotspot VM用来分析VM内部内存使用情况的一个功能。我们可以利用jcmd（jdk自带）这个工具来访问NMT的数据。</p></blockquote>\n<p>NMT必须先通过VM启动参数中打开，不过要注意的是，打开NMT会带来5%-10%的性能损耗。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:NativeMemoryTracking=[off | summary | detail]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后运行进程，可以使用下面的命令查看直接内存：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jcmd pid VM.native_memory detail scale=MB &gt; temp.txt</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>得到如图结果：</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435113914-image.png\"></p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435118357-image.png\"></p>\n<p>上图中给我们的信息，都不能很明显的看出问题，至少我当时依然不能通过这几次信息看出问题。</p>\n<p>排查似乎陷入了僵局。</p>\n<h3 id=\"山重水复疑无路\"><a href=\"#山重水复疑无路\" class=\"headerlink\" title=\"山重水复疑无路\"></a>山重水复疑无路</h3><p>在排查陷入停滞的时候，我们得到了来自WCS和SCF方面的回复，<strong>两方都确定了他们的封装没有内存泄漏的存在</strong>，WCS方面没有使用直接内存，而SCF虽然作为底层RPC协议，但是也不会遗留这么明显的内存bug，否则应该线上有很多反馈。</p>\n<h4 id=\"查看JVM内存信息-jmap\"><a href=\"#查看JVM内存信息-jmap\" class=\"headerlink\" title=\"查看JVM内存信息 jmap\"></a>查看JVM内存信息 jmap</h4><p>此时，找不到问题的我再次新开了一个沙箱容器，运行服务进程，然后运行jmap命令，看一看JVM内存的<strong>实际配置</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -heap pid</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>得到结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Attaching to process ID 1474, please wait...</span><br><span class=\"line\">Debugger attached successfully.</span><br><span class=\"line\">Server compiler detected.</span><br><span class=\"line\">JVM version is 25.66-b17</span><br><span class=\"line\"></span><br><span class=\"line\">using parallel threads in the new generation.</span><br><span class=\"line\">using thread-local object allocation.</span><br><span class=\"line\">Concurrent Mark-Sweep GC</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Configuration:</span><br><span class=\"line\">   MinHeapFreeRatio         = 40</span><br><span class=\"line\">   MaxHeapFreeRatio         = 70</span><br><span class=\"line\">   MaxHeapSize              = 4294967296 (4096.0MB)</span><br><span class=\"line\">   NewSize                  = 2147483648 (2048.0MB)</span><br><span class=\"line\">   MaxNewSize               = 2147483648 (2048.0MB)</span><br><span class=\"line\">   OldSize                  = 2147483648 (2048.0MB)</span><br><span class=\"line\">   NewRatio                 = 2</span><br><span class=\"line\">   SurvivorRatio            = 8</span><br><span class=\"line\">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class=\"line\">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class=\"line\">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class=\"line\">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class=\"line\"></span><br><span class=\"line\">Heap Usage:</span><br><span class=\"line\">New Generation (Eden + 1 Survivor Space):</span><br><span class=\"line\">   capacity = 1932787712 (1843.25MB)</span><br><span class=\"line\">   used     = 1698208480 (1619.5378112792969MB)</span><br><span class=\"line\">   free     = 234579232 (223.71218872070312MB)</span><br><span class=\"line\">   87.86316621615607% used</span><br><span class=\"line\">Eden Space:</span><br><span class=\"line\">   capacity = 1718091776 (1638.5MB)</span><br><span class=\"line\">   used     = 1690833680 (1612.504653930664MB)</span><br><span class=\"line\">   free     = 27258096 (25.995346069335938MB)</span><br><span class=\"line\">   98.41346682518548% used</span><br><span class=\"line\">From Space:</span><br><span class=\"line\">   capacity = 214695936 (204.75MB)</span><br><span class=\"line\">   used     = 7374800 (7.0331573486328125MB)</span><br><span class=\"line\">   free     = 207321136 (197.7168426513672MB)</span><br><span class=\"line\">   3.4349974840697497% used</span><br><span class=\"line\">To Space:</span><br><span class=\"line\">   capacity = 214695936 (204.75MB)</span><br><span class=\"line\">   used     = 0 (0.0MB)</span><br><span class=\"line\">   free     = 214695936 (204.75MB)</span><br><span class=\"line\">   0.0% used</span><br><span class=\"line\">concurrent mark-sweep generation:</span><br><span class=\"line\">   capacity = 2147483648 (2048.0MB)</span><br><span class=\"line\">   used     = 322602776 (307.6579818725586MB)</span><br><span class=\"line\">   free     = 1824880872 (1740.3420181274414MB)</span><br><span class=\"line\">   15.022362396121025% used</span><br><span class=\"line\"></span><br><span class=\"line\">29425 interned Strings occupying 3202824 bytes</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出的信息中，看得出老年代和新生代都蛮正常的，元空间也只占用了20M，直接内存看起来也是2g…</p>\n<p>嗯？为什么<code>MaxMetaspaceSize = 17592186044415 MB</code>？<strong>看起来就和没限制一样</strong>。</p>\n<p>再仔细看看我们的启动参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms4g -Xmx4g -Xmn2g -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=80</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>配置的是<code>-XX:PermSize=256m -XX:MaxPermSize=512m</code>，也就是永久代的内存空间。<strong>而1.8后，Hotspot虚拟机已经移除了永久代，使用了元空间代替。</strong>  由于我们线上使用的是JDK1.8，<strong>所以我们对于元空间的最大容量根本就没有做限制</strong>，<code>-XX:PermSize=256m -XX:MaxPermSize=512m</code> 这两个参数对于1.8就是过期的参数。</p>\n<p>下面的图描述了从1.7到1.8，永久代的变更：</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435130401-image.png\"></p>\n<p><strong>那会不会是元空间内存泄露了呢？</strong></p>\n<p>我选择了在本地进行测试，方便更改参数，也方便使用JVisualVM工具直观的看出内存变化。</p>\n<h4 id=\"使用JVisualVM观察进程运行\"><a href=\"#使用JVisualVM观察进程运行\" class=\"headerlink\" title=\"使用JVisualVM观察进程运行\"></a>使用JVisualVM观察进程运行</h4><p>首先限制住元空间，使用参数<code>-XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=128m</code>，然后在本地循环调用出问题的接口。</p>\n<p>得到如图：</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435138888-image.png\"></p>\n<p><strong>可以看出，在元空间耗尽时，系统出发了Full GC，元空间内存得到回收，并且卸载了很多类。</strong> </p>\n<p>然后我们将元空间限制去掉，也就是使用之前出问题的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms4g -Xmx4g -Xmn2g -Xss1024K -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=80 -XX:MaxDirectMemorySize=2g -XX:+UnlockDiagnosticVMOptions</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>得到如图：</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435147405-image.png\"></p>\n<p><strong>可以看出，元空间在不断上涨，并且已装入的类随着调用量的增加也在不断上涨，呈现正相关趋势。</strong> </p>\n<h3 id=\"柳暗花明又一村\"><a href=\"#柳暗花明又一村\" class=\"headerlink\" title=\"柳暗花明又一村\"></a>柳暗花明又一村</h3><p>问题一下子明朗了起来，<strong>随着每次接口的调用，极有可能是某个类都在不断的被创建，占用了元空间的内存</strong>。</p>\n<h4 id=\"观察JVM类加载情况-verbose\"><a href=\"#观察JVM类加载情况-verbose\" class=\"headerlink\" title=\"观察JVM类加载情况 -verbose\"></a>观察JVM类加载情况 -verbose</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在调试程序时，有时需要查看程序加载的类、内存回收情况、调用的本地接口等。这时候就需要-verbose命令。在myeclipse可以通过右键设置（如下），也可以在命令行输入java -verbose来查看。</p></blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-verbose:class 查看类加载情况</span><br><span class=\"line\">-verbose:gc 查看虚拟机中内存回收情况</span><br><span class=\"line\">-verbose:jni 查看本地方法调用的情况</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们在本地环境，添加启动参数<code>-verbose:class</code>循环调用接口。</p>\n<p>可以看到生成了无数<code>com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar]</span><br><span class=\"line\">[Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar]</span><br><span class=\"line\">[Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar]</span><br><span class=\"line\">[Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar]</span><br><span class=\"line\">[Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar]</span><br><span class=\"line\">[Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当调用了很多次，积攒了一定的类时，我们手动执行Full GC，进行类加载器的回收，我们发现大量的fastjson相关类被回收。</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435156669-image.png\"></p>\n<p><strong>如果在回收前，使用jmap查看类加载情况，同样也可以发现大量的fastjson相关类：</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -clstats 7984</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435164177-image.png\"></p>\n<p>这下有了方向，<strong>这次仔细排查代码</strong>，查看代码逻辑里哪里用到了fastjson，发现了如下代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public static String buildData(Object bean) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        SerializeConfig CONFIG = new SerializeConfig();</span><br><span class=\"line\">        CONFIG.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;</span><br><span class=\"line\">        return jsonString = JSON.toJSONString(bean, CONFIG);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题根因\"><a href=\"#问题根因\" class=\"headerlink\" title=\"问题根因\"></a>问题根因</h3><p>我们在调用wcs前将驼峰字段的实体类序列化成下划线字段，**这需要使用fastjson的SerializeConfig，而我们在静态方法中对其进行了实例化。SerializeConfig创建时默认会创建一个ASM代理类用来实现对目标对象的序列化。也就是上面被频繁创建的类<code>com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto</code>,如果我们复用SerializeConfig，fastjson会去寻找已经创建的代理类，从而复用。但是如果new SerializeConfig()，则找不到原来生成的代理类，就会一直去生成新的WlkCustomerDto代理类。</p>\n<p>下面两张图时问题定位的源码：</p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435173317-image.png\"></p>\n<p><img src=\"https://gitee.com/qqxx6661/markdown-pic/raw/master/2020-8-26/1598435178820-image.png\"></p>\n<p>我们将SerializeConfig作为类的静态变量，问题得到了解决。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final SerializeConfig CONFIG = new SerializeConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">static &#123;</span><br><span class=\"line\">    CONFIG.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"fastjson-SerializeConfig-做了什么\"><a href=\"#fastjson-SerializeConfig-做了什么\" class=\"headerlink\" title=\"fastjson SerializeConfig 做了什么\"></a>fastjson SerializeConfig 做了什么</h4><p>SerializeConfig介绍：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>SerializeConfig的主要功能是配置并记录每种Java类型对应的序列化类（ObjectSerializer接口的实现类），比如Boolean.class使用BooleanCodec（看命名就知道该类将序列化和反序列化实现写到一起了）作为序列化实现类，float[].class使用FloatArraySerializer作为序列化实现类。这些序列化实现类，有的是FastJSON中默认实现的（比如Java基本类），有的是通过ASM框架生成的（比如用户自定义类），有的甚至是用户自定义的序列化类（比如Date类型框架默认实现是转为毫秒，应用需要转为秒）。当然，这就涉及到是使用ASM生成序列化类还是使用JavaBean的序列化类类序列化的问题，这里判断根据就是是否Android环境（环境变量”java.vm.name”为”dalvik”或”lemur”就是Android环境），但判断不仅这里一处，后续还有更具体的判断。</p></blockquote>\n<p>理论上来说，每个SerializeConfig实例若序列化相同的类，都会找到之前生成的该类的代理类，来进行序列化。们的服务在每次接口被调用时，都实例化一个ParseConfig对象来配置Fastjson反序列的设置，而未禁用ASM代理的情况下，由于每次调用ParseConfig都是一个新的实例，因此永远也检查不到已经创建的代理类，所以Fastjson便不断的创建新的代理类，并加载到metaspace中，最终导致metaspace不断扩张，将机器的内存耗尽。</p>\n<h4 id=\"升级JDK1-8才会出现问题\"><a href=\"#升级JDK1-8才会出现问题\" class=\"headerlink\" title=\"升级JDK1.8才会出现问题\"></a>升级JDK1.8才会出现问题</h4><p>导致问题发生的原因还是值得重视。为什么在升级之前不会出现这个问题？这就要分析jdk1.8和1.7自带的hotspot虚拟机的差异了。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>从jdk1.8开始，自带的hostspot虚拟机取消了过去的永久区，而新增了metaspace区，从功能上看，metaspace可以认为和永久区类似，其最主要的功用也是存放类元数据，但实际的机制则有较大的不同。</p>\n<p>首先，metaspace默认的最大值是整个机器的物理内存大小，所以metaspace不断扩张会导致java程序侵占系统可用内存，最终系统没有可用的内存；而永久区则有固定的默认大小，不会扩张到整个机器的可用内存。当分配的内存耗尽时，两者均会触发full gc，但不同的是永久区在full gc时，以堆内存回收时类似的机制去回收永久区中的类元数据（Class对象），只要是根引用无法到达的对象就可以回收掉，而metaspace判断类元数据是否可以回收，是根据加载这些类元数据的Classloader是否可以回收来判断的，只要Classloader不能回收，通过其加载的类元数据就不会被回收。这也就解释了我们这两个服务为什么在升级到1.8之后才出现问题，因为在之前的jdk版本中，虽然每次调用fastjson都创建了很多代理类，在永久区中加载类很多代理类的Class实例，但这些Class实例都是在方法调用是创建的，调用完成之后就不可达了，因此永久区内存满了触发full gc时，都会被回收掉。</p>\n<p>而使用1.8时，因为这些代理类都是通过主线程的Classloader加载的，这个Classloader在程序运行的过程中永远也不会被回收，因此通过其加载的这些代理类也永远不会被回收，这就导致metaspace不断扩张，最终耗尽机器的内存了。</p></blockquote>\n<p>这个问题并不局限于fastjson，只要是需要通过程序加载创建类的地方，就有可能出现这种问题。<strong>尤其是在框架中，往往大量采用类似ASM、javassist等工具进行字节码增强，而根据上面的分析，在jdk1.8之前，因为大多数情况下动态加载的Class都能够在full gc时得到回收，因此不容易出现问题</strong>，也因此很多框架、工具包并没有针对这个问题做一些处理，一旦升级到1.8之后，这些问题就可能会暴露出来。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>问题解决了，接下来复盘下整个排查问题的流程，整个流程暴露了我很多问题，最主要的就是<strong>对于JVM不同版本的内存分配还不够熟悉</strong>，导致了对于老生代和元空间判断失误，走了很多弯路，在直接内存中排查了很久，浪费了很多时间。</p>\n<p>其次，排查需要的<strong>一是仔细，二是全面，</strong>，最好将所有可能性先行整理好，不然很容易陷入自己设定好的排查范围内，走进死胡同不出来。</p>\n<p>最后，总结一下这次的问题带来的收获：</p>\n<ul>\n<li>JDK1.8开始，自带的hostspot虚拟机取消了过去的永久区，而新增了metaspace区，从功能上看，metaspace可以认为和永久区类似，其最主要的功用也是存放类元数据，但实际的机制则有较大的不同。</li>\n<li>对于JVM里面的内存需要在启动时进行限制，包括我们熟悉的堆内存，也要包括直接内存和元生区，这是保证线上服务正常运行最后的兜底。</li>\n<li>使用类库，请多注意代码的写法，尽量不要出现明显的内存泄漏。</li>\n<li>对于使用了ASM等字节码增强工具的类库，在使用他们时请多加小心（尤其是JDK1.8以后）。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>文章撰写不易，请大家多多支持我的原创技术公众号：后端技术漫谈</p></blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>观察程序运行时类加载的过程</p>\n<p>blog.csdn.net&#x2F;tenderhearted&#x2F;article&#x2F;details&#x2F;39642275</p>\n<p>Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法）</p>\n<p><a href=\"https://www.cnblogs.com/duanxz/p/3520829.html\">https://www.cnblogs.com/duanxz/p/3520829.html</a></p>\n<p>java内存占用异常问题常见排查流程（含堆外内存异常）</p>\n<p><a href=\"https://my.oschina.net/haitaohu/blog/3024843\">https://my.oschina.net/haitaohu/blog/3024843</a></p>\n<p>JVM源码分析之堆外内存完全解读</p>\n<p><a href=\"http://lovestblog.cn/blog/2015/05/12/direct-buffer/\">http://lovestblog.cn/blog/2015/05/12/direct-buffer/</a></p>\n<p>JVM 类的卸载</p>\n<p><a href=\"https://www.cnblogs.com/caoxb/p/12735525.html\">https://www.cnblogs.com/caoxb/p/12735525.html</a></p>\n<p>fastjson在jdk1.8上面开启asm</p>\n<p><a href=\"https://github.com/alibaba/fastjson/issues/385\">https://github.com/alibaba/fastjson/issues/385</a></p>\n<p>fastjson：PropertyNamingStrategy_cn</p>\n<p><a href=\"https://github.com/alibaba/fastjson/wiki/PropertyNamingStrategy_cn\">https://github.com/alibaba/fastjson/wiki/PropertyNamingStrategy_cn</a></p>\n<p>警惕动态代理导致的Metaspace内存泄漏问题</p>\n<p><a href=\"https://blog.csdn.net/xyghehehehe/article/details/78820135\">https://blog.csdn.net/xyghehehehe/article/details/78820135</a></p>\n","text":"一次完整的JVM堆外内存泄漏故障排查记录前言记录一次线上JVM堆外内存泄漏问题的排查过程与思路，其中夹带一些JVM内存分配机制以及常用的JVM问题排查指令和工具...","permalink":"/post/JAVA/一次完整的JVM堆外内存泄漏故障排查记录","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"https","slug":"https","count":12,"path":"api/categories/https.json"},{"name":"JAVA","slug":"https/JAVA","count":5,"path":"api/categories/https/JAVA.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"gitee","slug":"gitee","count":1,"path":"api/tags/gitee.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84JVM%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95\"><span class=\"toc-text\">一次完整的JVM堆外内存泄漏故障排查记录</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%85%E9%9A%9C%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">故障描述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">排查过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90\"><span class=\"toc-text\">堆内存分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%86%85%E5%AD%98Dump\"><span class=\"toc-text\">堆内存Dump</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B2%99%E7%AE%B1%E7%8E%AF%E5%A2%83%E5%A4%8D%E7%8E%B0\"><span class=\"toc-text\">沙箱环境复现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90\"><span class=\"toc-text\">直接内存分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF-pmap\"><span class=\"toc-text\">查看进程内存信息 pmap</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E8%B7%9F%E8%B8%AA-NativeMemoryTracking\"><span class=\"toc-text\">堆外内存跟踪 NativeMemoryTracking</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%B1%E9%87%8D%E6%B0%B4%E5%A4%8D%E7%96%91%E6%97%A0%E8%B7%AF\"><span class=\"toc-text\">山重水复疑无路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8BJVM%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF-jmap\"><span class=\"toc-text\">查看JVM内存信息 jmap</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8JVisualVM%E8%A7%82%E5%AF%9F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">使用JVisualVM观察进程运行</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%B3%E6%9A%97%E8%8A%B1%E6%98%8E%E5%8F%88%E4%B8%80%E6%9D%91\"><span class=\"toc-text\">柳暗花明又一村</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9FJVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%83%85%E5%86%B5-verbose\"><span class=\"toc-text\">观察JVM类加载情况 -verbose</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%A0%B9%E5%9B%A0\"><span class=\"toc-text\">问题根因</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#fastjson-SerializeConfig-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">fastjson SerializeConfig 做了什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%87%E7%BA%A7JDK1-8%E6%89%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">升级JDK1.8才会出现问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"nginx平滑重启原理","uid":"382d6c325a8d429096616c76d2784a58","slug":"MIDDLEWARE/nginx平滑重启原理","date":"2024-04-26T15:57:42.000Z","updated":"2025-09-30T03:26:53.710Z","comments":true,"path":"api/articles/MIDDLEWARE/nginx平滑重启原理.json","keywords":"XuGuangSheng","cover":"/covers/nginx.jpg","text":"nginx平滑重启原理背景对于一个高并发的网络服务来说，平滑重启功能是必不可少的。试想，如果我们直接kill然后再start一个服务进程，则会导致： 12341...","permalink":"/post/MIDDLEWARE/nginx平滑重启原理","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"worker","slug":"worker","count":1,"path":"api/categories/worker.json"},{"name":"MIDDLEWARE","slug":"worker/MIDDLEWARE","count":1,"path":"api/categories/worker/MIDDLEWARE.json"}],"tags":[{"name":"master","slug":"master","count":3,"path":"api/tags/master.json"},{"name":"nginx","slug":"nginx","count":1,"path":"api/tags/nginx.json"},{"name":"fOxm","slug":"fOxm","count":1,"path":"api/tags/fOxm.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"linux - 深入浅出TCP中的SYN-Cookies","uid":"ba2c98fe76e98638ad19f6c9f02b695c","slug":"LINUX/linux - 深入浅出TCP中的SYN-Cookies","date":"2024-04-03T10:36:59.000Z","updated":"2025-09-30T03:26:37.420Z","comments":true,"path":"api/articles/LINUX/linux - 深入浅出TCP中的SYN-Cookies.json","keywords":"XuGuangSheng","cover":"/covers/linux-tcpsyn-cookies.jpg","text":"linux - 深入浅出TCP中的SYN-Cookies 本文渐进地介绍TCP中的syn-cookie技术，包括其由来、原理、实例测试。 SYN Flood 攻...","permalink":"/post/LINUX/linux - 深入浅出TCP中的SYN-Cookies","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"SYN","slug":"SYN","count":1,"path":"api/categories/SYN.json"},{"name":"LINUX","slug":"SYN/LINUX","count":1,"path":"api/categories/SYN/LINUX.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"Cookies","slug":"Cookies","count":1,"path":"api/tags/Cookies.json"},{"name":"ACK","slug":"ACK","count":2,"path":"api/tags/ACK.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}