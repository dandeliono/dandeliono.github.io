{"title":"Netty ChannelInactive 断链场景分析","uid":"a159c983ebe30de9eaec5108a827bcdd","slug":"JAVA/Netty ChannelInactive 断链场景分析","date":"2024-03-25T16:04:40.000Z","updated":"2025-09-30T03:26:13.974Z","comments":true,"path":"api/articles/JAVA/Netty ChannelInactive 断链场景分析.json","keywords":"XuGuangSheng","cover":"/covers/netty-channelinactive.jpg","content":"<h1 id=\"Netty-ChannelInactive-断链场景分析\"><a href=\"#Netty-ChannelInactive-断链场景分析\" class=\"headerlink\" title=\"Netty ChannelInactive 断链场景分析\"></a>Netty ChannelInactive 断链场景分析</h1><p><em>本文档主要列举离会、关闭进程、断网、重连等会导致sdk与服务端断开连接的场景的设计与实现，并试图解释其原理</em></p>\n<h2 id=\"1-Netty断链场景分析\"><a href=\"#1-Netty断链场景分析\" class=\"headerlink\" title=\"1.Netty断链场景分析\"></a><strong>1.Netty断链场景分析</strong></h2><h4 id=\"1-Netty对断链的处理\"><a href=\"#1-Netty对断链的处理\" class=\"headerlink\" title=\"1. Netty对断链的处理\"></a>1. Netty对断链的处理</h4><p>简单来说Netty在检测到断开连接的情况下会抛出channelInactive事件（其实准确的说应该是de-register事件），这个事件会在pipeline的Handler中被传递和被处理，当然也可以选择不往下传递，即不调用fireChannelInactive()，对pipeline和handler处理事件等原理有兴趣可以看一下《netty in action》第16章，这里我们就重点关注哪些场景会触发channelInactive  </p>\n<h4 id=\"2-ChannelInactive触发场景\"><a href=\"#2-ChannelInactive触发场景\" class=\"headerlink\" title=\"2. ChannelInactive触发场景\"></a>2. ChannelInactive触发场景</h4><ul>\n<li>客户端发送close帧（FIN包）</li>\n<li>客户端关闭进程（RST包）</li>\n<li>服务端或客户端主动调用channel.close()</li>\n</ul>\n<p>以上为使用Netty官方示例测试得出的场景，需要注意的是直接断网并不会触发channelInactive，原因大概是由于直接断开网络并没有发送<a href=\"https://so.csdn.net/so/search?q=fin&spm=1001.2101.3001.7020\">fin</a>包，netty无法感知当前连接的存活状态，当然我们可以通过心跳超时来处理这种情况</p>\n<p>另外心跳超时的情况也需要额外说明一下，在pipeline中添加IdleHandler可以配置一个自定义的心跳超时策略，例如我的服务中配置的是35s无新消息，当无新消息写入时，抛出一个心跳超时时间；但是心跳超时事件本身如果不去捕获netty是不会去做额外处理的，所以我的服务会在pipeline后面的heartbeatHandler中捕获心跳超时事件并主动关闭channel（对应上述第三种断链场景）</p>\n<h4 id=\"3-EventLoopGroup\"><a href=\"#3-EventLoopGroup\" class=\"headerlink\" title=\"3. EventLoopGroup\"></a>3. EventLoopGroup</h4><p>顺带提一下Netty的线程处理模型，Netty主要分为两个线程的group，bossGroup和workerGroup，可以当成两个线程池，其中bossGroup一般只有一个线程，用来处理新连接的请求，而连接具体的IO和业务操作则放在workerGroup中完成。一般workerGroup中包含多个EventLoop（一个EventLoop可以理解成一个线程或者nio中的selector），多个channel可以注册到同一个EventLoop上，而对一个channel的处理从头至尾只会由同一个EventLoop来完成，想了解更多关于EventLoopGroup的细节也可以看下《netty in action》前几章的内容。这里提线程处理模型的原因主要是想说明，即使当客户端突然断开连接，netty也不会终止对前几个消息的处理，而是会等待前面的消息处理完再处理关闭事件，因为虽然netty是一个异步的框架，但是同一个channel的操作都是在同一个线程上顺序执行的</p>\n<h2 id=\"2-直接关闭客户端的场景\"><a href=\"#2-直接关闭客户端的场景\" class=\"headerlink\" title=\"2.直接关闭客户端的场景\"></a><strong>2.直接关闭客户端的场景</strong></h2><p>当客户端直接关闭&#x2F;结束进程时，抓包信息如下</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.164.184.68    100.94.8.71       TCP    54    53435 → 80 [FIN, ACK] Seq=1 Ack=1 Win=1022 Len=0100.94.8.71       10.164.184.68    TCP    60    80 → 53435 [FIN, ACK] Seq=1 Ack=2 Win=103 Len=010.164.184.68    100.94.8.71       TCP    54    53435 → 80 [ACK] Seq=2 Ack=2 Win=1022 Len=0</span><br></pre></td></tr></table></figure>\n\n<p>可以看到客户端主动发送了fin包，服务端会调用WsSubscribeHandler的channelInactive，触发一个自定义的channelInactiveEvent事件，之后主要执行bye和evict方法，其中bye主要是向mcs发送leaveRoom请求，evict主要是删除acs的相关缓存，这是断链场景下最简单的一个流程</p>\n","text":"Netty ChannelInactive 断链场景分析本文档主要列举离会、关闭进程、断网、重连等会导致sdk与服务端断开连接的场景的设计与实现，并试图解释其原...","permalink":"/post/JAVA/Netty ChannelInactive 断链场景分析","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Netty","slug":"Netty","count":1,"path":"api/categories/Netty.json"},{"name":"JAVA","slug":"Netty/JAVA","count":1,"path":"api/categories/Netty/JAVA.json"}],"tags":[{"name":"netty","slug":"netty","count":1,"path":"api/tags/netty.json"},{"name":"channel","slug":"channel","count":1,"path":"api/tags/channel.json"},{"name":"channelInactive","slug":"channelInactive","count":1,"path":"api/tags/channelInactive.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Netty-ChannelInactive-%E6%96%AD%E9%93%BE%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90\"><span class=\"toc-text\">Netty ChannelInactive 断链场景分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Netty%E6%96%AD%E9%93%BE%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90\"><span class=\"toc-text\">1.Netty断链场景分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Netty%E5%AF%B9%E6%96%AD%E9%93%BE%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1. Netty对断链的处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-ChannelInactive%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2. ChannelInactive触发场景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-EventLoopGroup\"><span class=\"toc-text\">3. EventLoopGroup</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">2.直接关闭客户端的场景</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"ConditionalOnMissingBean失效问题追踪","uid":"81d9f9cbb43ffb5d74b9291c7102db6e","slug":"JAVA/ConditionalOnMissingBean失效问题追踪","date":"2024-04-01T18:25:44.000Z","updated":"2025-09-30T03:26:09.106Z","comments":true,"path":"api/articles/JAVA/ConditionalOnMissingBean失效问题追踪.json","keywords":"XuGuangSheng","cover":"/covers/conditionalonmissingbean.jpg","text":"ConditionalOnMissingBean失效问题追踪遇到一个@ConditionalOnMissingBean失效的问题，今天花点时间来分析一下。 现场...","permalink":"/post/JAVA/ConditionalOnMissingBean失效问题追踪","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"bean","slug":"bean","count":2,"path":"api/categories/bean.json"},{"name":"JAVA","slug":"bean/JAVA","count":2,"path":"api/categories/bean/JAVA.json"}],"tags":[{"name":"ConditionalOnMissingBean","slug":"ConditionalOnMissingBean","count":1,"path":"api/tags/ConditionalOnMissingBean.json"},{"name":"Configuration","slug":"Configuration","count":1,"path":"api/tags/Configuration.json"},{"name":"RunService","slug":"RunService","count":1,"path":"api/tags/RunService.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"直观感受 TLS 握手流程(下)","uid":"6097fb5f130a2c4c51fe513482d1af88","slug":"NETWORK/直观感受 TLS 握手流程(下)","date":"2024-03-08T10:08:28.000Z","updated":"2025-09-30T03:26:56.680Z","comments":true,"path":"api/articles/NETWORK/直观感受 TLS 握手流程(下).json","keywords":"XuGuangSheng","cover":"/covers/tls.jpg","text":"直观感受 TLS 握手流程(下)在 HTTPS 开篇的文章中，笔者分析了 HTTPS 之所以安全的原因是因为 TLS 协议的存在。TLS 能保证信息安全和完整性...","permalink":"/post/NETWORK/直观感受 TLS 握手流程(下)","photos":[],"count_time":{"symbolsCount":"44k","symbolsTime":"40 mins."},"categories":[{"name":"TLS","slug":"TLS","count":1,"path":"api/categories/TLS.json"},{"name":"NETWORK","slug":"TLS/NETWORK","count":1,"path":"api/categories/TLS/NETWORK.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"RTT","slug":"RTT","count":1,"path":"api/tags/RTT.json"},{"name":"PSK","slug":"PSK","count":1,"path":"api/tags/PSK.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}