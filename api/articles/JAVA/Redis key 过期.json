{"title":"Redis key 过期","uid":"6080594d045265903c518febf773294c","slug":"JAVA/Redis key 过期","date":"2021-08-26T18:26:40.000Z","updated":"2025-12-05T01:46:27.924Z","comments":true,"path":"api/articles/JAVA/Redis key 过期.json","keywords":"XuGuangSheng","cover":"/covers/redis-key.jpg","content":"<h1 id=\"Redis-key-过期\"><a href=\"#Redis-key-过期\" class=\"headerlink\" title=\"Redis key 过期\"></a>Redis key 过期</h1><h2 id=\"Keys-with-an-expire-有过期的-key\"><a href=\"#Keys-with-an-expire-有过期的-key\" class=\"headerlink\" title=\"*Keys with an expire 有过期的 key\"></a><a href=\"#keys-with-an-expire\">*</a>Keys with an expire 有过期的 key</h2><p>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the <a href=\"https://redis.io/commands/del\">DEL</a> command.</p>\n<p>通常，Redis 键是在没有相关生存时间的情况下创建的。密钥将永远存在，除非用户以显式的方式删除它，例如使用 DEL 命令。</p>\n<p>The <a href=\"https://redis.io/commands/expire\">EXPIRE</a> family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</p>\n<p>终止命令系列能够将终止期限关联到给定的密钥，代价是该密钥所使用的一些额外内存。如果密钥设置了过期设置，Redis 将确保在指定的时间过期时删除密钥。</p>\n<p>The key time to live can be updated or entirely removed using the <a href=\"https://redis.io/commands/expire\">EXPIRE</a> and <a href=\"https://redis.io/commands/persist\">PERSIST</a> command (or other strictly related commands).</p>\n<p>可以使用 EXPIRE 和 PERSIST 命令 (或其他严格相关的命令) 更新或完全删除关键存活时间。</p>\n<h2 id=\"Expire-accuracy-过期精度\"><a href=\"#Expire-accuracy-过期精度\" class=\"headerlink\" title=\"*Expire accuracy 过期精度\"></a><a href=\"#expire-accuracy\">*</a>Expire accuracy 过期精度</h2><p>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</p>\n<p>在 Redis 2.4 中，过期值可能不精确，而且可能在 0 到 1 秒之间。</p>\n<p>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</p>\n<p>由于 Redis 2.6，过期错误从 0 毫秒到 1 毫秒。</p>\n<h2 id=\"Expires-and-persistence-过期和持久性\"><a href=\"#Expires-and-persistence-过期和持久性\" class=\"headerlink\" title=\"*Expires and persistence 过期和持久性\"></a><a href=\"#expires-and-persistence\">*</a>Expires and persistence 过期和持久性</h2><p>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</p>\n<p>到期的键信息以绝对 Unix 时间戳的形式存储 (在 Redis 2.6 或更大版本中，以毫秒为单位)。这意味着即使 Redis 实例不活动，时间也是流动的。</p>\n<p>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</p>\n<p>为了使计算机正常工作，计算机时间必须稳定。如果您将 RDB 文件从两台计算机的时钟中带有大的 desync 的计算机中移动，可能会发生有趣的事情 (比如加载时加载的所有密钥都过期了)。</p>\n<p>Even running instances will always check the computer clock, so for instance if you set a key with a time to live of 1000 seconds, and then set your computer time 2000 seconds in the future, the key will be expired immediately, instead of lasting for 1000 seconds.</p>\n<p>即使是正在运行的实例也总是会检查计算机时钟，所以举例来说，如果你设置一个时间为 1000 秒的密钥，然后在未来设置你的计算机时间为 2000 秒，这个密钥将立即过期，而不是持续 1000 秒。</p>\n<h2 id=\"How-Redis-expires-keys-如何-Redis-过期键\"><a href=\"#How-Redis-expires-keys-如何-Redis-过期键\" class=\"headerlink\" title=\"*How Redis expires keys 如何 Redis 过期键\"></a><a href=\"#how-redis-expires-keys\">*</a>How Redis expires keys 如何 Redis 过期键</h2><p>Redis keys are expired in two ways: a passive way, and an active way.</p>\n<p>Redis 密钥有两种过期方式: 被动过期和主动过期。</p>\n<p>A key is passively expired simply when some client tries to access it, and the key is found to be timed out.</p>\n<p>当某个客户端试图访问密钥时，密钥被动地过期，并且发现密钥已超时。</p>\n<p>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</p>\n<p>当然，这是不够的，因为有过期的密钥将永远不会再次访问。这些密钥无论如何都应该过期，所以 Redis 会定期在具有过期设置的密钥之间随机测试一些密钥。所有已过期的密钥都将从密钥空间中删除。</p>\n<p>Specifically this is what Redis does 10 times per second:</p>\n<p>具体来说，这就是 Redis 每秒钟做的 10 次:</p>\n<ol>\n<li>Test 20 random keys from the set of keys with an associated expire. 测试来自带有关联过期值的键集合的 20 个随机键</li>\n<li>Delete all the keys found expired. 删除所有过期的密钥</li>\n<li>If more than 25% of keys were expired, start again from step 1. 如果超过 25% 的密钥过期，从第一步开始重新启动</li>\n</ol>\n<p>This is a trivial probabilistic algorithm, basically the assumption is that our sample is representative of the whole key space, and we continue to expire until the percentage of keys that are likely to be expired is under 25%</p>\n<p>这是一个简单的概率算法，基本上假设我们的样本代表了整个键空间，我们继续过期，直到可能过期的键的百分比低于 25%</p>\n<p>This means that at any given moment the maximum amount of keys already expired that are using memory is at max equal to max amount of write operations per second divided by 4.</p>\n<p>这意味着在任何给定时刻，正在使用内存的已过期键的最大数量等于每秒写操作的最大数量除以 4。</p>\n<h2 id=\"How-expires-are-handled-in-the-replication-link-and-AOF-file-在复制链接和-AOF-文件中如何处理过期\"><a href=\"#How-expires-are-handled-in-the-replication-link-and-AOF-file-在复制链接和-AOF-文件中如何处理过期\" class=\"headerlink\" title=\"*How expires are handled in the replication link and AOF file 在复制链接和 AOF 文件中如何处理过期\"></a><a href=\"#how-expires-are-handled-in-the-replication-link-and-aof-file\">*</a>How expires are handled in the replication link and AOF file 在复制链接和 AOF 文件中如何处理过期</h2><p>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a <a href=\"https://redis.io/commands/del\">DEL</a> operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</p>\n<p>为了在不牺牲一致性的情况下获得正确的行为，当一个密钥失效时，在 AOF 文件中合成一个 DEL 操作，并获得所有附加的副本节点。通过这种方式，过期过程集中在主实例中，不会出现一致性错误。</p>\n<p>However while the replicas connected to a master will not expire keys independently (but will wait for the <a href=\"https://redis.io/commands/del\">DEL</a> coming from the master), they’ll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</p>\n<p>然而，虽然连接到主控制器的副本不会独立地过期密钥 (但是会等待主控制器发出 DEL) ，但是它们仍然会接受数据集中已经存在的过期的完整状态，因此当一个副本被选择为主控制器时，它将能够独立地过期密钥，充当主控制器。<br> <a href=\"https://redis.io/commands/expire#how-redis-expires-keys\">https://redis.io/commands/expire#how-redis-expires-keys</a></p>\n","text":"Redis key 过期*Keys with an expire 有过期的 keyNormally Redis keys are created without...","permalink":"/post/JAVA/Redis key 过期","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"the","slug":"the","count":2,"path":"api/categories/the.json"},{"name":"JAVA","slug":"the/JAVA","count":1,"path":"api/categories/the/JAVA.json"}],"tags":[{"name":"Redis","slug":"Redis","count":3,"path":"api/tags/Redis.json"},{"name":"keys","slug":"keys","count":1,"path":"api/tags/keys.json"},{"name":"expire","slug":"expire","count":1,"path":"api/tags/expire.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Redis-key-%E8%BF%87%E6%9C%9F\"><span class=\"toc-text\">Redis key 过期</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Keys-with-an-expire-%E6%9C%89%E8%BF%87%E6%9C%9F%E7%9A%84-key\"><span class=\"toc-text\">Keys with an expire 有过期的 key</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Expire-accuracy-%E8%BF%87%E6%9C%9F%E7%B2%BE%E5%BA%A6\"><span class=\"toc-text\">Expire accuracy 过期精度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Expires-and-persistence-%E8%BF%87%E6%9C%9F%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7\"><span class=\"toc-text\">Expires and persistence 过期和持久性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-Redis-expires-keys-%E5%A6%82%E4%BD%95-Redis-%E8%BF%87%E6%9C%9F%E9%94%AE\"><span class=\"toc-text\">How Redis expires keys 如何 Redis 过期键</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-expires-are-handled-in-the-replication-link-and-AOF-file-%E5%9C%A8%E5%A4%8D%E5%88%B6%E9%93%BE%E6%8E%A5%E5%92%8C-AOF-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F\"><span class=\"toc-text\">How expires are handled in the replication link and AOF file 在复制链接和 AOF 文件中如何处理过期</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Linux 设置开机启动项的几种方法","uid":"2f5dd4c8f4fc8dc651e872f7c4bd5927","slug":"LINUX/Linux 设置开机启动项的几种方法","date":"2021-08-30T15:35:09.000Z","updated":"2025-12-05T01:47:02.652Z","comments":true,"path":"api/articles/LINUX/Linux 设置开机启动项的几种方法.json","keywords":"XuGuangSheng","cover":"/covers/linux.jpg","text":"Linux 设置开机启动项的几种方法方法一：编辑 rc.loacl 脚本Ubuntu 开机之后会执行 / etc/rc.local 文件中的脚本。 所以我们可以...","permalink":"/post/LINUX/Linux 设置开机启动项的几种方法","photos":[],"count_time":{"symbolsCount":499,"symbolsTime":"1 mins."},"categories":[{"name":"etc","slug":"etc","count":2,"path":"api/categories/etc.json"},{"name":"LINUX","slug":"etc/LINUX","count":2,"path":"api/categories/etc/LINUX.json"}],"tags":[{"name":"local","slug":"local","count":1,"path":"api/tags/local.json"},{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"设置开机启动项的几种方法","slug":"设置开机启动项的几种方法","count":1,"path":"api/tags/设置开机启动项的几种方法.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"ConditionalOnProperty控制Bean对象加载","uid":"d258daee60faadc2bf7311dc982adc47","slug":"JAVA/@ConditionalOnProperty控制Bean对象加载","date":"2021-08-25T15:27:06.000Z","updated":"2025-12-05T01:46:09.075Z","comments":true,"path":"api/articles/JAVA/@ConditionalOnProperty控制Bean对象加载.json","keywords":"XuGuangSheng","cover":"/covers/conditionalonpropertybean.jpg","text":"@ConditionalOnProperty控制Bean对象加载1、简介 SpringBoot 通过 @ConditionalOnProperty 来控制 @C...","permalink":"/post/JAVA/@ConditionalOnProperty控制Bean对象加载","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"application","slug":"application","count":1,"path":"api/categories/application.json"},{"name":"JAVA","slug":"application/JAVA","count":1,"path":"api/categories/application/JAVA.json"}],"tags":[{"name":"yml","slug":"yml","count":1,"path":"api/tags/yml.json"},{"name":"如果","slug":"如果","count":2,"path":"api/tags/如果.json"},{"name":"否则不生效","slug":"否则不生效","count":1,"path":"api/tags/否则不生效.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}