{"title":"Java线程的六种状态 Thread.State","uid":"e527db9dc4d4819a60eaa7ad7fd37a44","slug":"JAVA/Java线程的六种状态 Thread.State","date":"2021-09-09T09:20:36.000Z","updated":"2025-12-05T01:46:23.030Z","comments":true,"path":"api/articles/JAVA/Java线程的六种状态 Thread.State.json","keywords":"XuGuangSheng","cover":"/covers/java-thread-state.jpg","content":"<h1 id=\"Java线程的六种状态-Thread-State\"><a href=\"#Java线程的六种状态-Thread-State\" class=\"headerlink\" title=\"Java线程的六种状态 Thread.State\"></a>Java线程的六种状态 Thread.State</h1><p>Thread.State 是 Thread 中的一个内部类，表示了 Thread 的六种状态，还有，这个类是一个枚举类。</p>\n<h2 id=\"NEW\"><a href=\"#NEW\" class=\"headerlink\" title=\"NEW\"></a><strong>NEW</strong></h2><p>线程刚刚 new 出来，热乎的，还未启动</p>\n<h3 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><pre><code>public class ThreadStateNewExample &#123;\n    private static Object waiter = new Object();\n    \n    public static void main(String[] args)&#123;\n        Runnable waiting = () -&gt; &#123;\n            try&#123;\n                waiter.wait();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;;\n        Thread whoWillWait = new Thread(waiting);\n        System.out.printf(whoWillWait.getState().toString());\n    &#125;\n&#125;\n复制代码\n</code></pre>\n<p>结果</p>\n<pre><code>NEW\nProcess finished with exit code 0\n复制代码\n</code></pre>\n<h2 id=\"RUNNABLE\"><a href=\"#RUNNABLE\" class=\"headerlink\" title=\"RUNNABLE\"></a><strong>RUNNABLE</strong></h2><p>说明线程已经就绪，可能正在执行某个任务，<strong>也可能在等待 CPU 资源</strong></p>\n<h3 id=\"代码示例-1\"><a href=\"#代码示例-1\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><pre><code>public class ThreadStateRunnableExample &#123;\n    private static boolean flag = true;\n\n    public static void main(String[] args)&#123;\n        Runnable waiting = () -&gt; &#123;\n            //让程序空转，保持线程是runnable状态\n                do &#123; &#125;while (flag);\n        &#125;;\n        Thread thread = new Thread(waiting);\n        thread.start();\n        try &#123;\n            //主线程先睡3秒，让子线程先跑起来，然后输出线程状态\n            Thread.sleep(3000);\n            System.out.printf(thread.getState().toString());\n            //更改标志位，让子线程结束循环\n            flag = false;\n        &#125;catch (InterruptedException e)&#123;\n            e.printStackTrace();\n        &#125;\n        System.exit(1);\n    &#125;\n&#125;\n复制代码\n</code></pre>\n<h3 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h3><pre><code>RUNNABLE\nProcess finished with exit code 1\n复制代码\n</code></pre>\n<h2 id=\"BLOCKED\"><a href=\"#BLOCKED\" class=\"headerlink\" title=\"BLOCKED\"></a><strong>BLOCKED</strong></h2><p>线程正在阻塞，等待一个 monitor lock。例如等待获取一个文件的锁</p>\n<h3 id=\"代码示例-2\"><a href=\"#代码示例-2\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><pre><code>public class ThreadStateBlockExample &#123;\n\n    private static boolean LOCK_FLAG = true;\n\n    public static void main(String[] args)&#123;\n        Runnable locker = ThreadStateBlockExample::locker;\n\n        Thread whoWillLockOthers = new Thread(locker);\n        /**\n         * 启动whoWillLockOthers线程，主线程睡2秒让子线程先运行\n         * 此时whoWillLockOthers获得锁，这时候其他线程需要等待\n         */\n        whoWillLockOthers.start();\n        try &#123;\n            Thread.sleep(2000);\n        &#125;catch (InterruptedException e)&#123;\n            e.printStackTrace();\n        &#125;\n        Thread whoWillBeLocked = new Thread(locker);\n        /**\n         * 启动whoWillBeLocked线程，主线程睡2秒让子线程先运行\n         * 因为locker方法是个死循环，所以whoWillBeLocked线程永远拿不到锁，就会进入BLOCKED状态\n         */\n        whoWillBeLocked.start();\n        try &#123;\n            Thread.sleep(2000);\n        &#125;catch (InterruptedException e)&#123;\n            e.printStackTrace();\n        &#125;\n        System.out.printf(&quot;whoWillBeLocked 当前状态为=&quot;+whoWillBeLocked.getState().toString()+&quot;&quot;);\n        System.exit(1);\n    &#125;\n\n\n    private static synchronized void locker()&#123;\n        do &#123;\n\n        &#125;while (LOCK_FLAG);\n    &#125;\n&#125;\n\n复制代码\n</code></pre>\n<h3 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h3><pre><code>whoWillBeLocked 当前状态为=BLOCKED\nProcess finished with exit code -1\n复制代码\n</code></pre>\n<h2 id=\"WAITING\"><a href=\"#WAITING\" class=\"headerlink\" title=\"WAITING\"></a><strong>WAITING</strong></h2><p>代表线程正在等待中。一个线程如果调用下列方法，会导致线程状态变为<strong>WAITING</strong>：</p>\n<ul>\n<li>Object.wait with no timeout</li>\n<li>Thread.join with no timeout</li>\n<li>LockSupport.park</li>\n</ul>\n<p>举个栗子：ThreadA 调用了 Object.wait() 方法，此时 ThreadA 状态为<strong>WAITING</strong>。ThreadA 会等待其他的线程调用 Object.notify() 或 Object.notifyAll 才会被唤醒，继续执行后面的逻辑</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意！！！<strong>调用 wait() 和 notify() 此类方法必须先获得 Object 的锁，至于原理我们开新帖子去讲，本文主要介绍线程的状态和代码示例，有兴趣的同学也可以在掘金上搜搜其他作者关于锁和 Monitor 的文章。</strong> </p></blockquote>\n<h3 id=\"代码示例-3\"><a href=\"#代码示例-3\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><pre><code>public class ThreadStateWaitingExample &#123;\n    private static final Object LOCKER = new Object();\n\n    public static void main(String[] args) &#123;\n\n        Runnable waiting = () -&gt; &#123;\n            System.out.println(&quot;whoWillWait 开始等待 whoWillNotify&quot;);\n            waiting();\n            System.out.println(&quot;whoWillWait 等到了 whoWillNotify 的通知&quot;);\n        &#125;;\n        //创建一个线程调用waiter.wait()方法，让whoWillWait线程进入waiting状态\n        Thread whoWillWait = new Thread(waiting);\n        whoWillWait.start();\n        //主线程先睡2秒，让whoWillWait先执行\n        try &#123;\n            Thread.sleep(2000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;whoWillWait当前的线程状态=&quot; + whoWillWait.getState().toString());\n\n\n        Runnable notify = () -&gt; &#123;\n            System.out.println(&quot;whoWillNotify 准备通知 whoWillWait&quot;);\n            notifying();\n        &#125;;\n        //创建一个线程调用waiter.notify()方法，唤醒whoWillWait\n        Thread whoWillNotify = new Thread(notify);\n        whoWillNotify.start();\n        //主线程先睡2秒，让whoWillNotify先执行\n        try &#123;\n            Thread.sleep(2000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;唤醒后，whoWillWait当前的线程状态=&quot; + whoWillWait.getState().toString());\n        System.exit(1);\n    &#125;\n\n    private static void waiting() &#123;\n        synchronized (LOCKER) &#123;\n            try &#123;\n                LOCKER.wait();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n    &#125;\n\n    private static void notifying() &#123;\n        synchronized (LOCKER) &#123;\n            LOCKER.notify();\n            System.out.println(&quot;whoWillNotify 已经通知，即将离开同步代码块&quot;);\n        &#125;\n    &#125;\n&#125;\n复制代码\n</code></pre>\n<h3 id=\"执行结果-1\"><a href=\"#执行结果-1\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h3><pre><code>whoWillWait 开始等待 whoWillNotify\nwhoWillWait当前的线程状态=WAITING\nwhoWillNotify 准备通知 whoWillWait\nwhoWillNotify 已经通知，即将离开同步代码块\nwhoWillWait 等到了 whoWillNotify 的通知\n唤醒后，whoWillWait当前的线程状态=TERMINATED\n\nProcess finished with exit code 1\n复制代码\n</code></pre>\n<h2 id=\"TIMED-WAITING\"><a href=\"#TIMED-WAITING\" class=\"headerlink\" title=\"TIMED_WAITING\"></a>TIMED_WAITING</h2><p>线程正在等待其他线程的操作，直到超过指定的超时时间。线程在调用以下方法是会将状态改变为 TIMED_WAITING 状态:</p>\n<ul>\n<li>Thread.sleep</li>\n<li>Object.wait with timeout</li>\n<li>Thread.join with timeout</li>\n<li>LockSupport.parkNanos</li>\n<li>LockSupport.parkUntil</li>\n</ul>\n<h3 id=\"代码示例-4\"><a href=\"#代码示例-4\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><pre><code>public class ThreadStateTimedWaitingExample &#123;\n    private static final Object LOCKER = new Object();\n\n    public static void main(String[] args) &#123;\n\n        Runnable waiting = () -&gt; &#123;\n            System.out.println(&quot;whoWillWait 开始等待 2秒钟&quot;);\n            waiting();\n            System.out.println(&quot;whoWillWait 等待结束&quot;);\n        &#125;;\n        //创建一个线程调用waiter.wait()方法，让whoWillWait线程进入waiting状态\n        Thread whoWillWait = new Thread(waiting);\n        whoWillWait.start();\n        //主线程先睡1秒，让whoWillWait先执行\n        try &#123;\n            Thread.sleep(1000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;whoWillWait当前的线程状态=&quot; + whoWillWait.getState().toString());\n\n\n        try &#123;\n            Thread.sleep(2000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;whoWillWait当前的线程状态=&quot; + whoWillWait.getState().toString());\n        System.exit(1);\n    &#125;\n\n    private static void waiting() &#123;\n        synchronized (LOCKER) &#123;\n            try &#123;\n                LOCKER.wait(2000);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n    &#125;\n    \n&#125;\n复制代码\n</code></pre>\n<h3 id=\"执行结果-2\"><a href=\"#执行结果-2\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h3><pre><code>whoWillWait 开始等待 2秒钟\nwhoWillWait当前的线程状态=TIMED_WAITING\nwhoWillWait 等待结束\nwhoWillWait当前的线程状态=TERMINATED\n\nProcess finished with exit code 1\n复制代码\n</code></pre>\n<h2 id=\"TERMINATED\"><a href=\"#TERMINATED\" class=\"headerlink\" title=\"TERMINATED\"></a>TERMINATED</h2><p>线程已经结束执行，属于退出状态</p>\n<h3 id=\"代码示例-5\"><a href=\"#代码示例-5\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><pre><code>public class ThreadStateTerminatedExample &#123;\n\n    public static void main(String[] args) &#123;\n\n        Runnable waiting = () -&gt; &#123;\n            System.out.println(&quot;随便执行一下，然后线程就会变为Terminated&quot;);\n        &#125;;\n        Thread terminate = new Thread(waiting);\n        terminate.start();\n        //主线程先睡1秒，让terminate先执行，一秒钟足够terminate执行完毕，然后线程就结束了\n        try &#123;\n            Thread.sleep(1000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        System.out.println(&quot;terminate当前的线程状态=&quot; + terminate.getState().toString());\n\n        System.exit(1);\n    &#125;\n\n&#125;\n复制代码\n</code></pre>\n<h3 id=\"执行结果-3\"><a href=\"#执行结果-3\" class=\"headerlink\" title=\"执行结果\"></a>执行结果</h3><pre><code>随便执行一下，然后线程就会变为Terminated\nterminate当前的线程状态=TERMINATED\n\nProcess finished with exit code 1\n复制代码\n</code></pre>\n<hr>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>线程在某个时间点只会拥有一种状态</strong>，这些状态都是虚拟机的线程状态，并不是操作系统的线程状态，这是两个概念，不要混淆。<br> <a href=\"https://juejin.cn/post/6844903968200458247\">https://juejin.cn/post/6844903968200458247</a></p></blockquote>\n","text":"Java线程的六种状态 Thread.StateThread.State 是 Thread 中的一个内部类，表示了 Thread 的六种状态，还有，这个类是一个...","permalink":"/post/JAVA/Java线程的六种状态 Thread.State","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"Thread","slug":"Thread","count":1,"path":"api/categories/Thread.json"},{"name":"JAVA","slug":"Thread/JAVA","count":1,"path":"api/categories/Thread/JAVA.json"}],"tags":[{"name":"代码示例","slug":"代码示例","count":1,"path":"api/tags/代码示例.json"},{"name":"Object","slug":"Object","count":1,"path":"api/tags/Object.json"},{"name":"WAITING","slug":"WAITING","count":1,"path":"api/tags/WAITING.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81-Thread-State\"><span class=\"toc-text\">Java线程的六种状态 Thread.State</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NEW\"><span class=\"toc-text\">NEW</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">代码示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RUNNABLE\"><span class=\"toc-text\">RUNNABLE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">运行结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BLOCKED\"><span class=\"toc-text\">BLOCKED</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">执行结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WAITING\"><span class=\"toc-text\">WAITING</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">执行结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TIMED-WAITING\"><span class=\"toc-text\">TIMED_WAITING</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-4\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-2\"><span class=\"toc-text\">执行结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TERMINATED\"><span class=\"toc-text\">TERMINATED</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-5\"><span class=\"toc-text\">代码示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C-3\"><span class=\"toc-text\">执行结果</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"JIT编译器（Just In Time编译器）","uid":"c656f0476e6a10c5f9016d53a17b0bf8","slug":"JAVA/JIT编译器（Just In Time编译器）","date":"2021-10-07T22:17:49.000Z","updated":"2025-12-05T01:46:15.859Z","comments":true,"path":"api/articles/JAVA/JIT编译器（Just In Time编译器）.json","keywords":"XuGuangSheng","cover":"/covers/jitjust-in-time.jpg","text":"JIT编译器（Just In Time编译器）前提概要 我们都知道开发语言整体分为两类，一类是编译型语言，一类是解释型语言。那么你知道二者有何区别吗？编译器和解...","permalink":"/post/JAVA/JIT编译器（Just In Time编译器）","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"JIT","slug":"JIT","count":2,"path":"api/categories/JIT.json"},{"name":"JAVA","slug":"JIT/JAVA","count":2,"path":"api/categories/JIT/JAVA.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"Client","slug":"Client","count":2,"path":"api/tags/Client.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Spring中classpath的使用问题","uid":"78e24240498cee987d87ef60883b2ac7","slug":"JAVA/Spring中classpath的使用问题","date":"2021-09-07T20:30:06.000Z","updated":"2025-12-05T01:46:38.168Z","comments":true,"path":"api/articles/JAVA/Spring中classpath的使用问题.json","keywords":"XuGuangSheng","cover":"/covers/springclasspath.jpg","text":"Spring中classpath的使用问题在 Spring 的配置文件中，经常使用classpath：xxx.xxx来读取文件。对于 maven 项目，误区是读...","permalink":"/post/JAVA/Spring中classpath的使用问题","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Resource","slug":"Resource","count":1,"path":"api/categories/Resource.json"},{"name":"JAVA","slug":"Resource/JAVA","count":1,"path":"api/categories/Resource/JAVA.json"}],"tags":[{"name":"jar","slug":"jar","count":1,"path":"api/tags/jar.json"},{"name":"txt","slug":"txt","count":1,"path":"api/tags/txt.json"},{"name":"resources","slug":"resources","count":1,"path":"api/tags/resources.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}