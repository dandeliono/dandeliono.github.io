{"title":"为什么 TCP 协议有 TIME_WAIT 状态","uid":"b7ecf3954ed2a73caa330011a27b5abb","slug":"JAVA/为什么 TCP 协议有 TIME_WAIT 状态","date":"2021-08-31T17:36:55.000Z","updated":"2025-12-05T01:46:44.632Z","comments":true,"path":"api/articles/JAVA/为什么 TCP 协议有 TIME_WAIT 状态.json","keywords":"XuGuangSheng","cover":"/covers/tcp-time-wait.jpg","content":"<h1 id=\"为什么-TCP-协议有-TIME-WAIT-状态\"><a href=\"#为什么-TCP-协议有-TIME-WAIT-状态\" class=\"headerlink\" title=\"为什么 TCP 协议有 TIME_WAIT 状态\"></a>为什么 TCP 协议有 TIME_WAIT 状态</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为什么这么设计（Why’s THE Design）是一系列关于计算机领域中程序设计决策的文章，我们在这个系列的每一篇文章中都会提出一个具体的问题并从不同的角度讨论这种设计的优缺点、对具体实现造成的影响。</p></blockquote>\n<p>在这个系列前面的文章中，我们已经多次讨论 TCP 协议的设计原理，其中包括 TCP 协议的 <a href=\"https://draveness.me/whys-the-design-tcp-three-way-handshake\">三次握手</a>、<a href=\"https://draveness.me/whys-the-design-tcp-performance\">流量控制和重传机制</a>、<a href=\"https://draveness.me/whys-the-design-tcp-segment-ip-packet\">最大数据段</a> 以及 <a href=\"https://draveness.me/whys-the-design-tcp-message-frame\">粘包</a> 等问题。本文将继续分析 TCP 协议的实现细节，今天要分析的问题是为什么 TCP 协议需要 <code>TIME_WAIT</code> 状态以及该状态的作用究竟是什么。</p>\n<p>TCP 协议中包含 11 种不同的状态，TCP 连接会根据发送或者接收到的消息转换状态，如下图所示的状态机展示了所有可能的转换，其中不仅包含了正常情况下的状态转换过程，还包含了异常状态下的状态转换：</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/e8413335-9fea-4952-8666-d4b63e7054a5.svg\"></p>\n<p><strong>图 1 - TCP 协议状态</strong></p>\n<p>使用 TCP 协议通信的双方会在关闭连接时触发 <code>TIME_WAIT</code> 状态，关闭连接的操作其实是告诉通信的另一方<strong>自己没有需要发送的数据</strong>，但是它仍然<strong>保持了接收对方数据的能力</strong>，一个常见的关闭连接过程如下<a href=\"#fn:1\">1</a>：</p>\n<ol>\n<li>当客户端没有待发送的数据时，它会向服务端发送 <code>FIN</code> 消息，发送消息后会进入 <code>FIN_WAIT_1</code> 状态；</li>\n<li>服务端接收到客户端的 <code>FIN</code> 消息后，会进入 <code>CLOSE_WAIT</code> 状态并向客户端发送 <code>ACK</code> 消息，客户端接收到 <code>ACK</code> 消息时会进入 <code>FIN_WAIT_2</code> 状态；</li>\n<li>当服务端没有待发送的数据时，服务端会向客户端发送 <code>FIN</code> 消息；</li>\n<li>客户端接收到 <code>FIN</code> 消息后，会进入 <code>TIME_WAIT</code> 状态并向服务端发送 <code>ACK</code> 消息，服务端收到后会进入 <code>CLOSED</code> 状态；</li>\n<li>客户端等待<strong>两个最大数据段生命周期</strong>（Maximum segment lifetime，MSL）<a href=\"#fn:2\">2</a>的时间后也会进入 <code>CLOSED</code> 状态；</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/8f5c3411331180d34888579a78c6d867.png\"></p>\n<p><strong>图 2 - TCP 关闭连接的过程</strong></p>\n<p>从上述过程中，我们会发现 <code>TIME_WAIT</code> 仅在主动断开连接的一方出现，被动断开连接的一方会直接进入 <code>CLOSED</code> 状态，进入 <code>TIME_WAIT</code> 的客户端需要等待 2 MSL 才可以真正关闭连接。TCP 协议需要 <code>TIME_WAIT</code> 状态的原因和客户端需要等待两个 MSL 不能直接进入 <code>CLOSED</code> 状态的原因是一样的<a href=\"#fn:3\">3</a>：</p>\n<ul>\n<li>防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；</li>\n<li>保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 <code>FIN</code> 对应的 <code>ACK</code> 消息；</li>\n</ul>\n<p>上述两个原因都相对比较简单，我们来展开介绍这两个原因背后可能存在的一些问题。</p>\n<h2 id=\"阻止延迟数据段\"><a href=\"#阻止延迟数据段\" class=\"headerlink\" title=\"阻止延迟数据段\"></a>阻止延迟数据段</h2><p>每一个 TCP 数据段都包含唯一的序列号，这个序列号能够保证 TCP 协议的可靠性和顺序性，在不考虑序列号溢出归零的情况下，序列号唯一是 TCP 协议中的重要约定，一旦违反了这条规则，就可能造成令人困惑的现象和结果。为了保证新 TCP 连接的数据段不会与还在网络中传输的历史连接的数据段重复，TCP 连接在分配新的序列号之前需要<strong>至少静默数据段在网络中能够存活的最长时间，即 MSL</strong><a href=\"#fn:4\">4</a>：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers in use was lost.</p></blockquote>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/965a35ef7f6158da9d5d97026b16d6e6.png\"></p>\n<p><strong>图 3 - TIME-WAIT 较短导致的数据段延迟接收</strong></p>\n<p>在如上图所示的 TCP 连接中，服务端发送的 <code>SEQ = 301</code> 消息由于网络延迟直到 TCP 连接关闭后也没有收到；当使用相同端口号的 TCP 连接被重用后，<code>SEQ = 301</code> 的消息才发送到客户端，然而这个过期的消息却可能被客户端正常接收，这就会带来比较严重的问题，所以我们<strong>在调整 <code>TIME_WAIT</code> 策略时要非常谨慎</strong>，必须清楚自己在干什么。</p>\n<p>RFC 793 中虽然指出了 TCP 连接需要在 <code>TIME_WAIT</code> 中等待 2 倍的 MSL，但是并没有解释清楚这里的两倍是从何而来，比较合理的解释是 — 网络中可能存在来自发起方的数据段，当这些发起方的数据段被服务端处理后又会向客户端发送响应，所以一来一回需要等待 2 倍的时间<a href=\"#fn:5\">5</a>。</p>\n<p>RFC 793 文档将 MSL 的时间设置为 120 秒，即两分钟，然而这并不是一个经过严密推断的数值，而是工程上的选择，如果根据服务历史上的经验要求我们改变操作系统的设置，也是没有任何问题的；实际上，较早版本的 Linux 就开始将 <code>TIME_WAIT</code> 的等待时间 <a href=\"https://github.com/torvalds/linux/blob/bd2463ac7d7ec51d432f23bf0e893fb371a908cd/include/net/tcp.h#L121\"><code>TCP_TIMEWAIT_LEN</code></a> 设置成 60 秒，以便更快地复用 TCP 连接资源：</p>\n<p>在 Linux 上，客户端的可以使用端口号 32,768 ~ 61,000，总共 28,232 个端口号与远程服务器建立连接，应用程序可以在将近 3 万的端口号中任意选择一个：</p>\n<p>但是如果主机在过去一分钟时间内与目标主机的特定端口创建的 TCP 连接数超过 28,232，那么再创建新的 TCP 连接就会发生错误，也就是说如果我们不调整主机的配置，那么每秒能够建立的最大 TCP 连接数为 ~470<a href=\"#fn:6\">6</a>。</p>\n<h2 id=\"保证连接关闭\"><a href=\"#保证连接关闭\" class=\"headerlink\" title=\"保证连接关闭\"></a>保证连接关闭</h2><p>从 RFC 793 对 <code>TIME_WAIT</code> 状态的定义中，我们可以发现该状态的另一个重要作用，等待足够长的时间以确定远程的 TCP 连接接收到了其发出的终止连接消息 <code>FIN</code> 对应的 <code>ACK</code>：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</p></blockquote>\n<p>如果客户端等待的时间不够长，当服务端还没有收到 <code>ACK</code> 消息时，客户端就重新与服务端建立 TCP 连接就会造成以下问题 — 服务端因为没有收到 <code>ACK</code> 消息，所以仍然认为当前连接是合法的，客户端重新发送 <code>SYN</code> 消息请求握手时会收到服务端的 <code>RST</code> 消息，连接建立的过程就会被终止。</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/84755287f98eca877e6f1ebbf525cf14.png\"></p>\n<p><strong>图 4 - TIME-WAIT 较短导致的握手终止</strong></p>\n<p>在默认情况下，如果客户端等待足够长的时间就会遇到以下两种情况：</p>\n<ol>\n<li>服务端正常收到了 <code>ACK</code> 消息并关闭当前 TCP 连接；</li>\n<li>服务端没有收到 <code>ACK</code> 消息，重新发送 <code>FIN</code> 关闭连接并等待新的 <code>ACK</code> 消息；</li>\n</ol>\n<p>只要客户端等待 2 MSL 的时间，客户端和服务端之间的连接就会正常关闭，新创建的 TCP 连接收到影响的概率也微乎其微，保证了数据传输的可靠性。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在某些场景下，60 秒的等待销毁时间确实是难以接受的，例如：高并发的压力测试。当我们通过并发请求测试远程服务的吞吐量和延迟时，本地就可能产生大量处于 <code>TIME_WAIT</code> 状态的 TCP 连接，在 macOS 上可以使用如下所示的命令查看活跃的连接：</p>\n<p>当我们在主机上通过几千个并发来测试服务器的压力时，这些用于压力测试的连接会迅速消耗主机上的 TCP 连接资源，几乎所有的 TCP 都会处于 <code>TIME_WAIT</code> 状态等待销毁。如果我们真遇到不得不处理<strong>单机上的</strong> <code>TIME_WAIT</code> 状态的时候，那么可以通过以下几种方法处理：</p>\n<ol>\n<li>使用 <code>SO_LINGER</code> 选项并设置暂存时间 <code>l_linger</code> 为 0，在这时如果我们关闭 TCP 连接，内核就会直接丢弃缓冲区中的全部数据并向服务端发送 <code>RST</code> 消息直接终止当前的连接<a href=\"#fn:7\">7</a>；</li>\n<li>使用 <code>net.ipv4.tcp_tw_reuse</code> 选项，通过 TCP 的时间戳选项允许内核重用处于 <code>TIME_WAIT</code> 状态的 TCP 连接<a href=\"#fn:8\">8</a>；</li>\n<li>修改 <code>net.ipv4.ip_local_port_range</code> 选项中的可用端口范围，增加可同时存在的 TCP 连接数上限；</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>需要注意的是，另一个常见的 TCP 配置项 <code>net.ipv4.tcp_tw_recycle</code> 已经在 Linux 4.12 中移除<a href=\"#fn:9\">9</a>，所以我们不能再通过该配置解决 <code>TIME_WAIT</code> 设计带来的问题。</p></blockquote>\n<p>TCP 的 <code>TIME_WAIT</code> 状态有着非常重要的作用，它是保证 TCP 协议可靠性不可缺失的设计，如果能通过加机器解决的话就尽量加机器，如果不能解决的话，我们就需要理解其背后的设计原理并尽可能避免修改默认的配置，就像 Linux 手册中说的一样，在修改这些配置时应该咨询技术专家的建议；在这里，我们再重新回顾一下 TCP 协议中 <code>TIME_WAIT</code> 状态存在的原因，如果客户端等待的时间不够长，那么使用相同端口号重新与远程建立连接时会造成以下问题：</p>\n<ul>\n<li>因为数据段的网络传输时间不确定，所以可能会收到上一次 TCP 连接中未被收到的数据段；</li>\n<li>因为客户端发出的 <code>ACK</code> 可能还没有被服务端接收，服务端可能还处于 <code>LAST_ACK</code> 状态，所以它会回复 <code>RST</code> 消息终止新连接的建立；</li>\n</ul>\n<p><code>TIME_WAIT</code> 状态是 TCP 与不确定的网络延迟斗争的结果，而<strong>不确定性是 TCP 协议在保证可靠这条路的最大阻碍</strong>。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细思考一下下面的问题：</p>\n<ul>\n<li><code>net.ipv4.tcp_tw_reuse</code> 配置如何通过时间戳保证重用 TCP 连接的相对安全？</li>\n<li><code>net.ipv4.tcp_tw_recycle</code> 配置为什么被 Linux 从协议栈中移除？</li>\n</ul>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ul>\n<li><a href=\"https://draveness.me/whys-the-design-tcp-three-way-handshake\">为什么 TCP 建立连接需要三次握手</a></li>\n<li><a href=\"https://draveness.me/whys-the-design-tcp-segment-ip-packet\">为什么 TCP&#x2F;IP 协议会拆分数据</a></li>\n</ul>\n<hr>\n<ol>\n<li>“3.5. Closing a Connection · Transmission Control Protocol RFC793” <a href=\"https://tools.ietf.org/html/rfc793#section-3.5\">https://tools.ietf.org/html/rfc793#section-3.5</a> <a href=\"#fnref:1\">↩︎</a></li>\n<li>“Wikipedia: Maximum segment lifetime” <a href=\"https://en.wikipedia.org/wiki/Maximum_segment_lifetime\">https://en.wikipedia.org/wiki/Maximum_segment_lifetime</a> <a href=\"#fnref:2\">↩︎</a></li>\n<li>“Can the time a socket spends in TIMED-WAIT state be reduced?” <a href=\"https://knowledgebase.progress.com/articles/Article/Can-the-time-a-socket-spends-in-TIMED-WAIT-state-be-reduced\">https://knowledgebase.progress.com/articles/Article/Can-the-time-a-socket-spends-in-TIMED-WAIT-state-be-reduced</a> <a href=\"#fnref:3\">↩︎</a></li>\n<li>“Knowing When to Keep Quiet · Transmission Control Protocol RFC793” <a href=\"https://tools.ietf.org/html/rfc793\">https://tools.ietf.org/html/rfc793</a> <a href=\"#fnref:4\">↩︎</a></li>\n<li>“Setting TIME_WAIT TCP” <a href=\"https://stackoverflow.com/questions/337115/setting-time-wait-tcp\">https://stackoverflow.com/questions/337115/setting-time-wait-tcp</a> <a href=\"#fnref:5\">↩︎</a></li>\n<li>“Coping with the TCP TIME-WAIT state on busy Linux servers” <a href=\"https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux#connection-table-slot\">https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux#connection-table-slot</a> <a href=\"#fnref:6\">↩︎</a></li>\n<li>“SO_LINGER Socket Option · Chapter 7. Socket Options” <a href=\"https://notes.shichao.io/unp/ch7/#so_linger-socket-option\">https://notes.shichao.io/unp/ch7/#so_linger-socket-option</a> <a href=\"#fnref:7\">↩︎</a></li>\n<li>“net.ipv4.tcp_tw_reuse” <a href=\"https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux#netipv4tcp_tw_reuse\">https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux#netipv4tcp_tw_reuse</a> <a href=\"#fnref:8\">↩︎</a></li>\n<li>“tcp: remove tcp_tw_recycle” <a href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc\">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc</a> <a href=\"#fnref:9\">↩︎</a><br><a href=\"https://draveness.me/whys-the-design-tcp-time-wait/\">https://draveness.me/whys-the-design-tcp-time-wait/</a></li>\n</ol>\n","text":"为什么 TCP 协议有 TIME_WAIT 状态 为什么这么设计（Why’s THE Design）是一系列关于计算机领域中程序设计决策的文章，我们在这个系列的...","permalink":"/post/JAVA/为什么 TCP 协议有 TIME_WAIT 状态","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"TCP","slug":"TCP","count":3,"path":"api/categories/TCP.json"},{"name":"JAVA","slug":"TCP/JAVA","count":1,"path":"api/categories/TCP/JAVA.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"WAIT","slug":"WAIT","count":1,"path":"api/tags/WAIT.json"},{"name":"TIME","slug":"TIME","count":1,"path":"api/tags/TIME.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E5%8D%8F%E8%AE%AE%E6%9C%89-TIME-WAIT-%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">为什么 TCP 协议有 TIME_WAIT 状态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%BB%E6%AD%A2%E5%BB%B6%E8%BF%9F%E6%95%B0%E6%8D%AE%E6%AE%B5\"><span class=\"toc-text\">阻止延迟数据段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%9D%E8%AF%81%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">保证连接关闭</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">相关文章</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"JSQLParser的简单使用","uid":"48d20d4467bd70f47406b938972138eb","slug":"JAVA/JSQLParser的简单使用","date":"2021-09-01T16:57:01.000Z","updated":"2025-12-05T01:46:16.607Z","comments":true,"path":"api/articles/JAVA/JSQLParser的简单使用.json","keywords":"XuGuangSheng","cover":"/covers/jsqlparser.jpg","text":"JSQLParser的简单使用这里简单记录一下最近了解到的 JSQLParser 这个 SQL 语句解析器的用法，方便有需要的时候参考。 正文：import n...","permalink":"/post/JAVA/JSQLParser的简单使用","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"https","slug":"https","count":12,"path":"api/categories/https.json"},{"name":"JAVA","slug":"https/JAVA","count":5,"path":"api/categories/https/JAVA.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"net","slug":"net","count":1,"path":"api/tags/net.json"},{"name":"www","slug":"www","count":8,"path":"api/tags/www.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"kafka启动报错 A broker is already registered on the path brokers ids 1 解决方案","uid":"e618b0a0a36dd4779e822db97f59bf1f","slug":"MIDDLEWARE/kafka启动报错 A broker is already registered on the path brokers ids 1 解决方案","date":"2021-08-31T15:48:56.000Z","updated":"2025-12-05T01:47:42.638Z","comments":true,"path":"api/articles/MIDDLEWARE/kafka启动报错 A broker is already registered on the path brokers ids 1 解决方案.json","keywords":"XuGuangSheng","cover":"/covers/kafka-a-broker-is-already-registered-on-the-path-brokers-ids-1.jpg","text":"kafka启动报错”A broker is already registered on the path /brokers/ids/1”解决方案问题#kafka...","permalink":"/post/MIDDLEWARE/kafka启动报错 A broker is already registered on the path brokers ids 1 解决方案","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"broker","slug":"broker","count":1,"path":"api/categories/broker.json"},{"name":"MIDDLEWARE","slug":"broker/MIDDLEWARE","count":1,"path":"api/categories/broker/MIDDLEWARE.json"}],"tags":[{"name":"server","slug":"server","count":3,"path":"api/tags/server.json"},{"name":"kafka","slug":"kafka","count":1,"path":"api/tags/kafka.json"},{"name":"解决方案","slug":"解决方案","count":1,"path":"api/tags/解决方案.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}