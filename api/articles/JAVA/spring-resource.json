{"title":"spring-resource注解","uid":"967cedbbb844e0a50d0c9c5adb15d090","slug":"JAVA/spring-resource","date":"2020-09-24T21:56:07.000Z","updated":"2025-12-05T01:46:42.799Z","comments":true,"path":"api/articles/JAVA/spring-resource.json","keywords":"XuGuangSheng","cover":"/covers/spring-resource.jpg","content":"<p>Spring不但支持自己定义的@Autowired注解，还支持几个由<strong>JSR-250</strong>规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。这里只说@Autowired和@Resource注解的区别。</p>\n<ol>\n<li><p>@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。</p>\n</li>\n<li><p>@Autowired默认按类型装配（这个注解是属于spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required&#x3D;false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired()</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;baseDao&quot;)</span></span><br><span class=\"line\">privateBaseDao baseDao;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Resource(name=&quot;baseDao&quot;)</span></span><br><span class=\"line\">privateBaseDao baseDao;</span><br></pre></td></tr></table></figure>\n\n<p><strong>@Resource装配顺序</strong>  </p>\n<ol>\n<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常  </li>\n<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常  </li>\n<li>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常  </li>\n<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</li>\n</ol>\n<p><strong>@Autowired装配顺序</strong></p>\n<ol>\n<li>如果没有指定@Qualifier，默认安装类型注入，找不到则抛出异常。  </li>\n<li>如果指定了@Qualifier，则按照名称注入，找不到则抛出异常。</li>\n</ol>\n<p>一般@Autowired和@Qualifier一起用，@Resource单独用。当然没有冲突的话@Autowired也可以单独用。值得注意的是Spring官方并不建议直接在类的field上使用@Autowired注解。参考<a href=\"http://olivergierke.de/2013/11/why-field-injection-is-evil/\">《Why field injection is evil》</a></p>\n","text":"Spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及...","permalink":"/post/JAVA/spring-resource","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"Autowired","slug":"Autowired","count":1,"path":"api/categories/Autowired.json"},{"name":"JAVA","slug":"Autowired/JAVA","count":1,"path":"api/categories/Autowired/JAVA.json"}],"tags":[{"name":"name","slug":"name","count":6,"path":"api/tags/name.json"},{"name":"Resource","slug":"Resource","count":1,"path":"api/tags/Resource.json"},{"name":"bean","slug":"bean","count":1,"path":"api/tags/bean.json"}],"toc":"","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java集合","uid":"fd2c15dc5d41ab5172de4dd08fd40ea9","slug":"OTHER/interview-java-collection","date":"2021-01-11T21:09:12.000Z","updated":"2025-12-05T01:48:03.734Z","comments":true,"path":"api/articles/OTHER/interview-java-collection.json","keywords":"XuGuangSheng","cover":"/covers/interview-java-collection.jpg","text":"","permalink":"/post/OTHER/interview-java-collection","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"OTHER","slug":"OTHER","count":1,"path":"api/categories/OTHER.json"}],"tags":[],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Kadane算法","uid":"2c671df6ac43c352607865f709c91620","slug":"ALG/Kadane","date":"2020-09-22T22:01:24.000Z","updated":"2025-12-05T01:45:59.709Z","comments":true,"path":"api/articles/ALG/Kadane.json","keywords":"XuGuangSheng","cover":"/covers/kadane.jpg","text":"Kadane算法扫描一次整个数列的所有数值，在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。该子数列由两部分组成：以前一个位置为结束点的最大子数...","permalink":"/post/ALG/Kadane","photos":[],"count_time":{"symbolsCount":641,"symbolsTime":"1 mins."},"categories":[{"name":"Kadane","slug":"Kadane","count":1,"path":"api/categories/Kadane.json"},{"name":"ALG","slug":"Kadane/ALG","count":1,"path":"api/categories/Kadane/ALG.json"}],"tags":[{"name":"算法扫描一次整个数列的所有数值","slug":"算法扫描一次整个数列的所有数值","count":1,"path":"api/tags/算法扫描一次整个数列的所有数值.json"},{"name":"在每一个扫描点计算以该点数值为结束点的子数列的最大和","slug":"在每一个扫描点计算以该点数值为结束点的子数列的最大和","count":1,"path":"api/tags/在每一个扫描点计算以该点数值为结束点的子数列的最大和.json"},{"name":"正数和","slug":"正数和","count":1,"path":"api/tags/正数和.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}