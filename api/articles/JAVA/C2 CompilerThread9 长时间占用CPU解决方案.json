{"title":"C2 CompilerThread9 长时间占用CPU解决方案","uid":"ad2282a09eaef1269a01ab0f55818331","slug":"JAVA/C2 CompilerThread9 长时间占用CPU解决方案","date":"2023-11-02T18:06:45.000Z","updated":"2025-09-30T03:26:07.848Z","comments":true,"path":"api/articles/JAVA/C2 CompilerThread9 长时间占用CPU解决方案.json","keywords":"XuGuangSheng","cover":"/covers/c2-compilerthread9-cpu.jpg","content":"<h5 id=\"一、描述：异常线程的堆栈如下：\"><a href=\"#一、描述：异常线程的堆栈如下：\" class=\"headerlink\" title=\"一、描述：异常线程的堆栈如下：\"></a>一、描述：异常线程的堆栈如下：</h5><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`<span class=\"string\">&quot;C2 CompilerThread9&quot;</span> #48 daemon <span class=\"attribute\">prio</span>=9 <span class=\"attribute\">os_prio</span>=0 <span class=\"attribute\">tid</span>=0x00007f45f0b80000 <span class=\"attribute\">nid</span>=0x188 runnable [0x0000000000000000]</span><br><span class=\"line\">   java.lang.Thread.State: RUNNABLE` </span><br><span class=\"line\"></span><br><span class=\"line\">*   1</span><br><span class=\"line\">*   2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>补充描述：我的应用类型为后台接口服务，系统秒级调用峰值在10W+，JRE版本如下：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`<span class=\"keyword\">java </span>version <span class=\"string\">&quot;1.8.0_231&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">Java(TM) </span>SE Runtime Environment (<span class=\"keyword\">build </span><span class=\"number\">1</span>.<span class=\"number\">8</span>.<span class=\"number\">0</span>_231-<span class=\"keyword\">b11)</span></span><br><span class=\"line\"><span class=\"keyword\"></span><span class=\"keyword\">Java </span>HotSpot(TM) <span class=\"number\">64</span>-<span class=\"keyword\">Bit </span>Server VM (<span class=\"keyword\">build </span><span class=\"number\">25</span>.<span class=\"number\">231</span>-<span class=\"keyword\">b11, </span>mixed mode)` </span><br><span class=\"line\"></span><br><span class=\"line\">*   <span class=\"number\">1</span></span><br><span class=\"line\">*   <span class=\"number\">2</span></span><br><span class=\"line\">*   <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"二、问题解决过程：关闭JIT分层编译\"><a href=\"#二、问题解决过程：关闭JIT分层编译\" class=\"headerlink\" title=\"二、问题解决过程：关闭JIT分层编译\"></a>二、问题解决过程：关闭JIT分层编译</h5><p><strong>步骤一：了解JIT编译原理</strong></p>\n<p>因为之前对JIT的编译原理并不了解，不敢随意修改线上服务器的编译类型，担心会有一些其他的副作用，所以在网上开始了查阅资料学习的过程。</p>\n<p><strong>什么是JIT编译？</strong><br>编译器在编译过程中通常会考虑很多因素。比如：汇编指令的顺序。假设我们要将两个寄存器的值进行相加，执行这个操作一般只需要一个CPU周期；但是在相加之前需要将数据从内存读到寄存器中，这个操作是需要多个CPU周期的。编译器一般可以做到，先启动数据加载操作，然后执行其它指令，等数据加载完成后，再执行相加操作。由于解释器在解释执行的过程中，每次只能看到一行代码，所以很难生成上述这样的高效指令序列。而编译器可以事先看到所有代码，因此，一般来说，解释性代码比编译性代码要慢。</p>\n<p>java 作为静态语言十分特殊，他需要编译，但并不是在执行之前就编译为本地机器码。Java的实现在解释性和编译性之间进行了折中，Java代码是编译性的，它会被编译成一个平台独立的字节码程序。JVM负责加载、解释、执行这些字节码程序，在这个过程中，还可能会将这些字节码实时编译成目标机器码，以便提升性能。</p>\n<p>所以，在谈到 java的编译机制的时候，其实应该按时期，分为两个部分。一个是 javac指令 将java源码变为 java字节码的静态编译过程。 另一个是 java字节码编译为本地机器码的过程，并且因为这个过程是在程序运行时期完成的所以称之为即时编译（JIT：Just In Time）。</p>\n<p><strong>JIT编译类型：C1编译器、C2编译器、分层编译器</strong></p>\n<p>通常我们说<code>即时编译器</code>有两种类型，Client <a href=\"https://so.csdn.net/so/search?q=Compiler&spm=1001.2101.3001.7020\">Compiler</a>（C1编译器）和Server Compiler（C2编译器）。这两种编译器最大的区别就是，编译代码的时间点不一样。C1编译器会更早的对代码进行编译，因此在程序刚启动的时候，<code>C1编译器比C2编译器执行的更快，所以C1编译器适用于一些GUI应用</code>，可以缩短应用启动时间。<code>C2编译器会收集更多的信息</code>，然后才对代码进行编译优化，所以从长远角度考虑，C2编译器最终可以产生比C1编译器更优秀的代码，适用于<code>长时间运行</code>的后台接口服务。</p>\n<p>可能大家都有一个困扰，JVM为什么要将编译器分为client和server，为什么不在程序启动时，使用client编译器，在程序运行一段时间后，自动切换为server编译器？ 其实，这种技术是存在的，一般称之为 Tiered Compiler（分层编译器）。Java7 和Java 8可以使用选项<code>-XX:+TieredCompilation</code>来打开（<code>-server</code>选项也要打开）。在Java 8中，<code>-XX:+TieredCompilation</code>默认是打开的。</p>\n<p>分层编译将 JVM 的执行状态分为了 5 个层次：</p>\n<ul>\n<li>第 0 层：程序解释执行，默认开启性能监控功能（Profiling），如果不开启，可触发第二层编译；</li>\n<li>第 1 层：可称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启 Profiling；</li>\n<li>第 2 层：也称为 C1 编译，开启 Profiling，仅执行带方法调用次数和循环回边执行次数 profiling 的 C1 编译；</li>\n<li>第 3 层：也称为 C1 编译，执行所有带 Profiling 的 C1 编译；</li>\n<li>第 4 层：可称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li>\n</ul>\n<p>在一些特殊情况下，激进优化后的代码并不能有更高的性能。需要进行优化回退，将重新对代码进行解释执行。因此</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`<span class=\"built_in\">C2</span>编译器相对于<span class=\"built_in\">C1</span>编译器更适用于我们系统</span><br><span class=\"line\">分层编译器是综合考虑<span class=\"built_in\">C1</span>和<span class=\"built_in\">C2</span>编译器的优点衍生出的一种进化版本编译器，但是由于我们是纯后台应用，这种衍生优化是否有效未可知。</span><br><span class=\"line\">分层编译器在一些特殊情况下可能比较激进、不可靠。` </span><br><span class=\"line\"></span><br><span class=\"line\">*   <span class=\"number\">1</span></span><br><span class=\"line\">*   <span class=\"number\">2</span></span><br><span class=\"line\">*   <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>JIT学习参考博文：<br><a href=\"https://blog.csdn.net/qq_28674045/article/details/51896129\">https://blog.csdn.net/qq_28674045/article/details/51896129</a><br><a href=\"https://www.cnblogs.com/insistence/p/5901457.html\">https://www.cnblogs.com/insistence/p/5901457.html</a><br><a href=\"https://www.cnblogs.com/death00/p/11722130.html\">https://www.cnblogs.com/death00/p/11722130.html</a></p>\n<p><strong>步骤二：关闭分层编译，启用C2编译器</strong><br>JVM启动脚本中添加如下参数</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`-XX:-TieredCompilation -server` </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以下是一些常见的 JVM 参数和示例代码：</p>\n<ol>\n<li><p><strong>设置堆大小</strong>：</p>\n<ul>\n<li>增大堆大小：<code>-Xmx</code> 参数用于设置最大堆大小，例如 <code>-Xmx2g</code> 表示将堆的最大大小设置为 2GB。</li>\n<li>增大初始堆大小：<code>-Xms</code> 参数用于设置初始堆大小，例如 <code>-Xms512m</code> 表示将初始堆大小设置为 512MB。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xmx2g -Xms512m -jar YourApp.jar</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>选择垃圾收集器</strong>：</p>\n<ul>\n<li>选择垃圾收集器：使用 <code>-XX:+UseG1GC</code> 来启用 G1 垃圾收集器。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:+UseG1GC -jar YourApp.jar</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>JIT 编译优化</strong>：</p>\n<ul>\n<li>禁用 JIT 编译：可以使用 <code>-Djava.compiler=NONE</code> 来禁用 JIT 编译器。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Djava.compiler=NONE -jar YourApp.jar</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>设置编译阈值</strong>：</p>\n<ul>\n<li>调整编译阈值：使用 <code>-XX:CompileThreshold</code> 参数来调整编译阈值。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:CompileThreshold=1000 -jar YourApp.jar</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>更改编译器</strong>：</p>\n<ul>\n<li>使用 <code>-XX:TieredStopAtLevel</code> 参数来更改编译器级别，例如 <code>-XX:TieredStopAtLevel=1</code> 可以将编译器级别设置为 1。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:TieredStopAtLevel=1 -jar YourApp.jar</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>启用或禁用特定的编译器优化</strong>：</p>\n<ul>\n<li>使用 <code>-XX:CompileCommand</code> 来控制编译器优化，例如 <code>-XX:CompileCommand=inline,YourClass.yourMethod</code> 可以强制内联特定方法。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:CompileCommand=inline,YourClass.yourMethod -jar YourApp.jar</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>这些示例展示了如何在启动 Java 应用程序时传递不同的 JVM 参数。请注意，JVM 参数的调整应该根据应用程序的性能需求和性能分析的结果来选择。不同的应用程序可能需要不同的参数配置。确保在生产环境中小心谨慎地测试和优化参数，以获得最佳性能。</p>\n","text":"一、描述：异常线程的堆栈如下：1234567`\"C2 CompilerThread9\" #48 daemon prio=9 os_prio=0 tid=0x00...","permalink":"/post/JAVA/C2 CompilerThread9 长时间占用CPU解决方案","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"JIT","slug":"JIT","count":2,"path":"api/categories/JIT.json"},{"name":"JAVA","slug":"JIT/JAVA","count":2,"path":"api/categories/JIT/JAVA.json"}],"tags":[{"name":"编译","slug":"编译","count":1,"path":"api/tags/编译.json"},{"name":"编译器","slug":"编译器","count":1,"path":"api/tags/编译器.json"},{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%8F%8F%E8%BF%B0%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A0%86%E6%A0%88%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">一、描述：异常线程的堆栈如下：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%85%B3%E9%97%ADJIT%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">二、问题解决过程：关闭JIT分层编译</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"SpringBoot 扩展接口","uid":"b17fc263eaa274b6bfcba03d60c157eb","slug":"JAVA/SpringBoot 扩展接口","date":"2023-11-15T16:23:04.000Z","updated":"2025-09-30T03:26:20.574Z","comments":true,"path":"api/articles/JAVA/SpringBoot 扩展接口.json","keywords":"XuGuangSheng","cover":"/covers/springboot.jpg","text":"SpringBoot 扩展接口1、背景Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Spr...","permalink":"/post/JAVA/SpringBoot 扩展接口","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"bean","slug":"bean","count":2,"path":"api/categories/bean.json"},{"name":"JAVA","slug":"bean/JAVA","count":2,"path":"api/categories/bean/JAVA.json"}],"tags":[{"name":"spring","slug":"spring","count":4,"path":"api/tags/spring.json"},{"name":"org","slug":"org","count":2,"path":"api/tags/org.json"},{"name":"springframework","slug":"springframework","count":1,"path":"api/tags/springframework.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Kafka内外网访问的设置","uid":"f6ebfd744882aafe6959a28651edde47","slug":"MIDDLEWARE/Kafka内外网访问的设置","date":"2023-10-23T19:00:55.000Z","updated":"2025-09-30T03:26:47.932Z","comments":true,"path":"api/articles/MIDDLEWARE/Kafka内外网访问的设置.json","keywords":"XuGuangSheng","cover":"/covers/kafka.jpg","text":"Kafka内外网访问的设置kafka的两个配置listeners和advertised.listenerslistenerskafka监听的网卡的ip，假设你机...","permalink":"/post/MIDDLEWARE/Kafka内外网访问的设置","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"kafka","slug":"kafka","count":1,"path":"api/categories/kafka.json"},{"name":"MIDDLEWARE","slug":"kafka/MIDDLEWARE","count":1,"path":"api/categories/kafka/MIDDLEWARE.json"}],"tags":[{"name":"listeners","slug":"listeners","count":1,"path":"api/tags/listeners.json"},{"name":"advertised","slug":"advertised","count":1,"path":"api/tags/advertised.json"},{"name":"zookeeper","slug":"zookeeper","count":2,"path":"api/tags/zookeeper.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}