{"title":"用手写一个请求合并","uid":"b6f5eb01abd12277953691dc9b2fec2e","slug":"JAVA/用手写一个请求合并","date":"2023-04-19T15:45:48.000Z","updated":"2025-12-05T01:46:52.855Z","comments":true,"path":"api/articles/JAVA/用手写一个请求合并.json","keywords":"XuGuangSheng","cover":"/covers/e425c5f6a9af.jpg","content":"<h1 id=\"用手写一个请求合并\"><a href=\"#用手写一个请求合并\" class=\"headerlink\" title=\"用手写一个请求合并\"></a>用手写一个请求合并</h1><p><strong>推荐阅读：</strong> </p>\n<h2 id=\"一、服务器崩溃的思考\"><a href=\"#一、服务器崩溃的思考\" class=\"headerlink\" title=\"一、服务器崩溃的思考\"></a><strong>一、服务器崩溃的思考</strong></h2><dl><dt>老板说，他要做个现场营销活动，线上线下都要参与推广，这个活动参与人数可能很大哦··· 果然，由于不是我写的代码，所以那天服务器就崩了，崩的时候很安静，写代码的那个人一个人走的，走的时候很安详。</dt><dd>当请求量到达百万级时候，为啥会崩溃呢？</dd></dl><p><img src=\"https://pic3.zhimg.com/v2-fe8761a0aa32b55d66ba275d400288e2_b.jpg\"></p>\n<p>微服务中是通过接口去向<strong>服务提供者</strong>发起<code>http</code>请求或者<code>rpc（tcp）</code>请求去获取数据，事实上大量请求中，服务端能处理的请求数量有限，服务中充斥着大量的线程，以及数据库等的连接也会被占用完，导致请求响应速度也越来越慢。<br>：</p>\n<ul>\n<li>响应速度和我们的数据层有关系吗？</li>\n<li>能不能去添加服务端服务器呢？</li>\n<li>如果能减少客户端向服务端的请求就好了？</li>\n<li>限流吗？当前场景能限流吗？</li>\n<li>每个线程去查询数据，每次都只查询某一个结果，是不是太浪费了？</li>\n<li>我们能不能想办法，提升我们系统的调用性能？</li>\n</ul>\n<h2 id=\"二、有人想看请求合并，今天她来了\"><a href=\"#二、有人想看请求合并，今天她来了\" class=\"headerlink\" title=\"二、有人想看请求合并，今天她来了\"></a><strong>二、有人想看请求合并，今天她来了</strong></h2><p>上面的一些思路可以用加缓存，加MQ的方式去解决。但是缓存有限，MQ是个队列，有限流的效果。那么，如何才能提高系统的调用能力，我们学习一下，请求合并，结果分发。  </p>\n<ul>\n<li>正常的请求都是一个请求一个线程，到后台触发相关的业务需求，去调用数据获取业务。</li>\n<li>当请求合并后，我们要将多个多个请求合并后统一去批量去调用。</li>\n</ul>\n<p>大概的设计思路便是如下图所示：</p>\n<p>1. <strong>常规请求</strong></p>\n<p><img src=\"https://pic1.zhimg.com/v2-443942324c4131f8a36280f1c8555144_b.jpg\"></p>\n<p>2. <strong>请求合并</strong>  </p>\n<p><img src=\"https://pic3.zhimg.com/v2-11bf044b4527d57b934481fafb356a52_b.jpg\"></p>\n<p>3. <strong>说下我们的思路</strong></p>\n<ul>\n<li>解决请求调用多，比如调用商品数据，经过的服务多，调用链很长，所以查询数据库的次数也就非常多，数据库连接池很快就被用光，导致很多请求被阻塞，也导致应用整体线程数非常高。虽然通过增加数据库连接池大小可以缓解问题，并且可以通过压力测试，但这治标不治本。</li>\n<li>查询商品信息的时候，如果同一商品同一时刻有100个请求，那么其中的99次查询是多余的，可以把100个请求合并成一个真实的后台接口调用，只要控制好线程安全即可。我的想法是使用并发计数器来实现再配合本地缓存，计数器可直接用JDK提供的<code>AtomicInteger</code>，线程安全又提供原子操作。</li>\n<li>以获取商品信息为例，每个商品id对应一个计数器，计数器初始值默认是0，当一个请求过来后通过<code>incrementAndGet()</code>使计数器自增1并返回自增后的值。当该值等于1，表明该线程在这个时间点上是第一个到达的线程，然后就去调用真实的业务逻辑，在查询到结果后放入到本地缓存中。当该值大于1的时候，表明之前已有线程正在调用业务逻辑，则进入等待状态，并循环的查询本地缓存中是否已有数据可用。获取到结果后都调用<code>decrementAndGet()</code>使计数器减1，计数器被减到0的时候就回到了初始状态，并且当减到0（代表最后一个线程）时清除缓存。</li>\n<li>那还有在1000次请求中，请求的数据id不同，但是使用的服务接口相同，都是查询商品库的商品<code>id</code>从<code>1~1000</code>的数据，都是从表里面查询，<code>queryDataById(dataId)</code>,那我也可以合并这些请求，改为批量查询，然后将数据分发返回。思路就是设计每个请求携带一个请求<code>唯一的traceId</code>,有点像链路跟踪的感觉，简单点可以使用查询的id进行最为跟踪id，将请求放入一个队中，使用定时任务，比如每隔10ms去扫描队列，将这些业务合并请求统一去请求数据库层。</li>\n<li>此方案有个数据延迟的地方，就是每次循环时的等待状态的时间。因为一次包含多次查库的业务调用，耗时基本都在几十毫秒，甚至是上百毫秒，可以把该等待睡眠设置小一点，比如10毫秒。这样即不会浪费CPU时间，实时性也比较高，但然也可以通过主动唤醒等待线程的方式，这个操作起来就比较复杂些。在这其中还可以添加一些异常处理、超时控制、最大重试次数，最大并发数（超时最大并发数就快速失败）等。</li>\n</ul>\n<h2 id=\"三、开始演练\"><a href=\"#三、开始演练\" class=\"headerlink\" title=\"三、开始演练\"></a>三、开始演练</h2><ul>\n<li><strong>模拟一个远程调用接口</strong></li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 模拟远程调用ShopData接口</span><br><span class=\"line\"> * @author Lijing</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class QueryServiceRemoteCall &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 调用远程的商品信息查询接口</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param code 商品编码</span><br><span class=\"line\">     * @return 返回商品信息，map格式</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public HashMap&lt;String, Object&gt; queryShopDataInfoByCode(String code) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(50L);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">        hashMap.put(&quot;shopDataId&quot;, new Random().nextInt(999999999));</span><br><span class=\"line\">        hashMap.put(&quot;code&quot;, code);</span><br><span class=\"line\">        hashMap.put(&quot;name&quot;, &quot;小玩具&quot;);</span><br><span class=\"line\">        hashMap.put(&quot;isOk&quot;, &quot;true&quot;);</span><br><span class=\"line\">        hashMap.put(&quot;price&quot;,&quot;3000&quot;);</span><br><span class=\"line\">        return hashMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 批量查询 - 调用远程的商品信息查询接口</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param codes 多个商品编码</span><br><span class=\"line\">     * @return 返回多个商品信息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;Map&lt;String, Object&gt;&gt; queryShopDataInfoByCodeBatch(List&lt;String&gt; codes) &#123;</span><br><span class=\"line\">        List&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (String code : codes) &#123;</span><br><span class=\"line\">            HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">            hashMap.put(&quot;shopDataId&quot;, new Random().nextInt(999999999));</span><br><span class=\"line\">            hashMap.put(&quot;code&quot;, code);</span><br><span class=\"line\">            hashMap.put(&quot;name&quot;, &quot;棉花糖&quot;);</span><br><span class=\"line\">            hashMap.put(&quot;isOk&quot;, &quot;true&quot;);</span><br><span class=\"line\">            hashMap.put(&quot;price&quot;,&quot;6000&quot;);</span><br><span class=\"line\">            result.add(hashMap);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用<strong>CountDownLatch</strong>模拟并发请求的公共测试类</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RunWith(SpringRunner.class)</span><br><span class=\"line\">@SpringBootTest(classes = MyBotApplication.class)</span><br><span class=\"line\">public class MergerApplicationTests &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    long timed = 0L;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Before</span><br><span class=\"line\">    public void start() &#123;</span><br><span class=\"line\">        System.out.println(&quot;开始测试&quot;);</span><br><span class=\"line\">        timed = System.currentTimeMillis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @After</span><br><span class=\"line\">    public void end() &#123;</span><br><span class=\"line\">        System.out.println(&quot;结束测试,执行时长：&quot; + (System.currentTimeMillis() - timed));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 模拟的请求数量</span><br><span class=\"line\">    private static final int THREAD_NUM = 1000;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 倒计数器 juc包中常用工具类</span><br><span class=\"line\">    private CountDownLatch countDownLatch = new CountDownLatch(THREAD_NUM);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private ShopDataService shopDataService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void simulateCall() throws IOException &#123;</span><br><span class=\"line\">        // 创建 并不是马上发起请求</span><br><span class=\"line\">        for (int i = 0; i &lt; THREAD_NUM; i++) &#123;</span><br><span class=\"line\">            final String code = &quot;code-&quot; + (i + 1);</span><br><span class=\"line\">            // 多线程模拟用户查询请求</span><br><span class=\"line\">            Thread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    // 代码在这里等待，等待countDownLatch为0，代表所有线程都start，再运行后续的代码</span><br><span class=\"line\">                    countDownLatch.await();</span><br><span class=\"line\">                    // 模拟 http请求，实际上就是多线程调用这个方法</span><br><span class=\"line\">                    Map&lt;String, Object&gt; result = shopDataService.queryData(code);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot; 查询结束，结果是：&quot; + result);</span><br><span class=\"line\">                &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot; 线程执行出现异常:&quot; + e.getMessage());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            thread.setName(&quot;price-thread-&quot; + code);</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">            // 启动后，倒计时器倒计数 减一，代表又有一个线程就绪了</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">先来个普通调用演示</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 商品数据服务类</span><br><span class=\"line\"> * @author lijing</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class ShopDataService &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    QueryServiceRemoteCall queryServiceRemoteCall;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 1000 用户请求，1000个线程</span><br><span class=\"line\">    public Map&lt;String, Object&gt; queryData(String shopDataId) throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">         return queryServiceRemoteCall.queryShopDataInfoByCode(shopDataId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">查询结果展示</span><br><span class=\"line\">开始测试</span><br><span class=\"line\">price-thread-code-3 查询结束，结果是：&#123;code=code-3, shopDataId=165800794, price=3000, isOk=true, name=小玩具&#125;</span><br><span class=\"line\">price-thread-code-994 查询结束，结果是：&#123;code=code-994, shopDataId=735455508, price=3000, isOk=true, name=小玩具&#125;</span><br><span class=\"line\">price-thread-code-36 查询结束，结果是：&#123;code=code-36, shopDataId=781610507, price=3000, isOk=true, name=小玩具&#125;</span><br><span class=\"line\">price-thread-code-993 查询结束，结果是：&#123;code=code-993, shopDataId=231087525, price=3000, isOk=true, name=小玩具&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....... 省略代码中。。。。</span><br><span class=\"line\"></span><br><span class=\"line\">price-thread-code-25 查询结束，结果是：&#123;code=code-25, shopDataId=149193873, price=3000, isOk=true, name=小玩具&#125;</span><br><span class=\"line\">price-thread-code-2 查询结束，结果是：&#123;code=code-2, shopDataId=324877405, price=3000, isOk=true, name=小玩具&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.......共计1000次的查询结果</span><br><span class=\"line\"></span><br><span class=\"line\">结束测试,执行时长：150</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>那么我们发现我们可以用<code>code</code>作为一个追踪<code>traceId</code>,然后使用</strong></li>\n</ul>\n<p><code>ScheduledExecutorService</code>,<code>CompletableFuture</code>,<code>LinkedBlockingQueue</code>等一些多线程技术，就可以实现这个请求合并，请求分发的简单实现demo.</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import javax.annotation.PostConstruct;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\">import java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 商品数据服务类</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author lijing</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class ShopDataService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Request &#123;</span><br><span class=\"line\">        String shopDataId;</span><br><span class=\"line\">        CompletableFuture&lt;Map&lt;String, Object&gt;&gt; completableFuture;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 集合，积攒请求，每N毫秒处理</span><br><span class=\"line\">    LinkedBlockingQueue&lt;Request&gt; queue = new LinkedBlockingQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostConstruct</span><br><span class=\"line\">    public void init() &#123;</span><br><span class=\"line\">        ScheduledExecutorService scheduledExecutorPool = Executors.newScheduledThreadPool(5);</span><br><span class=\"line\">        scheduledExecutorPool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">            // TODO 取出所有queue的请求，生成一次批量查询</span><br><span class=\"line\">            int size = queue.size();</span><br><span class=\"line\">            if (size == 0) &#123;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;此次合并了多少请求：&quot; + size);</span><br><span class=\"line\">            // 1、 取出</span><br><span class=\"line\">            ArrayList&lt;Request&gt; requests = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            ArrayList&lt;String&gt; shopDataIds = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            for (int i = 0; i &lt; size; i++) &#123;</span><br><span class=\"line\">                Request request = queue.poll();</span><br><span class=\"line\">                requests.add(request);</span><br><span class=\"line\">                shopDataIds.add(request.shopDataId);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 2、 组装一个批量查询 （不会比单次查询慢很多）</span><br><span class=\"line\">            List&lt;Map&lt;String, Object&gt;&gt; mapList = queryServiceRemoteCall.queryShopDataInfoByCodeBatch(shopDataIds);</span><br><span class=\"line\"></span><br><span class=\"line\">            // 3、 分发响应结果，给每一个request用户请求 （多线程 之间的通信）</span><br><span class=\"line\">            HashMap&lt;String, Map&lt;String, Object&gt;&gt; resultMap = new HashMap&lt;&gt;(); //  1000---- 007</span><br><span class=\"line\">            for (Map&lt;String, Object&gt; map : mapList) &#123;</span><br><span class=\"line\">                String code = map.get(&quot;code&quot;).toString();</span><br><span class=\"line\">                resultMap.put(code, map);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 1000个请求</span><br><span class=\"line\">            for (Request req : requests) &#123; </span><br><span class=\"line\">                Map&lt;String, Object&gt; result = resultMap.get(req.shopDataId);</span><br><span class=\"line\">                // 怎么通知对应的1000多个线程，取结果呢？</span><br><span class=\"line\">                req.completableFuture.complete(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, 0, 10, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    QueryServiceRemoteCall queryServiceRemoteCall;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 1000 用户请求，1000个线程</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param shopDataId</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     * @throws ExecutionException</span><br><span class=\"line\">     * @throws InterruptedException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public Map&lt;String, Object&gt; queryData(String shopDataId) throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        Request request = new Request();</span><br><span class=\"line\">        request.shopDataId = shopDataId;</span><br><span class=\"line\">        CompletableFuture&lt;Map&lt;String, Object&gt;&gt; future = new CompletableFuture&lt;&gt;();</span><br><span class=\"line\">        request.completableFuture = future;</span><br><span class=\"line\">        queue.add(request);</span><br><span class=\"line\">        // 等待其他线程通知拿结果</span><br><span class=\"line\">        return future.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>测试结果</strong></li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始测试</span><br><span class=\"line\">结束测试,执行时长：164</span><br><span class=\"line\"></span><br><span class=\"line\">此次合并了多少请求：63</span><br><span class=\"line\">此次合并了多少请求：227</span><br><span class=\"line\">此次合并了多少请求：32</span><br><span class=\"line\">此次合并了多少请求：298</span><br><span class=\"line\">此次合并了多少请求：68</span><br><span class=\"line\">此次合并了多少请求：261</span><br><span class=\"line\">此次合并了多少请求：51</span><br><span class=\"line\"></span><br><span class=\"line\">price-thread-code-747 查询结束，结果是：&#123;code=code-747, shopDataId=113980125, price=6000, isOk=true, name=棉花糖&#125;</span><br><span class=\"line\">price-thread-code-821 查询结束，结果是：&#123;code=code-821, shopDataId=568038265, price=6000, isOk=true, name=棉花糖&#125;</span><br><span class=\"line\">price-thread-code-745 查询结束，结果是：&#123;code=code-745, shopDataId=998247608, price=6000, isOk=true, name=棉花糖&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....... 省略代码中。。。。</span><br><span class=\"line\"></span><br><span class=\"line\">price-thread-code-809 查询结束，结果是：&#123;code=code-809, shopDataId=479029433, price=6000, isOk=true, name=棉花糖&#125;</span><br><span class=\"line\">price-thread-code-806 查询结束，结果是：&#123;code=code-806, shopDataId=929748878, price=6000, isOk=true, name=棉花糖&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a><strong>四、总结</strong></h2><p><strong>弊端：</strong> </p>\n<ul>\n<li>启用请求的成本是执行实际逻辑之前增加的延迟。</li>\n<li>如果平均仅需要5毫秒的执行时间，放在一个10毫秒的做一次批处理的合并场景下，则在最坏的情况下，执行时间可能会变为15毫秒。(一定不适合低延迟的RPC场景、一定不适合低并发场景)</li>\n</ul>\n<p><strong>场景:</strong></p>\n<ul>\n<li>如果很少有超过1或2个请求会并发在一起，则没有必要用。</li>\n<li>一个特定的查询同时被大量使用，并且可以将几+个甚至数百个批处理在一起，那么如果能接受处理时间变长一点点，用来减少网络连接欲，这是值得的。(典型如:数据库、Http接口）</li>\n</ul>\n<p><strong>扩展:</strong></p>\n<ul>\n<li>我们不重复造轮子，在SpringCloud的组件<code>spring-cloud-starter-netflix-hystrix</code>中已经有封装好的轮子<code>Hystrix</code>的<code>HystrixCollapser来实现请求的合并，以减少通信消耗和线程数的占用</code>。</li>\n<li>当然他的组件比较复杂，也更全面，支持异步，同步，超时，异常等的处理机制。</li>\n<li>但是，从底层思路来说，无非是线程之间的通信，线程的切换，队列等一些并发编程相关的技术，只要我们高度封装和抽象，那也可以手撸一个合并请求的框架处理。</li>\n</ul>\n","text":"用手写一个请求合并推荐阅读： 一、服务器崩溃的思考老板说，他要做个现场营销活动，线上线下都要参与推广，这个活动参与人数可能很大哦··· 果然，由于不是我写的代码...","permalink":"/post/JAVA/用手写一个请求合并","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"https","slug":"https","count":12,"path":"api/categories/https.json"},{"name":"JAVA","slug":"https/JAVA","count":5,"path":"api/categories/https/JAVA.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"pic","slug":"pic","count":2,"path":"api/tags/pic.json"},{"name":"zhimg","slug":"zhimg","count":2,"path":"api/tags/zhimg.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6\"><span class=\"toc-text\">用手写一个请求合并</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83%E7%9A%84%E6%80%9D%E8%80%83\"><span class=\"toc-text\">一、服务器崩溃的思考</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E6%9C%89%E4%BA%BA%E6%83%B3%E7%9C%8B%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6%EF%BC%8C%E4%BB%8A%E5%A4%A9%E5%A5%B9%E6%9D%A5%E4%BA%86\"><span class=\"toc-text\">二、有人想看请求合并，今天她来了</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%BC%80%E5%A7%8B%E6%BC%94%E7%BB%83\"><span class=\"toc-text\">三、开始演练</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">四、总结</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"influxdb内存消耗分析及性能优化","uid":"9736c920c0447b484184935c1c343c5b","slug":"MIDDLEWARE/influxdb内存消耗分析及性能优化","date":"2023-04-19T16:34:36.000Z","updated":"2025-12-05T01:47:40.565Z","comments":true,"path":"api/articles/MIDDLEWARE/influxdb内存消耗分析及性能优化.json","keywords":"XuGuangSheng","cover":"/covers/influxdb.jpg","text":"influxdb内存消耗分析及性能优化 influxdb目前支持内存型索引inmem及文件型索引tsi1。之前追踪篇将influxd索引修改为tsi1之后，经过...","permalink":"/post/MIDDLEWARE/influxdb内存消耗分析及性能优化","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"influxdb","slug":"influxdb","count":1,"path":"api/categories/influxdb.json"},{"name":"MIDDLEWARE","slug":"influxdb/MIDDLEWARE","count":1,"path":"api/categories/influxdb/MIDDLEWARE.json"}],"tags":[{"name":"CPU","slug":"CPU","count":3,"path":"api/tags/CPU.json"},{"name":"SHR","slug":"SHR","count":1,"path":"api/tags/SHR.json"},{"name":"influxd","slug":"influxd","count":2,"path":"api/tags/influxd.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Spring RestTemplate使用指南","uid":"a48fe76127f611e471ecf4672c3ea452","slug":"JAVA/Spring RestTemplate使用指南","date":"2023-04-07T14:56:26.000Z","updated":"2025-12-05T01:46:33.042Z","comments":true,"path":"api/articles/JAVA/Spring RestTemplate使用指南.json","keywords":"XuGuangSheng","cover":"/covers/spring-resttemplate.jpg","text":"Spring RestTemplate使用指南〇、介绍 spring-web框架下的一个http客户端，提供了一种通用的接口。 HTTP请求方式可以选择： 原生...","permalink":"/post/JAVA/Spring RestTemplate使用指南","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[{"name":"HttpMessageConverter","slug":"HttpMessageConverter","count":1,"path":"api/categories/HttpMessageConverter.json"},{"name":"JAVA","slug":"HttpMessageConverter/JAVA","count":1,"path":"api/categories/HttpMessageConverter/JAVA.json"}],"tags":[{"name":"HTTP","slug":"HTTP","count":2,"path":"api/tags/HTTP.json"},{"name":"ClientHttpRequestFactory","slug":"ClientHttpRequestFactory","count":1,"path":"api/tags/ClientHttpRequestFactory.json"},{"name":"MappingJackson","slug":"MappingJackson","count":1,"path":"api/tags/MappingJackson.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}