{"title":"async-profiler","uid":"142536715563d02ed2a04093bf771493","slug":"JAVA/async-profiler","date":"2021-08-17T15:15:33.000Z","updated":"2025-09-30T03:26:22.625Z","comments":true,"path":"api/articles/JAVA/async-profiler.json","keywords":"XuGuangSheng","cover":"/covers/async-profiler.jpg","content":"<h1 id=\"async-profiler\"><a href=\"#async-profiler\" class=\"headerlink\" title=\"async-profiler\"></a>async-profiler</h1><h2 id=\"​简介\"><a href=\"#​简介\" class=\"headerlink\" title=\"​简介\"></a>​简介</h2><p>async-profiler 是一款采集分析 java 性能的工具，翻译一下 github 上的项目介绍：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>❝</strong></p>\n<p>async-profiler 是一款没有<code>Safepoint bias problem</code>的<code>低开销</code>java 采集分析器，它利用<code>HotSpot</code>特殊的 api 来收集栈信息以及内存分配信息，可以在<code>OpenJDK</code>,<code>Oracle JDK</code>以及一些其他的基于 HotSpot 的 java 虚拟机。async-profiler 可以追踪以下几种事件：</p>\n<ul>\n<li>cpu 周期</li>\n<li>硬件和软件性能计数器，例如高速缓存未命中，分支未命中，页面错误，上下文切换等</li>\n<li>Java 堆中内存的分配</li>\n<li>锁尝试，包括 Java 对象监视器和 ReentrantLock</li>\n</ul>\n<p>❞</p></blockquote>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><p>首先下载 async-profiler，github 主页（<a href=\"https://github.com/jvm-profiling-tools/async-profiler\">https://github.com/jvm-profiling-tools/async-profiler</a>）上有已经编译好的文件，找到对应的平台下载即可</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/4827c2c78e50408c99698a90a0db9763.webp\"></p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>下载好的文件解压后，有一个<code>profiler.sh</code>脚本，运行脚本即可对 java 进程进行 cpu 分析，例如 java 进程 id 为 1232</p>\n<p><code>./profiler.sh start 1232``./profiler.sh stop 1232</code>  </p>\n<p>或者可以用<code>-d</code>指定剖析的时间（秒）</p>\n<p>执行完成后会输出采集的信息：</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/c6f7585838c8a34dd02e0372feaef830.webp\"></p>\n<p>通常我们会用更加直观的<code>火焰图</code>来绘制输出的信息，使用参数<code>-f &#123;$file_name&#125;.svg</code>  </p>\n<p>命令执行完成后会生成一个 svg 格式的文件，用浏览器打开</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/435d8310d425a5a28d8e2e97ec6c9985.webp\"></p>\n<p>火焰图怎么看？可以参考阮一峰的文章</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>❝</strong></p>\n<p>《如何读懂火焰图》 <a href=\"http://www.ruanyifeng.com/blog/2017/09/flame-graph.html\">http://www.ruanyifeng.com/blog/2017/09/flame-graph.html</a></p>\n<p>❞</p></blockquote>\n<p>简单来说：x 轴是抽样数，x 轴越长说明被这个方法被抽样的次数越多，消耗 cpu 时间也越长 y 轴是栈的深度，通常越往上越细，如果发现往上有一个<code>平顶</code>，且平顶很宽，则说明它可能有问题，消耗 cpu 时间较多。</p>\n<h3 id=\"其他参数介绍\"><a href=\"#其他参数介绍\" class=\"headerlink\" title=\"其他参数介绍\"></a>其他参数介绍</h3><ul>\n<li>-e event</li>\n</ul>\n<p>event 可选参数用这个命令来查看</p>\n<p>输出样例：</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/156cb83bc2725985eadbb7c8838c2f08.webp\"></p>\n<p>event 默认为 cpu，也可以用 alloc 来查看内存分配</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/e749f87f541057cf6593cf770f00dc31.webp\"></p>\n<p>lock 查看锁情况：</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/bbedefe37d824465dd7b04d27327a3cd.webp\"></p>\n<p>其他的模式这里就不一一尝试，用的最多的还是 cpu 模式。</p>\n<ul>\n<li><p>-i N 设置采样频率，默认是 10ms，可使用<code>ms</code>，<code>us</code>，<code>s</code>作为单位，无单位默认为纳秒，如</p>\n</li>\n<li><p>-j N 设置栈采样深度</p>\n</li>\n<li><p>-o fmt 设置输出格式：可选的有 <code>summary</code>、<code>traces</code>、<code>flat</code>、<code>jfr</code>、<code>collapsed</code>、<code>svg</code>、<code>tree</code>，最常用的是 svg</p>\n</li>\n</ul>\n<p>更多命令可参考 async-profiler github 主页</p>\n<h2 id=\"一次网关性能压测实例\"><a href=\"#一次网关性能压测实例\" class=\"headerlink\" title=\"一次网关性能压测实例\"></a>一次网关性能压测实例</h2><p>笔者有一次在压测全链路异步网关时，RPS 在 2000 左右，始终上不去，cpu 消耗比较高，于是使用 async-profiler 进行 cpu 剖析，生成的火焰图如下</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/9af52333581e928be928762c3d6f80df.webp\"></p>\n<p>可以看到这里有个宽又深的栈，它消耗了很多 cpu，限于图像大小，再往上拉，看下这块到底是什么</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/9ce64139f4787c7ee7c93cf8aea55a46.webp\"></p>\n<p>从类名就能看出是<code>log4j</code>，猜测是代码某处打日志过于频繁导致，找到打日志的地方后先去掉日志，压测了一下，果然 RPS 提升到了 5000，一处小小的日志竟有如此大的影响。</p>\n<h2 id=\"原理介绍\"><a href=\"#原理介绍\" class=\"headerlink\" title=\"原理介绍\"></a>原理介绍</h2><p>看到这里相信你应该会用 async-profiler 来进行 cpu 剖析了，如果感兴趣可以了解下 async-profiler 实现的原理，这块有一篇文章介绍的很详细，可以参考</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>❝</strong></p>\n<p>《JVM CPU Profiler 技术原理及源码深度解析》 <a href=\"https://mp.weixin.qq.com/s/RKqmy8dw7B7WtQc6Xy2CLA\">https://mp.weixin.qq.com/s/RKqmy8dw7B7WtQc6Xy2CLA</a></p>\n<p>❞</p></blockquote>\n<p>简单总结一下：</p>\n<ul>\n<li>cpu profiler 实现一般有两种方案：（1）Sampling，采样（2）Instrumentation，埋点；采样对性能损耗较小但没那么准确，埋点（类似 AOP）精准但性能影响大</li>\n<li>Sampling 采样只能在<code>Safe Ponit</code>处采样，会导致统计结果偏差，也就是开头说的<code>Safepoint bias problem</code>，例如某些方法执行时间短，但执行频率高，正真占用了 cpu，这部分如果 Sampling 的采样频率不能足够小，可能就采样不到，但采样频率过高又会影响性能，这就是一般的基于采样的 cpu profiler 的缺点</li>\n<li>async-profiler 是基于采样实现的，但它又没有<code>Safepoint bias problem</code>，它是通过一种叫做<code>AsyncGetCallTrace</code>的方式来采样，这种采样不需要在安全点处采样，但这个函数不是那么容易就调用到的，需要使用一些技巧（黑科技）的方式来获取</li>\n</ul>\n<p>正是第三点原因我才写了这篇文章来推荐这款<code>cpu 分析利器</code>，比如我用了一款其他的分析器（uber-common&#x2F;jvm-profiler）来分析上面网关的 cpu，得出了如下的火焰图</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/386bb933d407e2eb0ec5742da9c34db0.webp\"></p>\n<p> <a href=\"https://xie.infoq.cn/article/58d2a013a045d2ff3d542a6a1\">https://xie.infoq.cn/article/58d2a013a045d2ff3d542a6a1</a></p>\n","text":"async-profiler​简介async-profiler 是一款采集分析 java 性能的工具，翻译一下 github 上的项目介绍： ❝ async-p...","permalink":"/post/JAVA/async-profiler","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"profiler","slug":"profiler","count":1,"path":"api/categories/profiler.json"},{"name":"JAVA","slug":"profiler/JAVA","count":1,"path":"api/categories/profiler/JAVA.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"cpu","slug":"cpu","count":1,"path":"api/tags/cpu.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#async-profiler\"><span class=\"toc-text\">async-profiler</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%80%8B%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">​简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">使用方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">基本用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">其他参数介绍</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E6%AC%A1%E7%BD%91%E5%85%B3%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">一次网关性能压测实例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">原理介绍</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"InfluxDB 通识篇","uid":"8cbbd86cd3c93044bc5b65f7c8f71a1c","slug":"JAVA/InfluxDB 通识篇","date":"2021-08-23T15:09:05.000Z","updated":"2025-09-30T03:26:10.401Z","comments":true,"path":"api/articles/JAVA/InfluxDB 通识篇.json","keywords":"XuGuangSheng","cover":"/covers/influxdb.jpg","text":"InfluxDB 通识篇什么是时序数据库？时序数据库全称时间序列数据库，英文名 Time Series DataBase，缩写 TSDB。 这种数据库专门用作处...","permalink":"/post/JAVA/InfluxDB 通识篇","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"InfluxDB","slug":"InfluxDB","count":1,"path":"api/categories/InfluxDB.json"},{"name":"JAVA","slug":"InfluxDB/JAVA","count":1,"path":"api/categories/InfluxDB/JAVA.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"raw","slug":"raw","count":5,"path":"api/tags/raw.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"从Java多线程可见性谈Happens-Before原则","uid":"dbb584f30bfc75da44387b6e286da8d6","slug":"JAVA/从Java多线程可见性谈Happens-Before原则","date":"2021-08-16T16:25:22.000Z","updated":"2025-09-30T03:26:24.608Z","comments":true,"path":"api/articles/JAVA/从Java多线程可见性谈Happens-Before原则.json","keywords":"XuGuangSheng","cover":"/covers/javahappens-before.jpg","text":"从Java多线程可见性谈Happens-Before原则Happens-Before 是一个非常抽象的概念，然而它又是学习 Java 并发编程不可跨域的部分。本...","permalink":"/post/JAVA/从Java多线程可见性谈Happens-Before原则","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"CPU","slug":"CPU","count":5,"path":"api/categories/CPU.json"},{"name":"JAVA","slug":"CPU/JAVA","count":1,"path":"api/categories/CPU/JAVA.json"}],"tags":[{"name":"volatile","slug":"volatile","count":2,"path":"api/tags/volatile.json"},{"name":"Happens","slug":"Happens","count":1,"path":"api/tags/Happens.json"},{"name":"Before","slug":"Before","count":1,"path":"api/tags/Before.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}