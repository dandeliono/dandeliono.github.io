{"title":"Zookeeper客户端Curator使用详解","uid":"b3c9ac518ccca39bee20ee352e4467cb","slug":"JAVA/Zookeeper客户端Curator使用详解","date":"2022-10-07T14:04:24.000Z","updated":"2025-09-30T03:26:22.151Z","comments":true,"path":"api/articles/JAVA/Zookeeper客户端Curator使用详解.json","keywords":"XuGuangSheng","cover":"/covers/zookeepercurator.jpg","content":"<h1 id=\"Zookeeper客户端Curator使用详解-简书\"><a href=\"#Zookeeper客户端Curator使用详解-简书\" class=\"headerlink\" title=\"Zookeeper客户端Curator使用详解 - 简书\"></a>Zookeeper客户端Curator使用详解 - 简书</h1><p>Curator 是 Netflix 公司开源的一套 zookeeper 客户端框架，解决了很多 Zookeeper 客户端非常底层的细节开发工作，包括连接重连、反复注册 Watcher 和 NodeExistsException 异常等等。Patrixck Hunt（Zookeeper）以一句 “Guava is to Java that Curator to Zookeeper” 给 Curator 予高度评价。<br><strong>引子和趣闻：</strong><br>Zookeeper 名字的由来是比较有趣的，下面的片段摘抄自《从 PAXOS 到 ZOOKEEPER 分布式一致性原理与实践》一书：<br>Zookeeper 最早起源于雅虎的研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型的系统需要依赖一个类似的系统进行分布式协调，但是这些系统往往存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架。在立项初期，考虑到很多项目都是用动物的名字来命名的 (例如著名的 Pig 项目)，雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 Raghu Ramakrishnan 开玩笑说：再这样下去，我们这儿就变成动物园了。此话一出，大家纷纷表示就叫动物园管理员吧——因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而 Zookeeper 正好用来进行分布式环境的协调——于是，Zookeeper 的名字由此诞生了。</p>\n<p>Curator 无疑是 Zookeeper 客户端中的瑞士军刀，它译作 “馆长” 或者’’管理者’’，不知道是不是开发小组有意而为之，笔者猜测有可能这样命名的原因是说明 Curator 就是 Zookeeper 的馆长 (脑洞有点大：Curator 就是动物园的园长)。<br>Curator 包含了几个包：<br><strong>curator-framework：</strong> 对 zookeeper 的底层 api 的一些封装<br><strong>curator-client：</strong> 提供一些客户端的操作，例如重试策略等<br><strong>curator-recipes：</strong> 封装了一些高级特性，如：Cache 事件监听、选举、分布式锁、分布式计数器、分布式 Barrier 等<br>Maven 依赖 (使用 curator 的版本：2.12.0，对应 Zookeeper 的版本为：3.4.x，<strong>如果跨版本会有兼容性问题，很有可能导致节点操作失败</strong>)：</p>\n<pre><code> &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;\n            &lt;version&gt;2.12.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;\n            &lt;version&gt;2.12.0&lt;/version&gt;\n        &lt;/dependency&gt; \n</code></pre>\n<h2 id=\"创建会话\"><a href=\"#创建会话\" class=\"headerlink\" title=\"创建会话\"></a>创建会话</h2><h3 id=\"1-使用静态工程方法创建客户端\"><a href=\"#1-使用静态工程方法创建客户端\" class=\"headerlink\" title=\"1. 使用静态工程方法创建客户端\"></a>1. 使用静态工程方法创建客户端</h3><p>一个例子如下：</p>\n<pre><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\nCuratorFramework client =\nCuratorFrameworkFactory.newClient(\n                        connectionInfo,\n                        5000,\n                        3000,\n                        retryPolicy); \n</code></pre>\n<p>newClient 静态工厂方法包含四个主要参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>connectionString</td>\n<td>服务器列表，格式 host1:port1,host2:port2,…</td>\n</tr>\n<tr>\n<td>retryPolicy</td>\n<td>重试策略, 内建有四种重试策略, 也可以自行实现 RetryPolicy 接口</td>\n</tr>\n<tr>\n<td>sessionTimeoutMs</td>\n<td>会话超时时间，单位毫秒，默认 60000ms</td>\n</tr>\n<tr>\n<td>connectionTimeoutMs</td>\n<td>连接创建超时时间，单位毫秒，默认 60000ms</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-使用-Fluent-风格的-Api-创建会话\"><a href=\"#2-使用-Fluent-风格的-Api-创建会话\" class=\"headerlink\" title=\"2. 使用 Fluent 风格的 Api 创建会话\"></a>2. 使用 Fluent 风格的 Api 创建会话</h3><p>核心参数变为流式设置，一个列子如下：</p>\n<pre><code> RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n        CuratorFramework client =\n        CuratorFrameworkFactory.builder()\n                .connectString(connectionInfo)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build(); \n</code></pre>\n<h3 id=\"3-创建包含隔离命名空间的会话\"><a href=\"#3-创建包含隔离命名空间的会话\" class=\"headerlink\" title=\"3. 创建包含隔离命名空间的会话\"></a>3. 创建包含隔离命名空间的会话</h3><p>为了实现不同的 Zookeeper 业务之间的隔离，需要为每个业务分配一个独立的命名空间（<strong>NameSpace</strong>），即指定一个 Zookeeper 的根路径（官方术语：**<em>为 Zookeeper 添加 “Chroot” 特性</em>**）。例如（下面的例子）当客户端指定了独立命名空间为 “&#x2F;base”，那么该客户端对 Zookeeper 上的数据节点的操作都是基于该目录进行的。通过设置 Chroot 可以将客户端应用与 Zookeeper 服务端的一课子树相对应，在多个应用共用一个 Zookeeper 集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。</p>\n<pre><code>RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n        CuratorFramework client =\n        CuratorFrameworkFactory.builder()\n                .connectString(connectionInfo)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .namespace(&quot;base&quot;)\n                .build(); \n</code></pre>\n<h2 id=\"启动客户端\"><a href=\"#启动客户端\" class=\"headerlink\" title=\"启动客户端\"></a>启动客户端</h2><p>当创建会话成功，得到 client 的实例然后可以直接调用其 start( ) 方法：</p>\n<h2 id=\"数据节点操作\"><a href=\"#数据节点操作\" class=\"headerlink\" title=\"数据节点操作\"></a>数据节点操作</h2><h3 id=\"创建数据节点\"><a href=\"#创建数据节点\" class=\"headerlink\" title=\"创建数据节点\"></a>创建数据节点</h3><p><strong>Zookeeper 的节点创建模式：</strong> </p>\n<ul>\n<li>PERSISTENT：持久化</li>\n<li>PERSISTENT_SEQUENTIAL：持久化并且带序列号</li>\n<li>EPHEMERAL：临时</li>\n<li>EPHEMERAL_SEQUENTIAL：临时并且带序列号</li>\n</ul>\n<p>**创建一个节点，初始内容为空 **</p>\n<pre><code>client.create().forPath(&quot;path&quot;); \n</code></pre>\n<p>注意：如果没有设置节点属性，节点创建模式默认为持久化节点，内容默认为空</p>\n<p><strong>创建一个节点，附带初始化内容</strong></p>\n<pre><code>client.create().forPath(&quot;path&quot;,&quot;init&quot;.getBytes()); \n</code></pre>\n<p><strong>创建一个节点，指定创建模式（临时节点），内容为空</strong></p>\n<pre><code>client.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;path&quot;); \n</code></pre>\n<p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容</strong></p>\n<pre><code>client.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;path&quot;,&quot;init&quot;.getBytes()); \n</code></pre>\n<p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点</strong></p>\n<pre><code>client.create()\n      .creatingParentContainersIfNeeded()\n      .withMode(CreateMode.EPHEMERAL)\n      .forPath(&quot;path&quot;,&quot;init&quot;.getBytes()); \n</code></pre>\n<p>这个 creatingParentContainersIfNeeded() 接口非常有用，因为一般情况开发人员在创建一个子节点必须判断它的父节点是否存在，如果不存在直接创建会抛出 NoNodeException，使用 creatingParentContainersIfNeeded() 之后 Curator 能够自动递归创建所有所需的父节点。</p>\n<h3 id=\"删除数据节点\"><a href=\"#删除数据节点\" class=\"headerlink\" title=\"删除数据节点\"></a>删除数据节点</h3><p><strong>删除一个节点</strong></p>\n<pre><code>client.delete().forPath(&quot;path&quot;); \n</code></pre>\n<p>注意，此方法只能删除<strong>叶子节点</strong>，否则会抛出异常。</p>\n<p><strong>删除一个节点，并且递归删除其所有的子节点</strong></p>\n<pre><code>client.delete().deletingChildrenIfNeeded().forPath(&quot;path&quot;); \n</code></pre>\n<p><strong>删除一个节点，强制指定版本进行删除</strong></p>\n<pre><code>client.delete().withVersion(10086).forPath(&quot;path&quot;); \n</code></pre>\n<p><strong>删除一个节点，强制保证删除</strong></p>\n<pre><code>client.delete().guaranteed().forPath(&quot;path&quot;); \n</code></pre>\n<p>guaranteed() 接口是一个保障措施，只要客户端会话有效，那么 Curator 会在后台持续进行删除操作，直到删除节点成功。</p>\n<p><strong>注意：</strong> 上面的多个流式接口是可以自由组合的，例如：</p>\n<pre><code>client.delete().guaranteed().deletingChildrenIfNeeded().withVersion(10086).forPath(&quot;path&quot;); \n</code></pre>\n<h3 id=\"读取数据节点数据\"><a href=\"#读取数据节点数据\" class=\"headerlink\" title=\"读取数据节点数据\"></a>读取数据节点数据</h3><p><strong>读取一个节点的数据内容</strong></p>\n<pre><code>client.getData().forPath(&quot;path&quot;); \n</code></pre>\n<p>注意，此方法返的返回值是 byte[ ];</p>\n<p><strong>读取一个节点的数据内容，同时获取到该节点的 stat</strong></p>\n<pre><code>Stat stat = new Stat();\nclient.getData().storingStatIn(stat).forPath(&quot;path&quot;); \n</code></pre>\n<h3 id=\"更新数据节点数据\"><a href=\"#更新数据节点数据\" class=\"headerlink\" title=\"更新数据节点数据\"></a>更新数据节点数据</h3><p><strong>更新一个节点的数据内容</strong></p>\n<pre><code>client.setData().forPath(&quot;path&quot;,&quot;data&quot;.getBytes()); \n</code></pre>\n<p>注意：该接口会返回一个 Stat 实例</p>\n<p><strong>更新一个节点的数据内容，强制指定版本进行更新</strong></p>\n<pre><code>client.setData().withVersion(10086).forPath(&quot;path&quot;,&quot;data&quot;.getBytes()); \n</code></pre>\n<h3 id=\"检查节点是否存在\"><a href=\"#检查节点是否存在\" class=\"headerlink\" title=\"检查节点是否存在\"></a>检查节点是否存在</h3><pre><code>client.checkExists().forPath(&quot;path&quot;); \n</code></pre>\n<p>注意：该方法返回一个 Stat 实例，用于检查 ZNode 是否存在的操作. 可以调用额外的方法 (监控或者后台处理) 并在最后调用 forPath( )指定要操作的 ZNode</p>\n<h3 id=\"获取某个节点的所有子节点路径\"><a href=\"#获取某个节点的所有子节点路径\" class=\"headerlink\" title=\"获取某个节点的所有子节点路径\"></a>获取某个节点的所有子节点路径</h3><pre><code>client.getChildren().forPath(&quot;path&quot;); \n</code></pre>\n<p>注意：该方法的返回值为 List<String>, 获得 ZNode 的子节点 Path 列表。 可以调用额外的方法 (监控、后台处理或者获取状态 watch, background or get stat) 并在最后调用 forPath() 指定要操作的父 ZNode</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>CuratorFramework 的实例包含 inTransaction() 接口方法，调用此方法开启一个 ZooKeeper 事务. 可以复合 create, setData, check, and&#x2F;or delete 等操作然后调用 commit() 作为一个原子操作提交。一个例子如下：</p>\n<pre><code>client.inTransaction().check().forPath(&quot;path&quot;)\n      .and()\n      .create().withMode(CreateMode.EPHEMERAL).forPath(&quot;path&quot;,&quot;data&quot;.getBytes())\n      .and()\n      .setData().withVersion(10086).forPath(&quot;path&quot;,&quot;data2&quot;.getBytes())\n      .and()\n      .commit();\n</code></pre>\n<h3 id=\"异步接口\"><a href=\"#异步接口\" class=\"headerlink\" title=\"异步接口\"></a>异步接口</h3><p>上面提到的创建、删除、更新、读取等方法都是同步的，Curator 提供异步接口，引入了<strong>BackgroundCallback</strong>接口用于处理异步接口调用之后服务端返回的结果信息。<strong>BackgroundCallback</strong>接口中一个重要的回调值为 CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p>\n<p><strong>CuratorEventType</strong></p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>对应 CuratorFramework 实例的方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CREATE</td>\n<td>#create()</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>#delete()</td>\n</tr>\n<tr>\n<td>EXISTS</td>\n<td>#checkExists()</td>\n</tr>\n<tr>\n<td>GET_DATA</td>\n<td>#getData()</td>\n</tr>\n<tr>\n<td>SET_DATA</td>\n<td>#setData()</td>\n</tr>\n<tr>\n<td>CHILDREN</td>\n<td>#getChildren()</td>\n</tr>\n<tr>\n<td>SYNC</td>\n<td>#sync(String,Object)</td>\n</tr>\n<tr>\n<td>GET_ACL</td>\n<td>#getACL()</td>\n</tr>\n<tr>\n<td>SET_ACL</td>\n<td>#setACL()</td>\n</tr>\n<tr>\n<td>WATCHED</td>\n<td>#Watcher(Watcher)</td>\n</tr>\n<tr>\n<td>CLOSING</td>\n<td>#close()</td>\n</tr>\n</tbody></table>\n<p><strong>响应码 (#getResultCode())</strong></p>\n<table>\n<thead>\n<tr>\n<th>响应码</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>OK，即调用成功</td>\n</tr>\n<tr>\n<td>-4</td>\n<td>ConnectionLoss，即客户端与服务端断开连接</td>\n</tr>\n<tr>\n<td>-110</td>\n<td>NodeExists，即节点已经存在</td>\n</tr>\n<tr>\n<td>-112</td>\n<td>SessionExpired，即会话过期</td>\n</tr>\n</tbody></table>\n<p>一个异步创建节点的例子如下：</p>\n<pre><code>Executor executor = Executors.newFixedThreadPool(2);\nclient.create()\n      .creatingParentsIfNeeded()\n      .withMode(CreateMode.EPHEMERAL)\n      .inBackground((curatorFramework, curatorEvent) -&gt; &#123;      System.out.println(String.format(&quot;eventType:%s,resultCode:%s&quot;,curatorEvent.getType(),curatorEvent.getResultCode()));\n      &#125;,executor)\n      .forPath(&quot;path&quot;); \n</code></pre>\n<p>注意：如果 #inBackground() 方法不指定 executor，那么会默认使用 Curator 的 EventThread 去进行异步处理。</p>\n<h2 id=\"Curator-食谱-高级特性\"><a href=\"#Curator-食谱-高级特性\" class=\"headerlink\" title=\"Curator 食谱 (高级特性)\"></a>Curator 食谱 (高级特性)</h2><p><strong>提醒：首先你必须添加 curator-recipes 依赖，下文仅仅对 recipes 一些特性的使用进行解释和举例，不打算进行源码级别的探讨</strong></p>\n<pre><code> &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;\n            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;\n            &lt;version&gt;2.12.0&lt;/version&gt;\n        &lt;/dependency&gt; \n</code></pre>\n<p><strong>重要提醒：强烈推荐使用 ConnectionStateListener 监控连接的状态，当连接状态为 LOST，curator-recipes 下的所有 Api 将会失效或者过期，尽管后面所有的例子都没有使用到 ConnectionStateListener。</strong> </p>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><p>Zookeeper 原生支持通过注册 Watcher 来进行事件监听，但是开发者需要反复注册 (Watcher 只能单次注册单次使用)。Cache 是 Curator 中对事件监听的包装，可以看作是对事件监听的本地缓存视图，能够自动为开发者处理反复注册监听。Curator 提供了三种 Watcher(Cache) 来监听结点的变化。</p>\n<h4 id=\"Path-Cache\"><a href=\"#Path-Cache\" class=\"headerlink\" title=\"Path Cache\"></a>Path Cache</h4><p>Path Cache 用来监控一个 ZNode 的子节点. 当一个子节点增加， 更新，删除时， Path Cache 会改变它的状态， 会包含最新的子节点， 子节点的数据和状态，而状态的更变将通过 PathChildrenCacheListener 通知。</p>\n<p>实际使用时会涉及到四个类：</p>\n<ul>\n<li>PathChildrenCache</li>\n<li>PathChildrenCacheEvent</li>\n<li>PathChildrenCacheListener</li>\n<li>ChildData</li>\n</ul>\n<p>通过下面的构造函数创建 Path Cache:</p>\n<pre><code>public PathChildrenCache(CuratorFramework client, String path, boolean cacheData) \n</code></pre>\n<p>想使用 cache，必须调用它的<code>start</code>方法，使用完后调用<code>close</code>方法。 可以设置 StartMode 来实现启动的模式<br> <a href=\"https://www.jianshu.com/p/70151fc0ef5d\">https://www.jianshu.com/p/70151fc0ef5d</a></p>\n","text":"Zookeeper客户端Curator使用详解 - 简书Curator 是 Netflix 公司开源的一套 zookeeper 客户端框架，解决了很多 Zook...","permalink":"/post/JAVA/Zookeeper客户端Curator使用详解","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"Zookeeper","slug":"Zookeeper","count":2,"path":"api/categories/Zookeeper.json"},{"name":"JAVA","slug":"Zookeeper/JAVA","count":2,"path":"api/categories/Zookeeper/JAVA.json"}],"tags":[{"name":"Curator","slug":"Curator","count":2,"path":"api/tags/Curator.json"},{"name":"注意","slug":"注意","count":1,"path":"api/tags/注意.json"},{"name":"Cache","slug":"Cache","count":2,"path":"api/tags/Cache.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AFCurator%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3-%E7%AE%80%E4%B9%A6\"><span class=\"toc-text\">Zookeeper客户端Curator使用详解 - 简书</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E4%BC%9A%E8%AF%9D\"><span class=\"toc-text\">创建会话</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">1. 使用静态工程方法创建客户端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8-Fluent-%E9%A3%8E%E6%A0%BC%E7%9A%84-Api-%E5%88%9B%E5%BB%BA%E4%BC%9A%E8%AF%9D\"><span class=\"toc-text\">2. 使用 Fluent 风格的 Api 创建会话</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%88%9B%E5%BB%BA%E5%8C%85%E5%90%AB%E9%9A%94%E7%A6%BB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BC%9A%E8%AF%9D\"><span class=\"toc-text\">3. 创建包含隔离命名空间的会话</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%AF%E5%8A%A8%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">启动客户端</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">数据节点操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">创建数据节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">删除数据节点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">读取数据节点数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">更新数据节点数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A3%80%E6%9F%A5%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8\"><span class=\"toc-text\">检查节点是否存在</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">获取某个节点的所有子节点路径</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">事务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">异步接口</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Curator-%E9%A3%9F%E8%B0%B1-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Curator 食谱 (高级特性)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Path-Cache\"><span class=\"toc-text\">Path Cache</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Spring Spring boot正确集成Quartz及解决Autowired失效问题","uid":"d8866dac3e3d178ff93b0801099e3728","slug":"JAVA/Spring Spring boot正确集成Quartz及解决@Autowired失效问题","date":"2022-10-07T14:04:24.000Z","updated":"2025-09-30T03:26:19.047Z","comments":true,"path":"api/articles/JAVA/Spring Spring boot正确集成Quartz及解决@Autowired失效问题.json","keywords":"XuGuangSheng","cover":"/covers/spring-spring-bootquartz-autowired.jpg","text":"Spring/Spring boot正确集成Quartz及解决@Autowired失效问题 - 从此寂静无声 - 博客园quartz(1) 项目依赖: 1234...","permalink":"/post/JAVA/Spring Spring boot正确集成Quartz及解决@Autowired失效问题","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Spring","slug":"Spring","count":4,"path":"api/categories/Spring.json"},{"name":"JAVA","slug":"Spring/JAVA","count":4,"path":"api/categories/Spring/JAVA.json"}],"tags":[{"name":"Quartz","slug":"Quartz","count":1,"path":"api/tags/Quartz.json"},{"name":"Job","slug":"Job","count":1,"path":"api/tags/Job.json"},{"name":"SpringBeanJobFactory","slug":"SpringBeanJobFactory","count":1,"path":"api/tags/SpringBeanJobFactory.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"使用spring validation完成数据后端校验","uid":"0432547e86941bc1570c73863bb3d6ac","slug":"JAVA/使用spring validation完成数据后端校验","date":"2022-10-07T14:04:24.000Z","updated":"2025-09-30T03:26:24.848Z","comments":true,"path":"api/articles/JAVA/使用spring validation完成数据后端校验.json","keywords":"XuGuangSheng","cover":"/covers/spring-validation.jpg","text":"使用spring validation完成数据后端校验_徐靖峰的专栏-CSDN博客前言数据的校验是交互式网站一个不可或缺的功能，前端的 js 校验可以涵盖大部分...","permalink":"/post/JAVA/使用spring validation完成数据后端校验","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"validation","slug":"validation","count":1,"path":"api/categories/validation.json"},{"name":"JAVA","slug":"validation/JAVA","count":1,"path":"api/categories/validation/JAVA.json"}],"tags":[{"name":"spring","slug":"spring","count":4,"path":"api/tags/spring.json"},{"name":"JSR","slug":"JSR","count":1,"path":"api/tags/JSR.json"},{"name":"hibernate","slug":"hibernate","count":1,"path":"api/tags/hibernate.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}