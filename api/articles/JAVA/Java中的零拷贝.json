{"title":"Java中的零拷贝","uid":"37fc72851c01fae66c3f1f8cc79de26f","slug":"JAVA/Java中的零拷贝","date":"2023-07-21T14:02:55.000Z","updated":"2025-09-30T03:26:12.619Z","comments":true,"path":"api/articles/JAVA/Java中的零拷贝.json","keywords":"XuGuangSheng","cover":"/covers/java.jpg","content":"<h1 id=\"Java中的零拷贝\"><a href=\"#Java中的零拷贝\" class=\"headerlink\" title=\"Java中的零拷贝\"></a>Java中的零拷贝</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>先提出两个问题：<br>IO过程中，哪些步骤进行了拷贝？哪些地方零拷贝？<br>Java支持哪些零拷贝？</p></blockquote>\n<p>带着这俩问题，我们一起来看下面的探究。</p>\n<h6 id=\"哪里听说过零拷贝-真的0次拷贝吗\"><a href=\"#哪里听说过零拷贝-真的0次拷贝吗\" class=\"headerlink\" title=\"哪里听说过零拷贝?真的0次拷贝吗?\"></a>哪里听说过零拷贝?真的0次拷贝吗?</h6><p>相信大家伙在以往的学习中，或多或少在下面这些组件、框架中有听说过零拷贝 (Zero-Copy)?</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Kafka<br>Netty<br>rocketmq<br>nginx<br>apache</p></blockquote>\n<h4 id=\"什么是零拷贝\"><a href=\"#什么是零拷贝\" class=\"headerlink\" title=\"什么是零拷贝?\"></a>什么是零拷贝?</h4><p>零拷贝(英语: Zero-copy) 技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p>\n<p>➢零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率<br>➢零拷贝技术减少了用户进程地址空间和内核地址空间之间因为上:下文切换而带来的开销<br><code>可以看出没有说不需要拷贝，只是说减少冗余[不必要]的拷贝。</code></p>\n<h4 id=\"LinuxI-x2F-O机制及零拷贝介绍\"><a href=\"#LinuxI-x2F-O机制及零拷贝介绍\" class=\"headerlink\" title=\"LinuxI&#x2F;O机制及零拷贝介绍\"></a>LinuxI&#x2F;O机制及零拷贝介绍</h4><h6 id=\"IO中断与DMA\"><a href=\"#IO中断与DMA\" class=\"headerlink\" title=\"IO中断与DMA\"></a>IO中断与DMA</h6><p>IO中断，需要CPU响应，需要CPU参与，因此效率比较低。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-38949a432035e034.png\"></p>\n<p>用户进程需要读取磁盘数据，需要CPU中断，发起IO请求，每次的IO中断，都带来CPU的上下文切换。</p>\n<p><strong>因此出现了——DMA。</strong> </p>\n<p>DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于CPU 的大量中断负载。<br>DMA控制器，接管了数据读写请求，减少CPU的负担。这样一来，CPU能高效工作了。<br>现代硬盘基本都支持DMA。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-f48301773e474195.png\"></p>\n<h6 id=\"Linux-IO流程\"><a href=\"#Linux-IO流程\" class=\"headerlink\" title=\"Linux IO流程\"></a>Linux IO流程</h6><p>实际因此IO读取，涉及两个过程：<br>1、DMA等待数据准备好，把磁盘数据读取到操作系统内核缓冲区；<br>2、用户进程，将内核缓冲区的数据copy到用户空间。<br>这两个过程，都是阻塞的。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-5f237f9440c7c76f.png\"></p>\n<h6 id=\"传统数据传送\"><a href=\"#传统数据传送\" class=\"headerlink\" title=\"传统数据传送\"></a>传统数据传送</h6><p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-6f4829e267ec4af6.png\"></p>\n<p>比如：读取文件，再用socket发送出去<br>传统方式实现：<br>先读取、再发送，实际经过1~4四次copy。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer = <span class=\"built_in\">File</span>.read </span><br><span class=\"line\">Socket.<span class=\"built_in\">send</span>(buffer) </span><br></pre></td></tr></table></figure>\n\n<p>1、第一次：将磁盘文件，读取到操作系统内核缓冲区；<br>2、第二次：将内核缓冲区的数据，copy到application应用程序的buffer；<br>3、第三步：将application应用程序buffer中的数据，copy到socket网络发送缓冲区(属于操作系统内核的缓冲区)；<br>4、第四次：将socket buffer的数据，copy到网卡，由网卡进行网络传输。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-64d12784414e7087.png\"></p>\n<p>传统方式，读取磁盘文件并进行网络发送，经过的四次数据copy是非常繁琐的。实际IO读写，需要进行IO中断，需要CPU响应中断(带来上下文切换)，尽管后来引入DMA来接管CPU的中断请求，但四次copy是存在“不必要的拷贝”的。</p>\n<p>重新思考传统IO方式，会注意到实际上并不需要第二个和第三个数据副本。应用程序除了缓存数据并将其传输回套接字缓冲区之外什么都不做。相反，数据可以直接从读缓冲区传输到套接字缓冲区。</p>\n<p>显然，第二次和第三次数据copy 其实在这种场景下没有什么帮助反而带来开销，这也正是零拷贝出现的背景和意义。</p>\n<p>传统数据传送所消耗的成本：4次拷贝，4次上下文切换。<br>4次拷贝，其中两次是DMA copy，两次是CPU copy。如下图所示<br>拷贝是个IO过程，需要系统调用。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-2bb73cd8b61c2315.png\"></p>\n<p>注意一点的是 内核从磁盘上面读取数据 是 不消耗CPU时间的，是通过磁盘控制器完成；称之为DMA Copy。<br>网卡发送也用DMA。</p>\n<h4 id=\"零拷贝的出现\"><a href=\"#零拷贝的出现\" class=\"headerlink\" title=\"零拷贝的出现\"></a>零拷贝的出现</h4><p>目的：减少IO流程中不必要的拷贝<br>零拷贝需要OS支持，也就是需要kernel暴露api。虚拟机不能操作内核，</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-93e9e29cf41ee186.png\"></p>\n<h4 id=\"Linux支持的-常见-零拷贝\"><a href=\"#Linux支持的-常见-零拷贝\" class=\"headerlink\" title=\"Linux支持的(常见)零拷贝\"></a>Linux支持的(常见)零拷贝</h4><h6 id=\"一、mmap内存映射\"><a href=\"#一、mmap内存映射\" class=\"headerlink\" title=\"一、mmap内存映射\"></a>一、mmap内存映射</h6><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>data loaded from disk is stored in a kernel buffer by DMA copy. Then the pages of the application buffer are mapped to the kernel buffer, so that the data copy between kernel buffers and application buffers are omitted.</p></blockquote>\n<p>DMA加载磁盘数据到kernel buffer后，应用程序缓冲区(application buffers)和内核缓冲区(kernel buffer)进行映射，数据再应用缓冲区和内核缓存区的改变就能省略。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-73a3298b625f9e79.png\"></p>\n<p>mmap内存映射将会经历：3次拷贝: 1次cpu copy，2次DMA copy；<br>以及4次上下文切换</p>\n<h6 id=\"二、sendfile\"><a href=\"#二、sendfile\" class=\"headerlink\" title=\"二、sendfile\"></a>二、sendfile</h6><p>linux 2.1支持的sendfile</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>when calling the sendfile() system call, data are fetched from disk and copied into a kernel buffer by DMA copy. Then data are copied directly from the kernel buffer to the socket buffer. Once all data are copied into the socket buffer, the sendfile() system call will return to indicate the completion of data transfer from the kernel buffer to socket buffer. Then, data will be copied to the buffer on the network card and transferred to the network.</p></blockquote>\n<p>当调用sendfile()时，DMA将磁盘数据复制到kernel buffer，然后将内核中的kernel buffer直接拷贝到socket buffer；<br>一旦数据全都拷贝到socket buffer，sendfile()系统调用将会return、代表数据转化的完成。<br>socket buffer里的数据就能在网络传输了。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-6e11745803f19ae9.png\"></p>\n<p>sendfile会经历：3次拷贝，1次CPU copy 2次DMA copy；<br>以及2次上下文切换</p>\n<h6 id=\"三、Sendfile-With-DMA-Scatter-x2F-Gather-Copy\"><a href=\"#三、Sendfile-With-DMA-Scatter-x2F-Gather-Copy\" class=\"headerlink\" title=\"三、Sendfile With DMA Scatter&#x2F;Gather Copy\"></a>三、Sendfile With DMA Scatter&#x2F;Gather Copy</h6><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Then by using the DMA scatter&#x2F;gather operation, the network interface card can gather all the data from different memory locations and store the assembled packet in the network card buffer.</p></blockquote>\n<p>Scatter&#x2F;Gather可以看作是sendfile的增强版，批量sendfile。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-bd7a14fad6369f67.png\"></p>\n<p>Scatter&#x2F;Gather会经历2次拷贝: 0次cpu copy，2次DMA copy</p>\n<p><strong>IO请求批量化</strong><br>DMA scatter&#x2F;gather：需要DMA控制器支持的。<br>DMA工作流程：cpu发送IO请求给DMA，DMA然后读取数据。<br>IO请求：相当于可以看作包含一个物理地址。<br>从一系列物理地址(10)读数据:普通的DMA (10请求)<br>dma scatter&#x2F;gather:一次给10个物理地址， 一个请求就可以（批量处理）。</p>\n<h6 id=\"4、splice\"><a href=\"#4、splice\" class=\"headerlink\" title=\"4、splice\"></a>4、splice</h6><p>Linux 2.6.17 支持splice</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>it does not need to copy data between kernel space and user space.<br>When using this approach, data are copied from disk to kernel buffer first. Then the splice() system call allows data to move between different buffers in kernel space without the copy to user space.<br>Unlike the method sendfile() with DMA scatter&#x2F;gather copy, splice() does not need support from hardware.</p></blockquote>\n<p>数据从磁盘读取到OS内核缓冲区后，在内核缓冲区直接可将其转成内核空间其他数据buffer，而不需要拷贝到用户空间。<br>如下图所示，从磁盘读取到内核buffer后，在内核空间直接与socket buffer建立pipe管道。<br>和sendfile()不同的是，splice()不需要硬件支持。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-fdb8993b1be81ede.png\"></p>\n<p>注意splice和sendfile的不同，sendfile是将磁盘数据加载到kernel buffer后，需要一次CPU copy,拷贝到socket buffer。<br>而splice是更进一步，连这个CPU copy也不需要了，直接将两个内核空间的buffer进行set up pipe。</p>\n<p>splice会经历 2次拷贝: 0次cpu copy 2次DMA copy；<br>以及2次上下文切换</p>\n<p><strong>Linux零拷贝机制对比</strong><br>无论是传统IO方式，还是引入零拷贝之后，2次DMA copy 是都少不了的。因为两次DMA都是依赖硬件完成的。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-073eedc607ffdbab.png\"></p>\n<h4 id=\"零拷贝的广义狭义之分\"><a href=\"#零拷贝的广义狭义之分\" class=\"headerlink\" title=\"零拷贝的广义狭义之分\"></a>零拷贝的广义狭义之分</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-da377c480bfb41aa.png\"></p>\n<p>实际上，零拷贝时有广义和狭义之分的。<br>广义零拷贝： 能减少拷贝次数，减少不必要的数据拷贝，就算作“零拷贝”。<br>这是目前，对零拷贝最为广泛的定义，我们需要知道的是，这是广义上的零拷贝，并不是操作系统 意义上的零拷贝。</p>\n<h6 id=\"零拷贝的广义性\"><a href=\"#零拷贝的广义性\" class=\"headerlink\" title=\"零拷贝的广义性\"></a>零拷贝的广义性</h6><p>最早的零拷贝定义，来源于</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Linux 2.4内核新增 sendfile 系统调用，提供了零拷贝。磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer(socket buffer)，无需 CPU 拷贝。这也是零拷贝这一说法的来源。这是真正操作系统 意义上的零拷贝(也就是狭义零拷贝)。</p></blockquote>\n<p>但是我们知道，由OS内核提供的 操作系统意义上的零拷贝，发展到目前也并没有很多种，也就是这样的零拷贝并不是很多；</p>\n<p>随着发展，零拷贝的概念得到了延伸，就是目前的<code>减少不必要的数据拷贝</code>都算作零拷贝的范畴；</p>\n<p>糟糕的是，一些开发者、机构、某些框架，在产品推广或竞争中“滥用”零拷贝这个概念，包装并美其名曰“性能…有多高，采用零拷贝…”</p>\n<p>尤其在框架孵化、推广初期，和竞对争夺市场时，这样的宣传似乎会让不是很内行的人 不明觉厉。</p>\n<p>今天提及的目的，是要大家明白，在看到xxx框架底层采用零拷贝时，或许并不是真正意义上的零拷贝，或许只是借用概念。</p>\n<p>在此说明，并不是否认某些框架借用概念的行为，毕竟随着发展，零拷贝的概念得到了延伸，容纳了新的东西。</p>\n<p>想要强调的是，作为一线技术者，应该不被几句宣传蒙蔽双眼；需要清晰的知道，数据合并以减少拷贝和内核提供的API、在性能提升方面还是有天壤之别的。</p>\n<p>若能稍作深入了解，便能识透其真相，究竟只是<code>偏向于优化数据操作</code>，还是真正切合场景、灵活运用了操作系统意义上的零拷贝，都会浮出水面了。</p>\n<p>后文，也会对目前使用了零拷贝的常见框架进行分析。</p>\n<h4 id=\"Java零拷贝机制解析\"><a href=\"#Java零拷贝机制解析\" class=\"headerlink\" title=\"Java零拷贝机制解析\"></a>Java零拷贝机制解析</h4><p>Linux提供的领拷贝技术 Java并不是全支持，支持2种(内存映射mmap、sendfile)；</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-e0f280739862a83f.png\"></p>\n<h6 id=\"NIO提供的内存映射-MappedByteBuffer\"><a href=\"#NIO提供的内存映射-MappedByteBuffer\" class=\"headerlink\" title=\"NIO提供的内存映射 MappedByteBuffer\"></a>NIO提供的内存映射 MappedByteBuffer</h6><ul>\n<li>首先要说明的是，JavaNlO中 的Channel (通道)就相当于操作系统中的内核缓冲区，有可能是读缓冲区，也有可能是网络缓冲区，而Buffer就相当于操作系统中的用户缓冲区。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MappedByteBuffer mappedByteBuffer = <span class=\"built_in\">new</span> RandomAccessFile(file, <span class=\"string\">&quot;r&quot;</span>) </span><br><span class=\"line\">                                 .getChannel() </span><br><span class=\"line\">                                .<span class=\"keyword\">map</span>(FileChannel.MapMode.READ_ONLY, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>); </span><br></pre></td></tr></table></figure>\n\n<p>底层就是调用Linux mmap()实现的。</p>\n<p>NIO中的FileChannel.map()方法其实就是采用了操作系统中的内存映射方式，底层就是调用Linux mmap()实现的。</p>\n<p>将内核缓冲区的内存和用户缓冲区的内存做了一个地址映射。这种方式适合读取大文件，同时也能对文件内容进行更改，但是如果其后要通过SocketChannel发送，还是需要CPU进行数据的拷贝。<br>使用MappedByteBuffer，小文件，效率不高；一个进程访问，效率也不高。</p>\n<p>MappedByteBuffer只能通过调用FileChannel的map()取得，再没有其他方式。<br>FileChannel.map()是抽象方法，具体实现是在 FileChannelImpl.c 可自行查看JDK源码，其map0()方法就是调用了Linux内核的mmap的API。<br>使用 MappedByteBuffer类要注意的是：mmap的文件映射，在full gc时才会进行释放。当close时，需要手动清除内存映射文件，可以反射调用sun.misc.Cleaner方法。</p>\n<h6 id=\"NIO提供的sendfile\"><a href=\"#NIO提供的sendfile\" class=\"headerlink\" title=\"NIO提供的sendfile\"></a>NIO提供的sendfile</h6><ul>\n<li>FileChannel.transferTo()方法直接将当前通道内容传输到另一个通道，没有涉及到Buffer的任何操作，NIO中 的Buffer是JVM堆或者堆外内存，但不论如何他们都是操作系统内核空间的内存</li>\n<li>transferTo()的实现方式就是通过系统调用sendfile() (当然这是Linux中的系统调用)</li>\n</ul>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> FileChannel sourceChannel = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"keyword\">source</span>, <span class=\"string\">&quot;rw&quot;</span>).getChannel();</span><br><span class=\"line\">SocketChannel socketChannel = SocketChannel.open(sa);</span><br><span class=\"line\">sourceChannel.transferTo(<span class=\"number\">0</span>, sourceChannel.<span class=\"keyword\">size</span>(), socketChannel); </span><br></pre></td></tr></table></figure>\n\n<p><strong>ZeroCopyFile实现文件复制</strong></p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">ZeroCopyFile</span> &#123;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">    public void copyFile(<span class=\"type\">File</span> <span class=\"title\">src</span>, <span class=\"type\">File</span> <span class=\"title\">dest</span>) &#123;</span></span><br><span class=\"line\"><span class=\"class\">        try (<span class=\"type\">FileChannel</span> <span class=\"title\">srcChannel</span> = <span class=\"title\">new</span> <span class=\"type\">FileInputStream(src)</span>.<span class=\"title\">getChannel</span>();</span></span><br><span class=\"line\"><span class=\"class\">             <span class=\"type\">FileChannel</span> destChannel = new <span class=\"type\">FileInputStream</span>(<span class=\"title\">dest</span>).getChannel()) &#123;</span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">            srcChannel.transferTo(0, <span class=\"title\">srcChannel</span>.<span class=\"title\">size</span>(), destChannel);</span></span><br><span class=\"line\"><span class=\"class\">        &#125; catch (<span class=\"type\">IOException</span> <span class=\"title\">e</span>) &#123;</span></span><br><span class=\"line\"><span class=\"class\">            e.printStackTrace();</span></span><br><span class=\"line\"><span class=\"class\">        &#125;</span></span><br><span class=\"line\"><span class=\"class\">    &#125;</span></span><br><span class=\"line\"><span class=\"class\">&#125; </span></span><br></pre></td></tr></table></figure>\n\n<p>注意： Java NIO提供的FileChannel.transferTo 和 transferFrom 并不保证一定能使用零拷贝。实际上是否能使用零拷贝与操作系统相关，如果操作系统提供 sendfile 这样的零拷贝系统调用，则这两个方法会通过这样的系统调用充分利用零拷贝的优势，否则并不能通过这两个方法本身实现零拷贝。</p>\n<hr>\n<h4 id=\"Kafka中的零拷贝\"><a href=\"#Kafka中的零拷贝\" class=\"headerlink\" title=\"Kafka中的零拷贝\"></a>Kafka中的零拷贝</h4><p>Kafka两个重要过程都使用了零拷贝技术，且都是操作系统层面的狭义零拷贝，一是Producer生产的数据存到broker，二是 Consumer从broker读取数据。</p>\n<ul>\n<li>Producer生产的数据持久化到broker，采用mmap文件映射，实现顺序的快速写入；</li>\n<li>Customer从broker读取数据，采用sendfile，将磁盘文件读到OS内核缓冲区后，直接转到socket buffer进行网络发送。</li>\n</ul>\n<p>深入学习请移步 <a href=\"https://www.jianshu.com/p/1c27da322767\">https://www.jianshu.com/p/1c27da322767</a></p>\n<h4 id=\"Netty中的零拷贝\"><a href=\"#Netty中的零拷贝\" class=\"headerlink\" title=\"Netty中的零拷贝\"></a>Netty中的零拷贝</h4><p>Netty中的Zero-copy与上面我们所提到到OS层面上的Zero-copy不太一样, Netty的Zero-copy完全是在用户态(Java层面)的，它的Zero-copy的更多的是偏向于优化数据操作这样的概念。</p>\n<p>Netty的Zero-copy体现在如下几个个方面:</p>\n<ul>\n<li>Netty提供了CompositeByteBuf类，它可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝。</li>\n<li>通过wrap操作，我们可以将byte[]数组、ByteBuf、 ByteBuffer 等包装成一个 Netty ByteBuf对象，进而避免了拷贝操作。</li>\n<li>ByteBuf支持slice 操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。</li>\n<li>通过FileRegion包装的FileChannel.tranferTo实现文件传输，可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li>\n</ul>\n<p>认真阅读的读者，一定能够知道：<br><strong>前三个都是 广义零拷贝，都是减少不必要数据copy；偏向于应用层数据优化的操作。</strong><br>FileRegion包装的FileChannel.tranferTo，才是真正的零拷贝。下面我们分别来看其每一种实现。<br>下面的分析，也不会刻意区别广义零拷贝和狭义零拷贝，读者只需要了解二者的区别，及其各自的实现对我们应用程序的影响即可。</p>\n<h6 id=\"通过CompositeByteBuf实现零拷贝\"><a href=\"#通过CompositeByteBuf实现零拷贝\" class=\"headerlink\" title=\"通过CompositeByteBuf实现零拷贝\"></a>通过CompositeByteBuf实现零拷贝</h6><ul>\n<li>将多个ByteBuf合并为一个逻辑上的ByteBuf，简单理解就是类似于用一个链表，把分散的多个ByteBuf通过引用连接起来；</li>\n<li>分散的多个ByteBuf在内存中可能是大小各异、互不相连的区域，通过链表串联起来，作为一整块逻辑上的大区域。</li>\n<li>而在实际数据读取时，还是会去各自每一小块上读取。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-3edd3b49a6d7fc1f.png\"></p>\n<h6 id=\"通过wrap操作实现零拷贝\"><a href=\"#通过wrap操作实现零拷贝\" class=\"headerlink\" title=\"通过wrap操作实现零拷贝\"></a>通过wrap操作实现零拷贝</h6><ul>\n<li>将byte[]数组、ByteBuf、 ByteBuffer 等包装成一个 Netty ByteBuf对象；</li>\n<li>这个比较简单，看过ByteBuf源码的同学一定会知道，ByteBuf其实就是组合(包含)了byte[]；</li>\n<li>通过 Unpooled.wrappedBuffer 方法来将 bytes 包装成为一个 UnpooledHeapByteBuf 对象, 而在包装的过程中, 是不会有拷贝操作的. 即最后我们生成的生成的 ByteBuf 对象是和 bytes 数组共用了同一个存储空间, 对 bytes 的修改也会反映到 ByteBuf 对象中.</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-f7ccacf4ada530c2.png\"></p>\n<h6 id=\"通过slice操作实现零拷贝\"><a href=\"#通过slice操作实现零拷贝\" class=\"headerlink\" title=\"通过slice操作实现零拷贝\"></a>通过slice操作实现零拷贝</h6><ul>\n<li>将ByteBuf分解为多个共享同一个存储区域的ByteBuf</li>\n<li>slice恰好是将一整块区域，划分成逻辑上独立的小区域；</li>\n<li>在读取每个逻辑小区域时，实际会去按slice(int index, int length) index和length去读取原内存buffer的数据。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-9de31e6f274adf3b.png\"></p>\n<h6 id=\"通过FileRegion实现零拷贝\"><a href=\"#通过FileRegion实现零拷贝\" class=\"headerlink\" title=\"通过FileRegion实现零拷贝\"></a>通过FileRegion实现零拷贝</h6><ul>\n<li>FileRegion包装的FileChannel.tranferTo实现文件传输，可以直接将文件缓冲区的数据发送到目标Channel；</li>\n<li>这是操作系统级别的零拷贝</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/9033085-0e680625f97d467d.png\"></p>\n<p>扩展阅读 <a href=\"https://links.jianshu.com/go?to=https://pdfs.semanticscholar.org/6a35/60046cb8d3258669c86072a7cab05e1d2300.pdf\">https://pdfs.semanticscholar.org/6a35/60046cb8d3258669c86072a7cab05e1d2300.pdf</a></p>\n","text":"Java中的零拷贝 先提出两个问题：IO过程中，哪些步骤进行了拷贝？哪些地方零拷贝？Java支持哪些零拷贝？ 带着这俩问题，我们一起来看下面的探究。 哪里听说过...","permalink":"/post/JAVA/Java中的零拷贝","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"upload","slug":"upload","count":1,"path":"api/categories/upload.json"},{"name":"JAVA","slug":"upload/JAVA","count":1,"path":"api/categories/upload/JAVA.json"}],"tags":[{"name":"images","slug":"images","count":1,"path":"api/tags/images.json"},{"name":"copy","slug":"copy","count":1,"path":"api/tags/copy.json"},{"name":"DMA","slug":"DMA","count":1,"path":"api/tags/DMA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">Java中的零拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%93%AA%E9%87%8C%E5%90%AC%E8%AF%B4%E8%BF%87%E9%9B%B6%E6%8B%B7%E8%B4%9D-%E7%9C%9F%E7%9A%840%E6%AC%A1%E6%8B%B7%E8%B4%9D%E5%90%97\"><span class=\"toc-text\">哪里听说过零拷贝?真的0次拷贝吗?</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">什么是零拷贝?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#LinuxI-x2F-O%E6%9C%BA%E5%88%B6%E5%8F%8A%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">LinuxI&#x2F;O机制及零拷贝介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#IO%E4%B8%AD%E6%96%AD%E4%B8%8EDMA\"><span class=\"toc-text\">IO中断与DMA</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Linux-IO%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Linux IO流程</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81\"><span class=\"toc-text\">传统数据传送</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%87%BA%E7%8E%B0\"><span class=\"toc-text\">零拷贝的出现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Linux%E6%94%AF%E6%8C%81%E7%9A%84-%E5%B8%B8%E8%A7%81-%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">Linux支持的(常见)零拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81mmap%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">一、mmap内存映射</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81sendfile\"><span class=\"toc-text\">二、sendfile</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Sendfile-With-DMA-Scatter-x2F-Gather-Copy\"><span class=\"toc-text\">三、Sendfile With DMA Scatter&#x2F;Gather Copy</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4%E3%80%81splice\"><span class=\"toc-text\">4、splice</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%B9%BF%E4%B9%89%E7%8B%AD%E4%B9%89%E4%B9%8B%E5%88%86\"><span class=\"toc-text\">零拷贝的广义狭义之分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%B9%BF%E4%B9%89%E6%80%A7\"><span class=\"toc-text\">零拷贝的广义性</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Java%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">Java零拷贝机制解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#NIO%E6%8F%90%E4%BE%9B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-MappedByteBuffer\"><span class=\"toc-text\">NIO提供的内存映射 MappedByteBuffer</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#NIO%E6%8F%90%E4%BE%9B%E7%9A%84sendfile\"><span class=\"toc-text\">NIO提供的sendfile</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Kafka%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">Kafka中的零拷贝</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Netty%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">Netty中的零拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87CompositeByteBuf%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">通过CompositeByteBuf实现零拷贝</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87wrap%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">通过wrap操作实现零拷贝</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87slice%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">通过slice操作实现零拷贝</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87FileRegion%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">通过FileRegion实现零拷贝</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"检查网络延时测试 URL 汇总","uid":"2b4f70bb6bf139f87ea4e015f7434bed","slug":"OTHER/检查网络延时测试 URL 汇总","date":"2023-07-22T15:26:02.000Z","updated":"2025-09-30T03:27:02.163Z","comments":true,"path":"api/articles/OTHER/检查网络延时测试 URL 汇总.json","keywords":"XuGuangSheng","cover":"/covers/url.jpg","text":"检查网络延时测试 URL 汇总 URL 备注 推荐 http://captive.apple.com 苹果设备用于检测 Wi-Fi 是否需要认证登陆的链接 推荐...","permalink":"/post/OTHER/检查网络延时测试 URL 汇总","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"com","slug":"com","count":3,"path":"api/categories/com.json"},{"name":"OTHER","slug":"com/OTHER","count":2,"path":"api/categories/com/OTHER.json"}],"tags":[{"name":"www","slug":"www","count":8,"path":"api/tags/www.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"},{"name":"generate","slug":"generate","count":1,"path":"api/tags/generate.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis - Redis分布式算法原理","uid":"fb69e728d1b56159eab29357e4640574","slug":"MIDDLEWARE/Redis - Redis分布式算法原理","date":"2023-07-06T17:05:32.000Z","updated":"2025-09-30T03:26:50.152Z","comments":true,"path":"api/articles/MIDDLEWARE/Redis - Redis分布式算法原理.json","keywords":"XuGuangSheng","cover":"/covers/redis-redis.jpg","text":"Redis - Redis分布式算法原理一、Redis集群的使用我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我...","permalink":"/post/MIDDLEWARE/Redis - Redis分布式算法原理","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"Hash","slug":"Hash","count":1,"path":"api/categories/Hash.json"},{"name":"MIDDLEWARE","slug":"Hash/MIDDLEWARE","count":1,"path":"api/categories/Hash/MIDDLEWARE.json"}],"tags":[{"name":"Redis","slug":"Redis","count":3,"path":"api/tags/Redis.json"},{"name":"Node","slug":"Node","count":1,"path":"api/tags/Node.json"},{"name":"png","slug":"png","count":2,"path":"api/tags/png.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}