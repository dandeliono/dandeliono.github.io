{"title":"订单拆分的算法工具","uid":"d4735e073a9024218ffc41d269e2b60f","slug":"JAVA/订单拆分的算法工具","date":"2022-08-05T09:20:57.000Z","updated":"2025-12-05T01:46:55.333Z","comments":true,"path":"api/articles/JAVA/订单拆分的算法工具.json","keywords":"XuGuangSheng","cover":"/covers/29c90dd60332.jpg","content":"<h1 id=\"订单拆分的算法工具\"><a href=\"#订单拆分的算法工具\" class=\"headerlink\" title=\"订单拆分的算法工具\"></a>订单拆分的算法工具</h1><p>本篇文章带你打造一个自适应场景的交易订单合单拆分通用算法方案，根据现有技术的痛点，我们支付的时候设计一种自适应场景的交易下单合单拆分通用算法的方案，可插拔的场景组件提升扩展性和通用性就很重要。</p>\n<p>现有业内或产品是否有类似的，现有技术是否有缺陷或不足或问题，我们支付的时候</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/0dd7c47a122435fbb0b2b3a89e9867d2.webp\"></p>\n<p>交易系统为满足企业生产、销售、服务等需要，信息化模型复杂；为应对运营、管理和决策从而业务变化快；需要应对多商业模式的场景，例如多供应商、自营模式、入驻模式等；运营系统多样性，如 O2O&#x2F;C2C&#x2F;B2C&#x2F;。</p>\n<p>随着业务不断迭代，每增加一个场景或者一个交易支付工具，交易模型就成笛卡尔积形式增长，下单、支付退款、结算业务将越来越难以维护和扩展。如果不能有效控制和管理，后续扩展都需要不断重复的进行原有工作，导致业务代码冗余，逻辑不清晰，不能有效的保证数据一致性，也会带来代码效率和开发效率等问题。代码可读性变差，同逻辑不同实现代码性能参差不齐的问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/7962b2a863714fe901cba17d5b57dde9.webp\"></p>\n<p>针对以上问题，设计一种自适应场景的电商下单合单拆分通用算法的方案，设计根据下单场景自适应交易合单的拆分订单信息、结算信息，通过顺序表存储可插拔的场景组件提升扩展性和通用性，使用持久层提升代码执行逻辑效率和数据一致性。</p>\n<p>对于复杂的交易模型，此设计整体上分为 4 个模块——分摊模块、事件模块、服务模块、数据模</p>\n<h2 id=\"1、数据模块\"><a href=\"#1、数据模块\" class=\"headerlink\" title=\"1、数据模块\"></a>1、数据模块</h2><p>将复杂的模型抽象化，保留交易类型、交易流水信息、订单商品信息，如需要扩展信息，可根据已知信息通过业务场景，在数据获取更多的信息。以统一的抽象数据模型应对多样的复杂的场景，场景动态扩展，程序通过策略选择，统一迭代来自适应复杂场景。</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/f3ce4a6eea99974995af372859780f99.webp\"></p>\n<h2 id=\"2、事件模块\"><a href=\"#2、事件模块\" class=\"headerlink\" title=\"2、事件模块 \"></a>2、事件模块 </h2><p>事件体系是交易系统内部抽象模型，定义了一个唯一的事件 ID，支持同步异步执行，具有配置持久化机制、自定义异常重试机制、自动触发机制、监控报警等特点，将复杂逻辑代码和交易业务代码解耦。</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/2d23597868a4cba2f35ed727edb0be3d.webp\"></p>\n<h2 id=\"3、服务模块\"><a href=\"#3、服务模块\" class=\"headerlink\" title=\"3、服务模块\"></a>3、服务模块</h2><p>将数据模块、交易拆分信息在提供服务之前完成持久化，提供统一通用的服务接口，避免数据不一致，提高下单、退款、清结算、金额&#x2F;数量分摊的性能与一致性。</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/04ea9f6f8fb3e5df3a1990fc370d310e.webp\"></p>\n<h2 id=\"4、算法模块\"><a href=\"#4、算法模块\" class=\"headerlink\" title=\"4、算法模块\"></a>4、算法模块</h2><p>总体基于事件模块自动执行，将数据模块信息拆分，内置支付工具模块可支持配置的所有工具扁平化处理，过滤仅使用的工具。拆分主体根据配置规则，按照商品总金额占比模式拆分，对复杂交易模式进行统一集中处理，对防资损使用拆分金额&#x2F;数量恒等于交易金额&#x2F;数量的方式，对异常处理具有失败重试、失败监控告警、异常捕获等措施。最终通过此模块，服务各类复杂订单拆分、不同场景拆分的能力。</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/7b17bb899b8154ad84e2a962ea9177a5.webp\"></p>\n<h2 id=\"5、整体设计\"><a href=\"#5、整体设计\" class=\"headerlink\" title=\"5、整体设计\"></a>5、整体设计</h2><p>​​</p>\n<p>整体业务处理流程图，首先我们拿到用户的行为，例如：下单使用了支付宝+商家券+满减活动+618 活动+花呗+银行卡，出去拆分下单落库，优惠券的核销使用，我们将拆分逻辑使用异步 API-Future 进行开发，首先将拆分事件定义为一个 event 事件，此事件保存在环形缓冲器（ring buffer）这么做为了可以循环执行添加的事件，无需阻塞，这个时候在事件里面，实现自适应的拆分逻辑，并将拆分逻辑提供对外的服务接口即可，当此事件执行异常时，会进行落库操作</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/e75a05521657feb07c74fb3c5f1fdd8b.webp\"></p>\n<h2 id=\"1、发布事件\"><a href=\"#1、发布事件\" class=\"headerlink\" title=\"1、发布事件\"></a>1、发布事件</h2><p>Disruptor 是一个高性能的异步处理框架，或者可以认为是线程间通信的高效低延时的内存消息组件，它最大特点是高性能，其 LMAX 架构可以获得每秒 6 百万订单，用 1 微秒的延迟获得吞吐量为 100K+。disruptor 设计了一种高效的替代方案，我们使用 disruptor.getRingBuffer(); 构件高并发容器</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 发布事件-异步执行</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param orderEvent 事件</span><br><span class=\"line\">     * @param isAsync    <span class=\"literal\">true</span>-异步 ，<span class=\"literal\">false</span>-同步</span><br><span class=\"line\">     * @param context    上下文</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public <span class=\"literal\">void</span> publishEvent(OrderEventBean orderEvent, <span class=\"built_in\">Object</span> context, boolean isAsync) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">            </span><br><span class=\"line\"></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isAsync) &#123;</span><br><span class=\"line\">                RingBuffer&lt;OrderEventBean&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class=\"line\">                ringBuffer.publishEvent<span class=\"function\"><span class=\"params\">((event, sequence, groupId, orderId) -&gt; ConvertBeanUtil.copyBeanProperties(orderEvent, event), orderEvent.getEventGroupId(), orderEvent.getOdrId())</span>;</span></span><br><span class=\"line\"><span class=\"function\">            &#125; <span class=\"title\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">                </span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">logger</span>.<span class=\"title\">info</span><span class=\"params\">(<span class=\"string\">&quot;publishEvent方法orderEvent=&#123;&#125;&quot;</span>, orderEvent)</span>;</span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"title\">EventProcessorUtil</span>.<span class=\"title\">run</span><span class=\"params\">(orderEvent)</span>;</span></span><br><span class=\"line\"><span class=\"function\">            &#125;</span></span><br><span class=\"line\"><span class=\"function\">        &#125; <span class=\"title\">catch</span> <span class=\"params\">(Exception e1)</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"title\">logger</span>.<span class=\"title\">error</span><span class=\"params\">(<span class=\"string\">&quot;publishEvent error e1 =&quot;</span>, e1)</span>;</span></span><br><span class=\"line\"><span class=\"function\">        &#125;</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">logger</span>.<span class=\"title\">info</span><span class=\"params\">(<span class=\"string\">&quot;publishEvent end&quot;</span>)</span>;</span></span><br><span class=\"line\"><span class=\"function\">    &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"​​​2、逻辑模块\"><a href=\"#​​​2、逻辑模块\" class=\"headerlink\" title=\"​​​2、逻辑模块\"></a>​​​2、逻辑模块</h2><p>计算分摊数量工具的核心逻辑，分摊逻辑：单笔子单 支付方式 支付金额 &#x2F; 该支付方式总订单积分支付金额 &#x3D; 数量，最后一笔子单使用减法 （订单总数 - 分摊总数） &#x3D; 剩余分摊数 &lt; 最后一笔分摊数 ？ 剩余分摊数 ： 最后一笔分摊数主要流程：1、先对 list&lt;…Detail&gt;根据优先级排序，2、按顺序分摊，不能超过剩余的总数量，最后一笔取剩余，退款不能超过交易，3、获取下单时的支付工具，4、计算</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">* 计算分摊数量的工具</span></span><br><span class=\"line\"><span class=\"comment\">     * 分摊逻辑：单笔子单 支付方式 支付金额 / 该支付方式总订单积分支付金额 = 数量</span></span><br><span class=\"line\"><span class=\"comment\">     * 最后一笔子单使用减法 （订单总数 - 分摊总数） = 剩余分摊数 &lt; 最后一笔分摊数 ？ 剩余分摊数 ： 最后一笔分摊数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public ForkQuantityDTO subOdrForkQuantityPayProcess(ForkQuantityDTO forkQuantityDTO) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>1、对拆分和服务逻辑做了解耦，将拆分模块化，解决了不同业务分摊的数据一致性问题，提高代码的可维护性可扩展性</p>\n<p>2、自适应复杂的业务场景，支持对复杂场景配置和组装，实现新业务新需求时改动小，提高开发效率</p>\n<p>3、支持对其他业务提供服务，解决了业务逻辑处理异地处理</p>\n","text":"订单拆分的算法工具本篇文章带你打造一个自适应场景的交易订单合单拆分通用算法方案，根据现有技术的痛点，我们支付的时候设计一种自适应场景的交易下单合单拆分通用算法的...","permalink":"/post/JAVA/订单拆分的算法工具","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"https","slug":"https","count":12,"path":"api/categories/https.json"},{"name":"JAVA","slug":"https/JAVA","count":5,"path":"api/categories/https/JAVA.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"raw","slug":"raw","count":5,"path":"api/tags/raw.json"},{"name":"githubusercontent","slug":"githubusercontent","count":3,"path":"api/tags/githubusercontent.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A2%E5%8D%95%E6%8B%86%E5%88%86%E7%9A%84%E7%AE%97%E6%B3%95%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">订单拆分的算法工具</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">1、数据模块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">2、事件模块 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">3、服务模块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">4、算法模块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">5、整体设计</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E5%8F%91%E5%B8%83%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">1、发布事件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%80%8B%E2%80%8B%E2%80%8B2%E3%80%81%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">​​​2、逻辑模块</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"MySQL Binlog日志配置","uid":"c870bba49f8ac447777617e20cdfda53","slug":"MIDDLEWARE/MySQL Binlog日志配置","date":"2022-08-09T17:05:23.000Z","updated":"2025-12-05T01:47:30.978Z","comments":true,"path":"api/articles/MIDDLEWARE/MySQL Binlog日志配置.json","keywords":"XuGuangSheng","cover":"/covers/mysql-binlog.jpg","text":"MySQL Binlog日志配置Binlog 记录模式Redo Log 是属于InnoDB引擎所特有的日志，而MySQL Server也有自己的日志，即 Bin...","permalink":"/post/MIDDLEWARE/MySQL Binlog日志配置","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"Binlog","slug":"Binlog","count":1,"path":"api/categories/Binlog.json"},{"name":"MIDDLEWARE","slug":"Binlog/MIDDLEWARE","count":1,"path":"api/categories/Binlog/MIDDLEWARE.json"}],"tags":[{"name":"log","slug":"log","count":4,"path":"api/tags/log.json"},{"name":"binlog","slug":"binlog","count":1,"path":"api/tags/binlog.json"},{"name":"event","slug":"event","count":1,"path":"api/tags/event.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"iotop发现jdb2 sdb1-8 io使用过高解决办法","uid":"a5de914b5d23a430628c528e96e12efd","slug":"LINUX/iotop发现jdb2 sdb1-8 io使用过高解决办法","date":"2022-08-03T16:05:11.000Z","updated":"2025-12-05T01:47:07.153Z","comments":true,"path":"api/articles/LINUX/iotop发现jdb2 sdb1-8 io使用过高解决办法.json","keywords":"XuGuangSheng","cover":"/covers/iotopjdb2-sdb1-8-io.jpg","text":"iotop发现jdb2/sdb1-8 io使用过高解决办法现象1234567891011121314\\[root@push-5\\-221 ~\\]# iotopo...","permalink":"/post/LINUX/iotop发现jdb2 sdb1-8 io使用过高解决办法","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"binlog","slug":"binlog","count":1,"path":"api/categories/binlog.json"},{"name":"LINUX","slug":"binlog/LINUX","count":1,"path":"api/categories/binlog/LINUX.json"}],"tags":[{"name":"cache","slug":"cache","count":2,"path":"api/tags/cache.json"},{"name":"log","slug":"log","count":4,"path":"api/tags/log.json"},{"name":"MySQL","slug":"MySQL","count":2,"path":"api/tags/MySQL.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}