{"title":"使用线程池时候当程序结束时候记得调用shutdown关闭线程池","uid":"c154332e2066fa4ee3ef3036412a15b5","slug":"JAVA/使用线程池时候当程序结束时候记得调用shutdown关闭线程池","date":"2022-07-26T10:03:32.000Z","updated":"2025-09-30T03:26:25.895Z","comments":true,"path":"api/articles/JAVA/使用线程池时候当程序结束时候记得调用shutdown关闭线程池.json","keywords":"XuGuangSheng","cover":"/covers/shutdown.jpg","content":"<h1 id=\"使用线程池时候当程序结束时候记得调用shutdown关闭线程池\"><a href=\"#使用线程池时候当程序结束时候记得调用shutdown关闭线程池\" class=\"headerlink\" title=\"使用线程池时候当程序结束时候记得调用shutdown关闭线程池\"></a>使用线程池时候当程序结束时候记得调用shutdown关闭线程池</h1><h2 id=\"使用线程池时候当程序结束时候记得调用-shutdown-关闭线程池\"><a href=\"#使用线程池时候当程序结束时候记得调用-shutdown-关闭线程池\" class=\"headerlink\" title=\"使用线程池时候当程序结束时候记得调用 shutdown 关闭线程池\"></a>使用线程池时候当程序结束时候记得调用 shutdown 关闭线程池</h2><p>日常开发中为了便于线程的有效复用，线程池是经常会被用的工具，然而线程池使用完后如果不调用 shutdown 会导致线程池资源一直不会被释放。下面通过简单例子来说明该问题。</p>\n<h3 id=\"1-问题复现\"><a href=\"#1-问题复现\" class=\"headerlink\" title=\"1 问题复现\"></a>1 问题复现</h3><p>下面通过一个例子说明当不调用线程池对象的 shutdown 方法后，当线程池里面的任务执行完毕后主线程这个 JVM 不会退出。</p>\n<pre><code>public class TestShutDown &#123;\n\n        static void asynExecuteOne() &#123;\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(new  Runnable() &#123;\n            public void run() &#123;\n                System.out.println(&quot;--async execute one ---&quot;);\n            &#125;\n        &#125;);\n    &#125;\n    \n    static void asynExecuteTwo() &#123;\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(new  Runnable() &#123;\n            public void run() &#123;\n                System.out.println(&quot;--async execute two ---&quot;);\n            &#125;\n        &#125;);\n    &#125;\n    \n\n    public static void main(String[] args) &#123;\n       \n        System.out.println(&quot;---sync execute---&quot;);\n       \n        asynExecuteOne();\n       \n        asynExecuteTwo();\n       \n        System.out.println(&quot;---execute over---&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>如上代码主线程里面首先同步执行了操作（1）然后执行操作（2）（3），操作（2）（3）使用线程池的一个线程执行异步操作，我们期望当主线程和操操作（2）（3）执行完线程池里面的任务后整个 JVM 就会退出，但是执行结果却如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/937c601b4016d1a8164226ba1817ce46.png\"></p>\n<p>image.png</p>\n<p>右上角红色方块说明 JVM 进程还没有退出，Mac 上执行<code>ps -eaf|grep java</code>后发现 Java 进程还是存在的，这是什么情况那？修改操作（2）（3）在方法里面添加调用线程池的 shutdown 方法如下代码：</p>\n<pre><code> static void asynExecuteOne() &#123;\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(new  Runnable() &#123;\n            public void run() &#123;\n                System.out.println(&quot;--async execute one ---&quot;);\n            &#125;\n        &#125;);\n        \n        executor.shutdown();\n    &#125;\n    \n    static void asynExecuteTwo() &#123;\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(new  Runnable() &#123;\n            public void run() &#123;\n                System.out.println(&quot;--async execute two ---&quot;);\n            &#125;\n        &#125;);\n        \n        executor.shutdown();\n    &#125;\n</code></pre>\n<p>在执行就会发现 JVM 已经退出了，使用<code>ps -eaf|grep java</code>后发现 Java 进程以及不存在了，这说明只有调用了线程池的 shutdown 方法后当线程池任务执行完毕后线程池资源才会释放。</p>\n<h3 id=\"2-问题分析\"><a href=\"#2-问题分析\" class=\"headerlink\" title=\"2 问题分析\"></a>2 问题分析</h3><p>下面看下为何如此那？大家或许还记得基础篇讲解的守护线程与用户线程吧，JVM 退出的条件是当前不存在用户线程，而线程池默认的 ThreadFactory 创建的线程是用户线程，</p>\n<pre><code> static class DefaultThreadFactory implements ThreadFactory &#123;\n        ...\n        public Thread newThread(Runnable r) &#123;\n            Thread t = new Thread(group, r,\n                                  namePrefix + threadNumber.getAndIncrement(),\n                                  0);\n            if (t.isDaemon())\n                t.setDaemon(false);\n            if (t.getPriority() != Thread.NORM_PRIORITY)\n                t.setPriority(Thread.NORM_PRIORITY);\n            return t;\n        &#125;\n    &#125;\n</code></pre>\n<p>如上代码可知线程池默认的线程工厂创建创建的都是用户线程。而线程池里面的核心线程是一直会存在的，如果没有任务则会阻塞，所以线程池里面的用户线程一直会存在. 而 shutdown 方法的作用就是让这些核心线程终止，下面在简单看下 shutdown 重要代码：</p>\n<pre><code> public void shutdown() &#123;\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try &#123;\n            ...\n            \n            advanceRunState(SHUTDOWN);\n            \n            interruptIdleWorkers();\n            ...\n        &#125; finally &#123;\n            mainLock.unlock();\n        &#125;\n           ...\n        &#125;\n</code></pre>\n<p>可知 shutdown 里面设置了线程池状态为 SHUTDOWN，并且设置了所有工作线程的中断标志，那么下面在简单看下工作线程 Worker 里面是不是发现中断标志被设置了就会退出了。</p>\n<pre><code> final void runWorker(Worker w) &#123;\n            ...\n            try &#123;\n            while (task != null || (task = getTask()) != null) &#123;\n               ...            \n            &#125;\n            ...\n          &#125; finally &#123;\n            ...\n        &#125;\n    &#125;\n\nprivate Runnable getTask() &#123;\n        boolean timedOut = false; \n\n        for (;;) &#123;\n            ...\n            \n            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;\n                decrementWorkerCount();\n                return null;\n            &#125;\n            \n            try &#123;\n                \n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            &#125; catch (InterruptedException retry) &#123;\n                timedOut = false;\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>如上代码正常情况下如果队列里面没有任务了，工作线程阻塞到代码（2）等待从工工作队列里面获取一个任务，这时候如果调用了线程池的 shutdown 命令而 shutdown 命令会中断所有工作线程，所以代码（2）会抛出处抛出 InterruptedException 异常而返回，而这个异常被 catch 了，所以继续执行代码（1），而 shutdown 时候设置了线程池的状态为 SHUTDOWN 所以 getTask 方法返回了 null，所以 runWorker 方法退出循环，该工作线程就退出了。</p>\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 总结\"></a>3 总结</h3><p>本节通过一个简单的使用线程池异步执行任务案例介绍了线程池使用完后要如果不调用 shutdown 会导致线程池的线程资源一直不会被释放，然后通过源码分析了没有被释放的原因。所以日常开发中使用线程池的场景一定不要忘记了调用 shutdown 方法设置线程池状态和中断工作线程池</p>\n","text":"使用线程池时候当程序结束时候记得调用shutdown关闭线程池使用线程池时候当程序结束时候记得调用 shutdown 关闭线程池日常开发中为了便于线程的有效复用...","permalink":"/post/JAVA/使用线程池时候当程序结束时候记得调用shutdown关闭线程池","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"shutdown","slug":"shutdown","count":1,"path":"api/categories/shutdown.json"},{"name":"JAVA","slug":"shutdown/JAVA","count":1,"path":"api/categories/shutdown/JAVA.json"}],"tags":[{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"使用线程池时候当程序结束时候记得调用","slug":"使用线程池时候当程序结束时候记得调用","count":1,"path":"api/tags/使用线程池时候当程序结束时候记得调用.json"},{"name":"关闭线程池","slug":"关闭线程池","count":1,"path":"api/tags/关闭线程池.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6%E5%80%99%E5%BD%93%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9D%9F%E6%97%B6%E5%80%99%E8%AE%B0%E5%BE%97%E8%B0%83%E7%94%A8shutdown%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">使用线程池时候当程序结束时候记得调用shutdown关闭线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6%E5%80%99%E5%BD%93%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9D%9F%E6%97%B6%E5%80%99%E8%AE%B0%E5%BE%97%E8%B0%83%E7%94%A8-shutdown-%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">使用线程池时候当程序结束时候记得调用 shutdown 关闭线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%97%AE%E9%A2%98%E5%A4%8D%E7%8E%B0\"><span class=\"toc-text\">1 问题复现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2 问题分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">3 总结</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"应对掘金CDN开启防盗链 记一次爬取markdown图片的经历","uid":"fcfa6f5ea8dabe903d8fbcda021fdf5f","slug":"WORK/应对掘金CDN开启防盗链 记一次爬取markdown图片的经历","date":"2022-07-29T14:06:36.000Z","updated":"2025-09-30T03:27:03.167Z","comments":true,"path":"api/articles/WORK/应对掘金CDN开启防盗链 记一次爬取markdown图片的经历.json","keywords":"XuGuangSheng","cover":"/covers/cdn-markdown.jpg","text":"应对掘金CDN开启防盗链 记一次爬取markdown图片的经历使用 markdown 写文章有什么好处? markdown 是一种纯文本格式 (后缀.md), ...","permalink":"/post/WORK/应对掘金CDN开启防盗链 记一次爬取markdown图片的经历","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"github","slug":"github","count":1,"path":"api/categories/github.json"},{"name":"WORK","slug":"github/WORK","count":1,"path":"api/categories/github/WORK.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"png","slug":"png","count":2,"path":"api/tags/png.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"nginx 反向代理和路径重写","uid":"77b291e312b6296807210b6244b44cc2","slug":"MIDDLEWARE/nginx 反向代理和路径重写","date":"2022-07-14T09:31:31.000Z","updated":"2025-09-30T03:26:53.504Z","comments":true,"path":"api/articles/MIDDLEWARE/nginx 反向代理和路径重写.json","keywords":"XuGuangSheng","cover":"/covers/nginx.jpg","text":"nginx 反向代理和路径重写nginx 反向代理路径问题http://abc.com:8080 写法和 http://abc.com:8080/ 写法的区别如...","permalink":"/post/MIDDLEWARE/nginx 反向代理和路径重写","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"NginxTest","slug":"NginxTest","count":1,"path":"api/categories/NginxTest.json"},{"name":"MIDDLEWARE","slug":"NginxTest/MIDDLEWARE","count":1,"path":"api/categories/NginxTest/MIDDLEWARE.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"},{"name":"abc","slug":"abc","count":1,"path":"api/tags/abc.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}