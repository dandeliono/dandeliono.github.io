{"title":"虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南","uid":"6302f7b0274d5a479bc686d3d275831e","slug":"JAVA/虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南","date":"2021-10-24T13:41:42.000Z","updated":"2025-12-05T01:46:54.639Z","comments":true,"path":"api/articles/JAVA/虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南.json","keywords":"XuGuangSheng","cover":"/covers/gcsafepoint.jpg","content":"<h1 id=\"虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南\"><a href=\"#虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南\" class=\"headerlink\" title=\"虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南\"></a>虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南</h1><h3 id=\"SafePoint-前提介绍\"><a href=\"#SafePoint-前提介绍\" class=\"headerlink\" title=\"SafePoint 前提介绍\"></a>SafePoint 前提介绍</h3><p>在高度优化的现代 JVM 里，Safepoint 有几种不同的用法。GC safepoint 是最常见、大家听说得最多的，但还有 <em>deoptimization safepoint</em> 也很重要。</p>\n<p>在 HotSpot VM 里，这两种 Safepoint 目前实现在一起，但其实概念上它们俩没有直接联系，需要的数据不一样。</p>\n<p>无论是哪种 SafePoint，最简洁的定义是 “A point in program where the state of execution is known by the VM”。<strong>这里 “state of execution” 特意说得模糊，是因为不同种类的 safepoint 需要的数据不一样。</strong> </p>\n<h4 id=\"GC-safepoint\"><a href=\"#GC-safepoint\" class=\"headerlink\" title=\"GC safepoint\"></a>GC safepoint</h4><p>GC Safepoint 需要知道在那个<strong>程序位置上，调用栈、寄存器</strong>等一些重要的数据区域里什么地方包含了 GC 管理的指针； 如果要触发一次 GC，那么 JVM 里的所有 Java 线程都必须到达 GC safepoint。</p>\n<h4 id=\"Deoptimization-safepoint\"><a href=\"#Deoptimization-safepoint\" class=\"headerlink\" title=\"Deoptimization safepoint\"></a>Deoptimization safepoint</h4><p>Deoptimization safepoint 需要知道在那个程序位置上，原本抽象概念上的 JVM 的执行状态（所有局部变量、临时变量、锁，等等）到底分配到了什么地方，是在栈帧￼的具体某个操作数栈 slot，还是在某个寄存器里。</p>\n<p>如果要执行一次 deoptimization，那么需要执行 deoptimization 的线程要在到达 deoptimization safepoint 之后才可以开始 deoptimize。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>不同 JVM 实现会选用不同的位置放置 safepoint。</strong> </p></blockquote>\n<h4 id=\"HotSpotVM-的-SafePoint\"><a href=\"#HotSpotVM-的-SafePoint\" class=\"headerlink\" title=\"HotSpotVM 的 SafePoint\"></a>HotSpotVM 的 SafePoint</h4><p>解释器里每条字节码的边界都可以是一个 safepoint，因为 HotSpot 的解释器总是能很容易的找出完整的 “state of execution”。</p>\n<p>JIT 编译的世界里，HotSpot 会在所有方法的临返回之前，以及所有非 counted loop 的循环的回跳之前放置 safepoint，(counted loop 则没有放置 safepoint）。</p>\n<p>HotSpot 的 JIT 编译器不但会生成机器码，还会额外在每个 safepoint 生成一些 “调试符号信息”，以便 VM 能找到所需的 “state of execution”。</p>\n<h4 id=\"SafePoint-的存储信息\"><a href=\"#SafePoint-的存储信息\" class=\"headerlink\" title=\"SafePoint 的存储信息\"></a>SafePoint 的存储信息</h4><p>为 GC SafePoint 生成的符号信息是 OopMap，指出栈上和寄存器里哪里有 GC 管理的指针；</p>\n<p>为 deoptimization SafePoint 生成的符号信息是 debugInfo，指出如果要把当前栈帧从 compiled frame 转换为 interpreted frame 的话，要从哪里把相应的局部变量、临时变量、锁等信息找出来。</p>\n<h4 id=\"选择在-SafePoint-的位置地点\"><a href=\"#选择在-SafePoint-的位置地点\" class=\"headerlink\" title=\"选择在 SafePoint 的位置地点\"></a>选择在 SafePoint 的位置地点</h4><ul>\n<li><strong>挂在 safepoint 的调试符号</strong>信息要占用空间，如果允许每条机器码都可以是 safepoint 的话，需要存储的数据量会很大（当然这有办法解决，例如用 delta 存储和用压缩）</li>\n<li><strong>safepoint 会影响优化</strong>，特别是 deoptimization safepoint，会迫使 JVM 保留一些只有解释器可能需要的、JIT 编译器认定无用的变量的值。本来 JIT 编译器可能可以发现某些值不需要而消除它们对应的运算，如果在 safepoint 需要这些值的话那就只好保留了。这才是更重要的地方，所以要尽量少放置 safepoint。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>像 HotSpotVM 这样，在 Safepoint 会生成（polling 代码）主动请求询问 JVM 是否要进入 safepoint，polling 也有开销所以要尽量减少。</p></blockquote>\n<h4 id=\"Native-代码的特殊性\"><a href=\"#Native-代码的特殊性\" class=\"headerlink\" title=\"Native 代码的特殊性\"></a>Native 代码的特殊性</h4><p>当某个线程在执行 native 函数的时候。此时该线程在执行 JVM 管理之外的代码，不能对 JVM 的执行状态做任何修改，因而 JVM 要进入 safepoint 不需要关心它。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>所以也可以把正在执行 native 函数的线程看作 “已经进入了 safepoint”，或者把这种情况叫做 “在 safe-region 里”。</p></blockquote>\n<p>JVM 外部要对 JVM 执行状态做修改必须要通过 JNI。所有能修改 JVM 执行状态的 JNI 函数在入口处都有 safepoint 检查，一旦 JVM 已经发出通知说此时应该已经到达 safepoint 就会在这些检查的地方停下来把控制权交给 JVM。</p>\n<p>JRockit 选择放置 safepoint 的地方在方法的入口以及循环末尾回跳之前，跟 HotSpot 略为不同。</p>\n<pre><code>UseCountedLoopSafepoints:\n</code></pre>\n<p>复制代码</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以避免 GC 发生时，线程因长时间运行 counted loop，进入不到 safepoint，而引起 GC 的 STW 时间过长。</p></blockquote>\n<p>JVM 参数<code>-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1</code>  </p>\n<p>在控制台输出以下信息：</p>\n<pre><code>vmop [threads: total initially_running wait_to_block]  [time: spin block sync cleanup vmop] page_trap_count  370337.312: GenCollectForAllocation     [  1070     2       3  ]   [ 8830   0 8831   1  24  ] \n</code></pre>\n<p>复制代码</p>\n<p>YGC 所花费的时间非常短，主要时间花费在所有线程达到安全点并暂停。</p>\n<h4 id=\"JVM-参数配置如下：\"><a href=\"#JVM-参数配置如下：\" class=\"headerlink\" title=\"JVM 参数配置如下：\"></a>JVM 参数配置如下：</h4><pre><code>-server -Xms8192M -Xmx8192M -Xmn1500M -Xss256k -XX:PermSize=256M -XX:MaxPermSize=256M -XX:SurvivorRatio=8 -XX:-UseBiasedLocking -XX:MonitorBound=16384 -XX:+UseSpinning -XX:PreBlockSpin=1 -XX:+UseParNewGC -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=55 -XX:CMSMaxAbortablePrecleanTime=5 -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSClassUnloadingEnabled -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:SoftRefLRUPolicyMSPerMB=0 -XX:+DisableExplicitGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/xmail/jvm_heap.dump -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1  \n</code></pre>\n<p>复制代码</p>\n<p>最有可能导致问题的是代码里有 Java 代码</p>\n<pre><code>for (int i = 0; i &lt; ...; i++) &#123; &#125; 或者类似的循环代码。\n</code></pre>\n<p>复制代码</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这种循环称为 “counted loop”，就是有明确的循环计数器变量，而且该变量有明确的起始值、终止值、步进长度的循环。</p></blockquote>\n<p>它有可能被优化为循环末尾没有 safepoint，于是如果这个循环的循环次数很多、循环体里又不调用别的方法或者是调用了方法但被内联进来了，就有可能会导致进入 safepoint 非常耗时。</p>\n<p>可惜的是现在没什么特别方便的办法直接指出是什么地方有这种循环。有的话，一种解决办法是把单层循环拆成等价的双重嵌套循环，这样其中一层循环末尾的 safepoint 就可能会留下来，减少进入 safepoint 的等待时间。</p>\n<h4 id=\"如何判断内联方法\"><a href=\"#如何判断内联方法\" class=\"headerlink\" title=\"如何判断内联方法\"></a>如何判断内联方法</h4><p>从代码角度如何判断方法被内联进来了，主要是方法被 final 修饰。 final 是可以帮助 JIT 编译器做出内联的判断，但不是必要条件。</p>\n<ul>\n<li>-XX:+PrintCompilation -XX:+PrintInlining 来看内联状况</li>\n<li>-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount&#x3D;1 ” 输出的结果 “[time: spin block sync cleanup vmop] ” 中 spin 是指什么呢？</li>\n<li>PrintSafepointStatics：打印出来的 spin 值指的是 SafepointSynchronize 在同步每个线程时做的自旋。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>thread locking &#x2F; biased locking 的 spin 完全没关系，自然设置那些参数也不会影响 safepoint 的自旋（UseSpinning 之类控制的是 thread locking 的自旋）。</p></blockquote>\n<h3 id=\"SafePoint-存在的目的？\"><a href=\"#SafePoint-存在的目的？\" class=\"headerlink\" title=\"SafePoint 存在的目的？\"></a>SafePoint 存在的目的？</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为什么把这些位置设置为 jvm 的安全点呢，主要目的就是避免程序长时间无法进入 safepoint，比如 JVM 在做 GC 之前要等所有的应用线程进入到安全点后 VM 线程才能分派 GC 任务 ，如果有线程一直没有进入到安全点，就会导致 GC 时 JVM 停顿时间延长。</p></blockquote>\n<p><strong>比如，写了一个超大的循环导致线程一直没有进入到安全点，GC 前停顿了 8 秒。</strong> </p>\n<p>产生的日志信息基本上 STW 的原因都是 RevokeBias 或者 BulkRevokeBias。这个是撤销偏向锁操作，虽然每次暂停的时间很短，但是特别频繁出现也会很耗时。</p>\n<h4 id=\"GC-如何找到不可用的对象\"><a href=\"#GC-如何找到不可用的对象\" class=\"headerlink\" title=\"GC 如何找到不可用的对象\"></a><strong>GC 如何找到不可用的对象</strong></h4><p>编写代码的时候是可以知道对象不可用的，但对于程序来说，需要一定的方式来知晓，可用方法比如：编译分析，引用计数，和对象是否可达。</p>\n<h4 id=\"可达性分析\"><a href=\"#可达性分析\" class=\"headerlink\" title=\"可达性分析\"></a><strong>可达性分析</strong></h4><p>因而可达性分析，只需要找到直接可达的引用，直接可达的引用就是根引用，根引用的集合就是根的集合</p>\n<ol>\n<li>一个对象只要能够通过 mutator 触达，那么它就是 “活” 着的。</li>\n<li>如果 Mutator 栈的一个槽位包含了对象的引用，那么对象就是直接可触达。</li>\n<li>从直接可达对象可触达的对象必定也是可达的，</li>\n</ol>\n<h5 id=\"muator-线程分析\"><a href=\"#muator-线程分析\" class=\"headerlink\" title=\"muator 线程分析\"></a>muator 线程分析</h5><ul>\n<li>mutator 的上下文就包含了直接可达的数据，所以要获取对象根集合就是要找到 mutator 上下文中的对象引用，</li>\n<li>mutator 的上下文指的就是它的栈、它的寄存器文件以及一些线程上特定的数据。</li>\n</ul>\n<h4 id=\"静态数据\"><a href=\"#静态数据\" class=\"headerlink\" title=\"静态数据\"></a>静态数据</h4><p>全局数据本身也是直接可达的</p>\n<p>可达性分析为了确保能正确的决定对象是否存活，GC 需要获取 mutator 上下文的（当前）一致性快照，然后枚举所有的根对象。</p>\n<ul>\n<li>一致性指的是：快照的抽取就像只在一个时间点发生，来避免丢失一些活着的对象。</li>\n</ul>\n<h5 id=\"如何获取-mutator-上下文的一致性快照\"><a href=\"#如何获取-mutator-上下文的一致性快照\" class=\"headerlink\" title=\"如何获取 mutator 上下文的一致性快照\"></a><strong>如何获取 mutator 上下文的一致性快照</strong></h5><p>一种简单的方式就是在跟引用的过程中暂停所有的线程。当 mutator 暂停了它的执行时，只有将所有引用信息保存在其上下文中，才能枚举根的集合，这意味着，mutator 需要能够告诉 JVM 哪些栈的槽位有用，哪些寄存器持有引用。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果 GC 能够准确的获取上述引用信息，它就称作精准根集合枚举。而无法获取就是不精准的。</p></blockquote>\n<h4 id=\"如何获取精准的引用信息枚举\"><a href=\"#如何获取精准的引用信息枚举\" class=\"headerlink\" title=\"如何获取精准的引用信息枚举\"></a><strong>如何获取精准的引用信息枚举</strong></h4><p>对于 java 来说，JIT 知晓所有的栈帧信息和寄存器的内容，当 JIT 编译一个方法时，对于每条指令，它都可以去保存根引用信息，保存意味着额外的存储空间，如果要存储所有的指令就显得花销太大，另外在真实的运行过程中也只有少数指令才会成为暂停点，因此 JIT 只需要保存这些指令点的信息就够了。而<strong>真正有机会成为暂停点的地方就称作 safe-points，即能够安全的枚举根集合的暂停点</strong>。</p>\n<h4 id=\"如何保证-mutator-会在-safe-point-暂停\"><a href=\"#如何保证-mutator-会在-safe-point-暂停\" class=\"headerlink\" title=\"如何保证 mutator 会在 safe-point 暂停\"></a><strong>如何保证 mutator 会在 safe-point 暂停</strong></h4><p>当 GC 想要触发一次回收时，它会设置一个标志，mutator 则周期性的去检查 (poll) 这个标志，如果检查到了，就会立马暂停，这里的检查点 (poll points) 也是安全点，由 JIT 负责把 poll points 放到合适的位置，<strong>那些地方适合设置检查 GC 事件的标记</strong></p>\n<h5 id=\"polling-point-插入的主要原则是\"><a href=\"#polling-point-插入的主要原则是\" class=\"headerlink\" title=\"polling point 插入的主要原则是:\"></a>polling point 插入的主要原则是:</h5><ul>\n<li>polling point 应该足够多，防止 GC 等一个 mutator 的暂停太长，导致其他 mutator 都走在等 GC 释放空间，程序整个等待过长</li>\n<li>polling point 不能太频繁导致运行时存储开销过大</li>\n<li>polling 本身也是有开销的，不能过多</li>\n<li>权衡下来只在必须和必要的地方加</li>\n<li>分配地址的时候强制添加，因为分配空间很有肯能导致回收，所以这里是一个安全点</li>\n<li>长时间的执行一般意味着循环和方法调用，所以方法调用和循环返回最好加上</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>但是有时候并不是长时间的执行，而是长时间的空闲，比如 sleep、block，线程在执行其他的 native 函数，这些时候 JVM 无法掌控执行能力，也就无法响应 GC 事件。</p></blockquote>\n<p><strong>SafePoint 无法解决 sleep&#x2F;block 带来的问题</strong>，当这段时间内 JVM 要发起 GC 时，就不管没到安全点但是在安全区域的线程。在线程要离开安全区域时，要检查系统是否已经完成了 GC，故我们又定义了一个安全区域的概念.</p>\n<h4 id=\"SafeRegion-的简介\"><a href=\"#SafeRegion-的简介\" class=\"headerlink\" title=\"SafeRegion 的简介\"></a><strong>SafeRegion 的简介</strong></h4><p>safe-region 是指代码快中没有用到会变异的部分，这样的代码块中，任何一个点都可以安全的枚举根。</p>\n<ul>\n<li>当进入到 safe-region 中时，mutator 会设置一个准备标记，在离开 safe-region 区域之前，会检查 GC 是否已经完成了回收，如果没有，那么就暂停执行，如果有，就可以直接离开 safe-region 区域，不需要暂停 mutator。</li>\n<li>关于 Java&#x2F;JVM 的 safepoint &#x2F; safe-region，代码的执行过程中，如果需要执行某些操作，比如 GC，deoptimize, 等等，必须知道当前程序所有线程运行到的地方，是否能够恰好满足我执行对应操作，而不会对应用程序本身造成损害，能够正确执行的地方就是 safepoint&#x2F;saferegion</li>\n</ul>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><ul>\n<li><a href=\"http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html\">GC safe-point (or safepoint) and safe-region | Xiao-Feng Li</a>  </li>\n<li>Cliff Click 大神 safepoint：<a href=\"http://0xdata.com/blog/2015/02/Java-HotLoops/\">How does Java Both Optimize Hot Loops and Allow Debugging</a></li>\n</ul>\n","text":"虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南SafePoint 前提介绍在高度优化的现代 JVM 里，Safepoint 有...","permalink":"/post/JAVA/虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"safepoint","slug":"safepoint","count":1,"path":"api/categories/safepoint.json"},{"name":"JAVA","slug":"safepoint/JAVA","count":1,"path":"api/categories/safepoint/JAVA.json"}],"tags":[{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"mutator","slug":"mutator","count":1,"path":"api/tags/mutator.json"},{"name":"safe","slug":"safe","count":1,"path":"api/tags/safe.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%B1%E5%B1%82%E7%B3%BB%E5%88%97%E3%80%8CGC%E6%9C%AC%E8%B4%A8%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E3%80%8DSafePoint%E7%9A%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%E6%8C%87%E5%8D%97\"><span class=\"toc-text\">虚拟机深层系列「GC本质底层机制」SafePoint的深入分析和底层原理探究指南</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SafePoint-%E5%89%8D%E6%8F%90%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">SafePoint 前提介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GC-safepoint\"><span class=\"toc-text\">GC safepoint</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Deoptimization-safepoint\"><span class=\"toc-text\">Deoptimization safepoint</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#HotSpotVM-%E7%9A%84-SafePoint\"><span class=\"toc-text\">HotSpotVM 的 SafePoint</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SafePoint-%E7%9A%84%E5%AD%98%E5%82%A8%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">SafePoint 的存储信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E5%9C%A8-SafePoint-%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%9C%B0%E7%82%B9\"><span class=\"toc-text\">选择在 SafePoint 的位置地点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Native-%E4%BB%A3%E7%A0%81%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7\"><span class=\"toc-text\">Native 代码的特殊性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JVM-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%A6%82%E4%B8%8B%EF%BC%9A\"><span class=\"toc-text\">JVM 参数配置如下：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%86%85%E8%81%94%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">如何判断内联方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SafePoint-%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9B%AE%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">SafePoint 存在的目的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#GC-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">GC 如何找到不可用的对象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90\"><span class=\"toc-text\">可达性分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#muator-%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">muator 线程分析</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">静态数据</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96-mutator-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%BF%AB%E7%85%A7\"><span class=\"toc-text\">如何获取 mutator 上下文的一致性快照</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%B2%BE%E5%87%86%E7%9A%84%E5%BC%95%E7%94%A8%E4%BF%A1%E6%81%AF%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">如何获取精准的引用信息枚举</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-mutator-%E4%BC%9A%E5%9C%A8-safe-point-%E6%9A%82%E5%81%9C\"><span class=\"toc-text\">如何保证 mutator 会在 safe-point 暂停</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#polling-point-%E6%8F%92%E5%85%A5%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%88%99%E6%98%AF\"><span class=\"toc-text\">polling point 插入的主要原则是:</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SafeRegion-%E7%9A%84%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">SafeRegion 的简介</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\"><span class=\"toc-text\">参考文献</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"如何优雅地记录操作日志？","uid":"bec62911910e4566d1eb24b159beea23","slug":"LINUX/如何优雅地记录操作日志？","date":"2021-11-03T14:13:48.000Z","updated":"2025-12-05T01:47:15.114Z","comments":true,"path":"api/articles/LINUX/如何优雅地记录操作日志？.json","keywords":"XuGuangSheng","cover":"/covers/8566a8fc21ff.jpg","text":"如何优雅地记录操作日志？操作日志几乎存在于每个系统中，而这些系统都有记录操作日志的一套 API。操作日志和系统日志不一样，操作日志必须要做到简单易懂。所以如何让...","permalink":"/post/LINUX/如何优雅地记录操作日志？","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"24 mins."},"categories":[{"name":"SpEL","slug":"SpEL","count":1,"path":"api/categories/SpEL.json"},{"name":"LINUX","slug":"SpEL/LINUX","count":1,"path":"api/categories/SpEL/LINUX.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"AOP","slug":"AOP","count":1,"path":"api/tags/AOP.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"字体ttc文件打包时损坏","uid":"ff376bbc0a7a05ebffda5869db6237b5","slug":"LINUX/字体ttc文件打包时损坏","date":"2021-10-08T09:24:25.000Z","updated":"2025-12-05T01:47:15.872Z","comments":true,"path":"api/articles/LINUX/字体ttc文件打包时损坏.json","keywords":"XuGuangSheng","cover":"/covers/ttc.jpg","text":"字体ttc文件打包时损坏 在使用 springboot 时，在 resources 添加 .ttc 类型的字体集，本地 jar 启动没有丝毫问题，打成 war ...","permalink":"/post/LINUX/字体ttc文件打包时损坏","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"ttc","slug":"ttc","count":1,"path":"api/categories/ttc.json"},{"name":"LINUX","slug":"ttc/LINUX","count":1,"path":"api/categories/ttc/LINUX.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"www","slug":"www","count":8,"path":"api/tags/www.json"},{"name":"sxkawzp","slug":"sxkawzp","count":1,"path":"api/tags/sxkawzp.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}