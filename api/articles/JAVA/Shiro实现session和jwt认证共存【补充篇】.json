{"title":"Shiro实现session和jwt认证共存【补充篇】","uid":"a16ed64205294beb02f16921cdcc37a9","slug":"JAVA/Shiro实现session和jwt认证共存【补充篇】","date":"2024-07-11T09:28:24.000Z","updated":"2025-09-30T03:26:16.943Z","comments":true,"path":"api/articles/JAVA/Shiro实现session和jwt认证共存【补充篇】.json","keywords":"XuGuangSheng","cover":"/covers/shirosessionjwt.jpg","content":"<h1 id=\"Shiro实现session和jwt认证共存【补充篇】\"><a href=\"#Shiro实现session和jwt认证共存【补充篇】\" class=\"headerlink\" title=\"Shiro实现session和jwt认证共存【补充篇】\"></a>Shiro实现session和jwt认证共存【补充篇】</h1><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>前文 <a href=\"https://blog.csdn.net/qq_24054301/article/details/103833855\">Shiro实现session和无状态token认证共存</a> 保姆级代码，但是不够完善，有些难点不清不楚，这里补充一些难点的解决。<br>当时选型 <a href=\"https://blog.csdn.net/qq_24054301/article/details/103836684\">shiro复用session实现前后端分离鉴权</a> ，纯粹采用有状态的鉴权方案简单强大，而真正意义上的的有状态和无状态共存在shiro上是不好实现的，当然我也给你解决了。</p>\n<h3 id=\"再次强调无状态\"><a href=\"#再次强调无状态\" class=\"headerlink\" title=\"再次强调无状态\"></a>再次强调无状态</h3><p>如果不了解，赶紧止步，请使用有状态方案，真正了解无状态并坚决落地无状态再来看实现。</p>\n<p><strong>无状态有状态的比喻：</strong><br>前文经典比喻</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>session与<a href=\"https://so.csdn.net/so/search?q=jwt&spm=1001.2101.3001.7020\">jwt</a>的不同：session认证是保险箱在服务器，密码在用户手中，用户把密码送到服务器解开自己的保险箱，而jwt则是保险箱放在用户手中，服务器什么都不放，当用户把保险箱送来，服务器摸一摸保险箱，敲打敲打，认为保险箱是自己家生产的就打开它。<br>这样当服务器开分号时，采用session方式就只能帮用户解锁在自己分号的保险箱，用户如果让a分号打开存在b分号的保险箱，就得顺丰快递从a送到b送过来。而jwt方式每一家分号都能打开任意用户的保险箱。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>补充一下上面比喻，假如保险箱非常多，明显session方案成本在存储保险箱，jwt方案成本在用户得搬运保险箱。<a href=\"https://so.csdn.net/so/search?q=redis%E9%9B%86%E7%BE%A4&spm=1001.2101.3001.7020\">redis集群</a>虽然也耗带宽但是可以搭建在内网，相当于分号内部建立的超时空通道。</p></blockquote>\n<p><strong>运维成本：</strong><br>所谓的有状态无状态关键在于，session存储信息在服务端，jwt存储信息在客户端。<br>抓住要点，这意味着高负荷下有状态耗费服务器内存，无状态耗费外网网络带宽。</p>\n<p>假设权限丰富的token平均大小为5kb，这是非常正常的。<br>200w session存储大概占用10g内存。2000qps jwt传输占用10MB&#x2F;s网速即80M下载带宽。我在这里假定的数据是非常有实际意义的，这个价位的云服务器，10g内存大致对应的就是百M下载带宽，2000qps 非常不错了，这还是因为下载带宽相对上传带宽不值钱，如果你要搞jwt刷新策略返回参数带新jwt就要消耗上传带宽了，这个就是高成本了。很明显200w的session的系统级别远远不是2000qps的级别系统可比的。也就是说成本上来说肯定存储服务器性价比高，所谓的有状态浪费服务器资源不攻自破，无状态还浪费带宽呢。</p>\n<p><strong>网上乱象：</strong><br>在研发权限丰富的系统中，我更倾向使用session的方式。近年来无状态兴起，各种博文动不动就贬低session一无是处，强行给session编了一大堆缺点（要么是根本不懂乱写，要么是没本事解决），其实session才是主流方案，方便控制-权限更新、踢人下线、限制登录等，无状态token不适合小项目趟这个浑水，更适合大型互联网项目的部分功能，它非常适用于只需要认证而鉴权需求少的局部的微服务。我前两篇文章是在2020年1月写的，那时候无状态吹得是牛逼轰轰，动不动就无状态鉴权，现在是2022年3月风向好像倒回去，估计是被坑的人越来越多了。</p>\n<p>不过直到现在很多文章的评论里都混淆无状态、有状态、token、jwt、session、sessionId、cookie、localStorage。随处可见干了好几年的程序员写出<del>session依赖cookie在手机端不能用，必须使用token或者jwt、无状态认证</del> 的评论。</p>\n<p>入门八股文必有一问session和cookie的区别？评论session离不开cookie的绝大多数都背过这个八股文，不然也入不了行，网上的八股文解答很细致，也都能答出什么cookie只能存4k之类的。。。</p>\n<p><strong>概诉作用：</strong><br>这个问题就是个陷阱，不用讲它们的区别，它们压根就是两个东西，只不过历史场景经常绑在一起使用，session代表有状态会话，包含用户登录状态、权限信息，存在服务器的内存之中，比较大，生成一个sessionId的短字符串作为key通过response请求设置cookie并传送给客户端，客户端浏览器就会自动使用cookie存储，这样即使前端不编写传参，访问同域url时会自动带上cookie非常方便。sessionId存在客户端哪都行和cookie无关，只是方便不用前端自己编写传参逻辑，比如安卓小程序之类cookie不能用的场景，sessionId可以前端自己编写保存到存储里，统一拦截请求时带到请求头或者参数里都行，后端也得编写逻辑去拦截获取。这里sessionId通常会被后端改个好听的名字叫做token，token只是个参数名而已，这里的token就是sessionId就是有状态token。而jwt的token才是无状态的，说白了jwt的token就是session的内容加时间之类，你要是存权限之类的话就会非常长，要使用散列还是双向加密都行看你如何落地，不存服务器就得在传输时一直带上，jwt这套必须自己去实现这些传参保存方案，session+cookie设置这套框架自带，所以很多人误解<del>只有token能用在移动端上</del> ，传来传去变成<del>只有jwt能用在移动端上</del> 。</p>\n<p><strong>歧路方案：</strong><br>真正明白session和cookie和jwt的关系后，就不会走上歧路。比如当年我改造系统有了 <a href=\"https://blog.csdn.net/qq_24054301/article/details/103836684\">shiro复用session实现前后端分离鉴权</a> 这个方案，而在我开发之前的前辈的解决非常奇葩，cookie不能用后，就自己生成一串uuid保存redis叫做token，只能认证不能鉴权相当于shiro的user权限标识符。。。大概是因为不懂shiro框架，不懂如何在后端获取到sessionId，然后实现jwt又被哪篇水文忽悠了搞了个四不像。包括现在网上的文章很多jwt还给存到redis里，都存redis还能叫无状态吗。</p>\n<p><strong>无状态缺点：</strong><br>无状态优点就是服务器不存储，然后为了实现踢下线，限制登录、权限变更，会衍生出各种有状态的方案。比如redis存储有变更user，jwt过来时需要比对user，搞到最后，服务器还是得存东西，所以无状态只是个理想概念，为了丰富功能最后还是得需要有状态来解决。</p>\n<p><strong>我想象中的无状态使用场景：</strong><br>前面讲到有状态耗内存，无状态耗带宽。全部使用无状态不现实，我提倡精简jwt的token，大部分时候只需要认证不需要鉴权的功能使用jwt的token就行，然后用到某个涉及到鉴权的功能开始有状态，才读取权限内容保存进redis。这样可以解决无状态耗带宽的问题，又可以减低有状态对redis集群的过分依赖，防止redis一挂全部功能都得挂。redis集群存储个成千上亿的session虽然不成问题，但是web大集群和redis大集群频繁交互，每个请求都交互一次，耦合度实在太高了。</p>\n<p>所以说完美的无状态不现实，权限信息不可能存入jwt，太大了，耗带宽，小项目更加承受不起这个成本。</p>\n<h3 id=\"前文已解决\"><a href=\"#前文已解决\" class=\"headerlink\" title=\"前文已解决\"></a>前文已解决</h3><p>1、自定义过滤器<br>2、多realm共存<br>3、重写supports选择realm进行认证<br>4、多realm共存鉴权失败抛出详细异常<br>5、认证失败时 返回json<br>6、授权失败时 返回json<br>7、获取sessionid可以使用其它参数名</p>\n<h3 id=\"难点解决\"><a href=\"#难点解决\" class=\"headerlink\" title=\"难点解决\"></a>难点解决</h3><h4 id=\"禁用session管理\"><a href=\"#禁用session管理\" class=\"headerlink\" title=\"*禁用session管理\"></a>*禁用session管理</h4><p>这个非常重要，如果关闭，不能实现有状态的token（即session）管理，开启着会影响无状态请求，会导致各种莫名其妙的bug。</p>\n<p>由于系统采用redis作为缓存管理，查找办法就是把redis关闭掉，操作的时候就会触发redis连接导致请求无响应和超时，再一一解决。</p>\n<p>三禁-禁session写入、禁session读取、禁权限读取，都涉及到有状态。</p>\n<p><a href=\"https://shiro.apache.org/session-management.html#SessionManagement-SessionsSubjectState-HybridApproach\">官方文档</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://shiro.apache.org/session-management.html#SessionManagement-SessionsSubjectState-HybridApproach\">https://shiro.apache.org/session-management.html#SessionManagement-SessionsSubjectState-HybridApproach</a></p></blockquote>\n<p>解疑：经过重复试验，在多realm共存的情况下，全部禁用session管理或者开启session管理都没啥问题，但是混用的时候就不好处理了，得想办法处理，不修改源码的前提下，框架只能做到选择性禁止session的缓存写入。</p>\n<h5 id=\"①-禁创建的session缓存写入\"><a href=\"#①-禁创建的session缓存写入\" class=\"headerlink\" title=\"① 禁创建的session缓存写入\"></a>① 禁创建的session缓存写入</h5><p>官网混用方案只能禁登录时的session缓存写入，也就是说不会禁止缓存读取。</p>\n<p>方法一：重写SessionStorageEvaluator<br>传参有Subject ，可以获取request 的内容，通过token的不同特征来区分是无状态的还是有状态的token<br>重写SessionStorageEvaluator：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomeSessionStorge</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultWebSessionStorageEvaluator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public boolean isSessionStorageEnabled(<span class=\"type\">Subject</span> subject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(subject instanceof <span class=\"type\">WebSubject</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">HttpServletRequest</span> request = (<span class=\"type\">HttpServletRequest</span>) ((<span class=\"type\">WebSubject</span>) subject).getServletRequest();</span><br><span class=\"line\">            <span class=\"type\">String</span> token = request.getParameter(<span class=\"string\">&quot;token&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"type\">StringUtils</span>.isBlank(token)) &#123;</span><br><span class=\"line\">                token = ((<span class=\"type\">HttpServletRequest</span>) request).getHeader(<span class=\"string\">&quot;token&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (token == <span class=\"literal\">null</span> || token.contains(<span class=\"string\">&quot;.&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.isSessionStorageEnabled(subject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultSubjectDAO subjectDAO <span class=\"operator\">=</span> new DefaultSubjectDAO()<span class=\"comment\">;</span></span><br><span class=\"line\">subjectDAO.setSessionStorageEvaluator(customeSessionStorge)<span class=\"comment\">;</span></span><br><span class=\"line\">securityManager.setSubjectDAO(subjectDAO)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>方法二：NoSessionCreationFilter</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://shiro.apache.org/static/1.9.0/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html\">https://shiro.apache.org/static/1.9.0/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html</a></p></blockquote>\n<p>session有提供一个过滤器用于禁止创建session，设置在登录接口上，效果可能比方法一更好。<br>noSessionCreation 过滤器设置到禁止创建session的接口上即可。</p>\n<h5 id=\"②-禁session的缓存读取\"><a href=\"#②-禁session的缓存读取\" class=\"headerlink\" title=\"② 禁session的缓存读取\"></a>② 禁session的缓存读取</h5><p>禁session的缓存读取，如果不设置，请求带无状态token时认证前会读取session。</p>\n<p>重写 <strong>DefaultWebSessionManager</strong> getSessionId 方法<br>&#x2F;&#x2F; 自己的token判断 我这里共用一个toekn参数<br>三层判断<br>第一个if判断包含.说明是jwt，sessionId直接返回null，就不会读缓存；<br>第二个if判断有状态token参数，变了传参形式的sessionId；<br>其它则是旧版的cookie传参的sessionId。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Serializable <span class=\"title function_\">getSessionId</span><span class=\"params\">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">sid</span> <span class=\"operator\">=</span> request.getParameter(<span class=\"string\">&quot;token&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(StringUtils.isBlank(sid)) &#123;</span><br><span class=\"line\">\t\t\tsid = ((HttpServletRequest) request).getHeader(<span class=\"string\">&quot;token&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (StringUtils.isNotBlank(sid) &amp;&amp; sid.contains(<span class=\"string\">&quot;.&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (StringUtils.isNotBlank(sid)) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (WebUtils.isTrue(request, <span class=\"string\">&quot;__cookie&quot;</span>))&#123;</span><br><span class=\"line\">\t\t        <span class=\"type\">HttpServletRequest</span> <span class=\"variable\">rq</span> <span class=\"operator\">=</span> (HttpServletRequest)request;</span><br><span class=\"line\">\t\t        <span class=\"type\">HttpServletResponse</span> <span class=\"variable\">rs</span> <span class=\"operator\">=</span> (HttpServletResponse)response;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">Cookie</span> <span class=\"variable\">template</span> <span class=\"operator\">=</span> getSessionIdCookie();</span><br><span class=\"line\">\t\t        <span class=\"type\">Cookie</span> <span class=\"variable\">cookie</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleCookie</span>(template);</span><br><span class=\"line\">\t\t\t\tcookie.setValue(sid); cookie.saveTo(rq, rs);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,</span><br><span class=\"line\">                    ShiroHttpServletRequest.URL_SESSION_ID_SOURCE); </span><br><span class=\"line\">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, sid);</span><br><span class=\"line\">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span> sid;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getSessionId(request, response);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"③-禁权限读取\"><a href=\"#③-禁权限读取\" class=\"headerlink\" title=\"③ 禁权限读取\"></a>③ 禁权限读取</h5><p>禁了前两步，访问带权限标识符的需要鉴权的接口时还会请求redis。调试后发现StatelessAuthorizingRealm的缓存确实禁用了，但是因为鉴权会遍历realm调用了有状态的Realm导致请求了redis。</p>\n<p>解决办法就是重写所有的鉴权方法，判断是否无状态并结束调用。<br>所以前文不齐全，前文拦截的是<strong>doGetAuthorizationInfo</strong>方法，这个方法是—授权查询回调函数, 进行鉴权但缓存中无用户的授权信息时调用，也就是获取授权。所以要重写的是真正的鉴权方法<strong>isPermitted</strong>，鉴权方法会读取缓存，在前面判断拦截了，就不会读取。</p>\n<p>加个判断，判断不是当前realm的principals，鉴权false。</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isPermitted</span><span class=\"params\">(PrincipalCollection principals, Permission permission)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!(getAvailablePrincipal(principals) <span class=\"keyword\">instanceof</span> Principal))&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tauthorizationValidate(permission);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.<span class=\"title\">isPermitted</span><span class=\"params\">(principals, permission)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"jwt方案整合shiro\"><a href=\"#jwt方案整合shiro\" class=\"headerlink\" title=\"jwt方案整合shiro\"></a>jwt方案整合shiro</h4><p>禁缓存才是最大的难点，整合简单多了，前提是得理解一些概念，不然也是会搞得乱七八糟，前文从未提及jwt，这里作补充。</p>\n<h5 id=\"①-登录接口\"><a href=\"#①-登录接口\" class=\"headerlink\" title=\"① 登录接口\"></a>① 登录接口</h5><p>不重要的全部省略掉，重点在于SecurityUtils.getSubject() ，subject调用login，然后再subject获取Principal得到token。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(value = &quot;。。。/login2&quot;)</span></span><br><span class=\"line\">   <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> ResultDTO <span class=\"title function_\">login2</span><span class=\"params\">(HttpServletRequest request...)</span> &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">       <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> SecurityUtils.getSubject();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (subject == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">               ...</span><br><span class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">               <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> request.getParameter(<span class=\"string\">&quot;username&quot;</span>);</span><br><span class=\"line\">               <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> request.getParameter(<span class=\"string\">&quot;password&quot;</span>);</span><br><span class=\"line\">               subject.login(<span class=\"keyword\">new</span> <span class=\"title class_\">StatelessToken</span>(username, password));</span><br><span class=\"line\">               <span class=\"type\">String</span> <span class=\"variable\">jwt</span> <span class=\"operator\">=</span> ((StatelessAuthorizingRealm.Principal)SecurityUtils.getSubject().getPrincipal()).getToken();</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"②-拦截认证\"><a href=\"#②-拦截认证\" class=\"headerlink\" title=\"② 拦截认证\"></a>② 拦截认证</h5><p>拦截认证，token无效返回失败，有效调用login。关键点在于需要login。有状态的时候框架自动根据sessionId获取用户信息，而无状态每次调用都要login，不然鉴权的时候会报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">onAccessDenied</span><span class=\"params\">(ServletRequest request, ServletResponse response)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">StatelessToken</span> <span class=\"variable\">statelessToken</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StatelessToken</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> request.getParameter(<span class=\"string\">&quot;token&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(StringUtils.isBlank(token)) &#123;</span><br><span class=\"line\">\t\t\ttoken = ((HttpServletRequest) request).getHeader(<span class=\"string\">&quot;token&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(JwtUtil.verify(token)) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tstatelessToken.setToken(token);</span><br><span class=\"line\">\t\t\tgetSubject(request, response).login(statelessToken);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">ResultDTO</span> <span class=\"variable\">retDto</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t\tresponse.getWriter().write(GsonUtils.toJson(retDto));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"③-赋予认证信息\"><a href=\"#③-赋予认证信息\" class=\"headerlink\" title=\"③ 赋予认证信息\"></a>③ 赋予认证信息</h5><p>这里体现了无状态和有状态的最大不同。有状态只需要登录认证就行了，而无状态需要获取是否包含jwt的token，有的话说明登陆过，千万不要再去登录，而是解析token获取用户信息设置到SimpleAuthenticationInfo里，这一步其实相当于session版shiro内置读取session缓存，后面的和有状态实现一样，踢人不行了这得有状态去实现。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">\tprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) &#123;</span><br><span class=\"line\">\t\tStatelessToken token = (StatelessToken) authcToken;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(StringUtils.isNotBlank(token.getToken())) &#123;</span><br><span class=\"line\">\t\t\tUser user = JwtUtil.getUsername(token.getToken());</span><br><span class=\"line\">\t\t\tPrincipal principalTmp = <span class=\"keyword\">new</span> <span class=\"type\">Principal</span>(user);</span><br><span class=\"line\">\t\t\tprincipalTmp.setToken(token.getToken());</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> <span class=\"type\">SimpleAuthenticationInfo</span>(principalTmp, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, getName());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tUser user = getSystemService().getUserByTLoginName(token.getUsername());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (user != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (...) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">AuthenticationException</span>(<span class=\"string\">&quot;msg:该帐号已禁止登录.&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (...) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">AuthenticationException</span>(<span class=\"string\">&quot;msg:该帐号已被加入黑名单.&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tbyte[] salt = Encodes.decodeHex(user.getPassword().substring(。。。));</span><br><span class=\"line\">\t\t\tPrincipal principal = <span class=\"keyword\">new</span> <span class=\"type\">Principal</span>(user);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tSimpleAuthorizationInfo info = <span class=\"keyword\">new</span> <span class=\"type\">SimpleAuthorizationInfo</span>();</span><br><span class=\"line\">\t\t\tList&lt;Menu&gt; list = UserUtils.<span class=\"keyword\">get</span>。。。;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (Menu menu : <span class=\"type\">list</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (StringUtils.isNotBlank(menu.getPermission())) &#123;</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">String</span> permission : <span class=\"type\">StringUtils</span>.split(menu.getPermission(), <span class=\"string\">&quot;,&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tinfo.addStringPermission(permission);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tinfo.addStringPermission(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (Role role : <span class=\"type\">user</span>.getRoleList()) &#123;</span><br><span class=\"line\">\t\t\t\tinfo.addRole(role.<span class=\"keyword\">get</span>...);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">String</span> jwt = JwtUtil.createJWT(user, info);</span><br><span class=\"line\">\t\t\tprincipal.setToken(jwt);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(token.isTraceless()) &#123;</span><br><span class=\"line\">\t\t\t\tprincipal.setTraceless(<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> <span class=\"type\">SimpleAuthenticationInfo</span>(principal, user</span><br><span class=\"line\">\t\t\t\t\t.getPassword().substring(...), ByteSource.Util.bytes(salt), getName());</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!token.isTraceless()) &#123;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\tgetSystemService().update。。。</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t\tLogUtils.saveLog(...);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"④-赋予授权信息\"><a href=\"#④-赋予授权信息\" class=\"headerlink\" title=\"④ 赋予授权信息\"></a>④ 赋予授权信息</h5><p>这是绝对理想化的获取授权信息，有状态版想更新缓存就更新缓存，无状态只能解析jwt获取，实时性就没了。要想实现又得引入redis的一套，比如修改过的user设置进redis。这里面获取授权信息每次都得查询redis看是否存在于名单里是否需要重新读取，这样完美的无状态又不能实现了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title function_\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!(getAvailablePrincipal(principals) <span class=\"keyword\">instanceof</span> Principal))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">Principal</span> <span class=\"variable\">principal</span> <span class=\"operator\">=</span> (Principal) getAvailablePrincipal(principals);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> JwtUtil.getRoles(principal.getToken());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"业务使用\"><a href=\"#业务使用\" class=\"headerlink\" title=\"业务使用\"></a>业务使用</h4><p>善于使用<strong>Subject</strong>、<strong>Principal</strong> ，只要搭的好，无状态有状态都可以用的，即使无状态，在一次请求的生命周期里是有状态的，和有状态的用法一模一样，可以通过<strong>Principal</strong>在业务里传递用户信息。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Subject subject <span class=\"operator\">=</span> SecurityUtils.getSubject()<span class=\"comment\">;</span></span><br><span class=\"line\">Principal principal <span class=\"operator\">=</span> (Principal) subject.getPrincipal()<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>之前的文章不清不楚，这篇文章算是完美解答了，思路和疑难基本解决。至于使用无状态之后衍生出来的问题那就是后续的头疼了。在中小规模的项目中，我有个应用方案就是把无状态这套当做后备隐藏救急方案，就是当灾难发生时假如redis全挂了，就是用不了，系统可以马上切换到无状态realm。又或者是认证使用jwt减少对redis的耦合，提高系统的高可用，需要鉴权再再加载有状态内容，这也是非常不错的，至于完全的无状态，那是不现实的。</p>\n","text":"Shiro实现session和jwt认证共存【补充篇】前言前文 Shiro实现session和无状态token认证共存 保姆级代码，但是不够完善，有些难点不清不...","permalink":"/post/JAVA/Shiro实现session和jwt认证共存【补充篇】","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"session","slug":"session","count":2,"path":"api/categories/session.json"},{"name":"JAVA","slug":"session/JAVA","count":1,"path":"api/categories/session/JAVA.json"}],"tags":[{"name":"jwt","slug":"jwt","count":1,"path":"api/tags/jwt.json"},{"name":"token","slug":"token","count":1,"path":"api/tags/token.json"},{"name":"redis","slug":"redis","count":2,"path":"api/tags/redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Shiro%E5%AE%9E%E7%8E%B0session%E5%92%8Cjwt%E8%AE%A4%E8%AF%81%E5%85%B1%E5%AD%98%E3%80%90%E8%A1%A5%E5%85%85%E7%AF%87%E3%80%91\"><span class=\"toc-text\">Shiro实现session和jwt认证共存【补充篇】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%8D%E6%AC%A1%E5%BC%BA%E8%B0%83%E6%97%A0%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">再次强调无状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E6%96%87%E5%B7%B2%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">前文已解决</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9A%BE%E7%82%B9%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">难点解决</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A6%81%E7%94%A8session%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">*禁用session管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E7%A6%81%E5%88%9B%E5%BB%BA%E7%9A%84session%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5\"><span class=\"toc-text\">① 禁创建的session缓存写入</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E7%A6%81session%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">② 禁session的缓存读取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E7%A6%81%E6%9D%83%E9%99%90%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">③ 禁权限读取</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jwt%E6%96%B9%E6%A1%88%E6%95%B4%E5%90%88shiro\"><span class=\"toc-text\">jwt方案整合shiro</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">① 登录接口</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E6%8B%A6%E6%88%AA%E8%AE%A4%E8%AF%81\"><span class=\"toc-text\">② 拦截认证</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E8%B5%8B%E4%BA%88%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">③ 赋予认证信息</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E8%B5%8B%E4%BA%88%E6%8E%88%E6%9D%83%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">④ 赋予授权信息</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%9A%E5%8A%A1%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">业务使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">最后</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"NFQUEUE机制导致DNS请求5秒超时分析","uid":"1bbad1a585c4bcc2381dfee0a793a3ef","slug":"LINUX/NFQUEUE机制导致DNS请求5秒超时分析","date":"2024-08-12T10:01:18.000Z","updated":"2025-09-30T03:26:34.814Z","comments":true,"path":"api/articles/LINUX/NFQUEUE机制导致DNS请求5秒超时分析.json","keywords":"XuGuangSheng","cover":"/covers/nfqueuedns5.jpg","text":"NFQUEUE机制导致DNS请求5秒超时分析在一台CentOS 7.0服务器(内核版本号:3.10.0-123.el7.x86_64)上安装我们的安全防护程序后...","permalink":"/post/LINUX/NFQUEUE机制导致DNS请求5秒超时分析","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"conntrack","slug":"conntrack","count":1,"path":"api/categories/conntrack.json"},{"name":"LINUX","slug":"conntrack/LINUX","count":1,"path":"api/categories/conntrack/LINUX.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"DNS","slug":"DNS","count":1,"path":"api/tags/DNS.json"},{"name":"BUG","slug":"BUG","count":1,"path":"api/tags/BUG.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Linux下so动态链接库使用总结","uid":"86d3016d930075b1294dec7c5e7f9e57","slug":"LINUX/Linux下so动态链接库使用总结","date":"2024-07-01T13:35:18.000Z","updated":"2025-09-30T03:26:34.326Z","comments":true,"path":"api/articles/LINUX/Linux下so动态链接库使用总结.json","keywords":"XuGuangSheng","cover":"/covers/linuxso.jpg","text":"Linux下so动态链接库使用总结本文主要总结在Linux环境下，使用so动态链接库经常遇到的问题，包括使用cp命令覆盖so导致进程coredump之类的问题。...","permalink":"/post/LINUX/Linux下so动态链接库使用总结","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ldconfig","slug":"ldconfig","count":1,"path":"api/categories/ldconfig.json"},{"name":"LINUX","slug":"ldconfig/LINUX","count":1,"path":"api/categories/ldconfig/LINUX.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"lib","slug":"lib","count":1,"path":"api/tags/lib.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}