{"title":"Producer Metadata 读取与更新机制","uid":"4cc462e9c8fcfd4947ede10d296d33aa","slug":"MIDDLEWARE/Producer Metadata 读取与更新机制","date":"2023-08-11T14:30:38.000Z","updated":"2025-12-05T01:47:36.647Z","comments":true,"path":"api/articles/MIDDLEWARE/Producer Metadata 读取与更新机制.json","keywords":"XuGuangSheng","cover":"/covers/producer-metadata.jpg","content":"<h1 id=\"Producer-Metadata-读取与更新机制\"><a href=\"#Producer-Metadata-读取与更新机制\" class=\"headerlink\" title=\"Producer Metadata 读取与更新机制\"></a>Producer Metadata 读取与更新机制</h1><h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>宏观上介绍了 Producer 的宏观模型，其中通过 waitOnMetadata() 方法获取 topic 的 metadata 。</p>\n<h2 id=\"二、Metadata\"><a href=\"#二、Metadata\" class=\"headerlink\" title=\"二、Metadata\"></a>二、Metadata</h2><p><strong>2.1 什么是 Metadata</strong></p>\n<p>Metadata 是指 Kafka 集群的元数据，包含了 Kafka 集群的各种信息，直接看源码便可知：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Metadata implements Closeable &#123;</span><br><span class=\"line\">   <span class=\"keyword\"> private</span><span class=\"keyword\"> final</span> <span class=\"class\">Logger log;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span><span class=\"keyword\"> final</span><span class=\"built_in\"> long </span>refreshBackoffMs;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span><span class=\"keyword\"> final</span><span class=\"built_in\"> long </span>metadataExpireMs;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span><span class=\"built_in\"> int </span>updateVersion;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span><span class=\"built_in\"> int </span>requestVersion;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span><span class=\"built_in\"> long </span>lastRefreshMs;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span><span class=\"built_in\"> long </span>lastSuccessfulRefreshMs;</span><br><span class=\"line\">   <span class=\"keyword\"> private</span> KafkaException fatalException;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span> Set&lt;String&gt; invalidTopics;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span> Set&lt;String&gt; unauthorizedTopics;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span> MetadataCache cache = MetadataCache.empty();</span><br><span class=\"line\">   <span class=\"keyword\"> private</span> boolean needFullUpdate;</span><br><span class=\"line\">   <span class=\"keyword\"> private</span> boolean needPartialUpdate;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span><span class=\"keyword\"> final</span> ClusterResource<span class=\"class\">Listeners clusterResourceListeners;</span></span><br><span class=\"line\">   <span class=\"keyword\"> private</span> boolean isClosed;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\"> private</span><span class=\"keyword\"> final</span> Map&lt;TopicPartition, Integer&gt; lastSeen<span class=\"class\">LeaderEpochs;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>MetadataCache：Kafka 集群中关于 node、topic 和 partition 的信息。（是只读的）</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title class_\"><span class=\"keyword\">class</span> <span class=\"title\">MetadataCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span> clusterId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Integer, Node&gt; nodes;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;<span class=\"keyword\">String</span>&gt; unauthorizedTopics;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;<span class=\"keyword\">String</span>&gt; invalidTopics;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;<span class=\"keyword\">String</span>&gt; internalTopics;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node controller;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;TopicPartition, PartitionMetadata&gt; metadataByPartition;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Cluster clusterInstance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于 topic 的详细信息（leader 所在节点、replica 所在节点、isr 列表）都是在 Cluster 实例中保存的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cluster</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> boolean isBootstrapConfigured;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">List</span>&lt;<span class=\"type\">Node</span>&gt; nodes;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt; unauthorizedTopics;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt; invalidTopics;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt; internalTopics;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Node</span> controller;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">TopicPartition</span>, <span class=\"type\">PartitionInfo</span>&gt; partitionsByTopicPartition;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">List</span>&lt;<span class=\"type\">PartitionInfo</span>&gt;&gt; partitionsByTopic;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">List</span>&lt;<span class=\"type\">PartitionInfo</span>&gt;&gt; availablePartitionsByTopic;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">Integer</span>, <span class=\"type\">List</span>&lt;<span class=\"type\">PartitionInfo</span>&gt;&gt; partitionsByNode;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">Integer</span>, <span class=\"type\">Node</span>&gt; nodesById;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ClusterResource</span> clusterResource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">PartitionInfo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String topic;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> partition;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node leader;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node\\[\\] replicas;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node\\[\\] inSyncReplicas;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node\\[\\] offlineReplicas;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码不难理解 Metadata 的主要数据结构，我们大概总结下包含哪些信息：</p>\n<ul>\n<li>集群中有哪些节点；</li>\n<li>集群中有哪些 topic，这些 topic 有哪些 partition；</li>\n<li>每个 partition 的 leader 副本分配在哪个节点上，follower 副本分配在哪些节点上；</li>\n<li>每个 partition 的 AR 有哪些副本，ISR 有哪些副本；</li>\n</ul>\n<p><strong>2.2 Metadata 的应用场景</strong></p>\n<p>Metadata 在 Kafka 中非常重要，很多场景中都需要从 Metadata 中获取数据或更新数据，例如：</p>\n<ul>\n<li>KafkaProducer 发送一条消息到指定的 topic 中，需要知道分区的数量，要发送的目标分区，目标分区的 leader，leader 所在的节点地址等，这些信息都要从 Metadata 中获取。</li>\n<li>当 Kafka 集群中发生了 leader 选举，节点中 partition 或副本发生了变化等，这些场景都需要更新Metadata 中的数据。</li>\n</ul>\n<h2 id=\"三、Producer-的-Metadata-更新流程\"><a href=\"#三、Producer-的-Metadata-更新流程\" class=\"headerlink\" title=\"三、Producer 的 Metadata 更新流程\"></a>三、Producer 的 Metadata 更新流程</h2><p>Producer 在调用 doSend() 方法时，第一步就是通过 waitOnMetadata 方法获取该 topic 的 metadata 信息。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000040855910\"></p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000040855911\"></p>\n<p>总结一下以上代码：</p>\n<ul>\n<li><p>首先会从缓存中获取 cluster 信息，并从中获取 partition 信息，如果可以取到则返回当前的 cluster 信息，如果不含有所需要的 partition 信息时就会更新 metadata；</p>\n</li>\n<li><p>更新 metadata 的操作会在一个 do ….while 循环中进行，直到 metadata 中含有所需 partition 的信息，该循环中主要做了以下事情：</p>\n<ul>\n<li>调用 metadata.requestUpdateForTopic() 方法来获取 updateVersion，即上一次更新成功时的 version，并将 needUpdate 设为 true，强制更新；</li>\n<li>调用 sender.wakeup() 方法来唤醒 Sender 线程，Sender 线程中又会唤醒 NetworkClient 线程，在 NetworkClient 中会对 UpdateMetadataRequest 请求进行操作，待会下面会详细介绍；</li>\n<li>调用 metadata.awaitUpdate(version, remainingWaitMs) 方法来等待 metadata 的更新，通过比较当前的 updateVersion 与步骤 1 中获取的 updateVersion 来判断是否更新成功；</li>\n</ul>\n</li>\n</ul>\n<p><strong>3.1 org.apache.kafka.clients.NetworkClient#poll</strong></p>\n<p>上面提到调用 sender.wakeup() 方法来唤醒 Sender 线程，Sender 线程中又会唤醒 NetworkClient 线程，在 NetworkClient 中会对 UpdateMetadataRequest 请求进行操作。在 NetworkClient 中真正处理请求的是 NetworkClient.poll() 方法，接下来让我们通过分析源码来看下 NetworkClient 是如何处理请求的。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000040855912\"></p>\n<p><strong>3.2 org.apache.kafka.clients.NetworkClient.DefaultMetadataUpdater#maybeUpdate(long)</strong></p>\n<p>我们来看下 metadata 是如何更新的<br><img src=\"https://segmentfault.com/img/remote/1460000040855913\"></p>\n<p>这里你可能会问，老周啊，最小负载节点是啥呀？</p>\n<p>别急，我们来看下面这张图，你就理解了。</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000040855914\"></p>\n<p>LeastLoadedNode 指 Kafka 集群中所有 Node 中负载最小的那一个 Node，它是由每个 Node 在 InFlightRequests 中还未确定的请求数决定的，未确定的请求越少则负载越小。如上图所示，Node1 即为 LeastLoadedNode。</p>\n<p><strong>3.3 org.apache.kafka.clients.Metadata#updateRequested</strong><br><img src=\"https://segmentfault.com/img/remote/1460000040855915\"></p>\n<p>下次更新元数据信息的时间：<code>当前 metadata 信息即将到期的时间</code>即 timeToExpire 和 <code>距离允许更新 metadata 信息的时间</code> 即 timeToAllowUpdate 中的最大值。</p>\n<p>timeToExpire：needUpdate 为 true，表示强制更新，此时该值为 0；否则的话，就按照定时更新时间，即元数据信息过期时间（默认是 300000 ms 即 5 分钟）进行周期性更新。</p>\n<p>timeToAllowUpdate：默认就是 refreshBackoffMs 的默认值，即 100 ms。</p>\n<p><strong>3.4 org.apache.kafka.clients.NetworkClient.DefaultMetadataUpdater#maybeUpdate(long, org.apache.kafka.common.Node)</strong></p>\n<p>我们继续跟一下 maybeUpdate 方法：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000040855916\"></p>\n<p>因此，每次 producer 请求更新 metadata 时，会有以下几种情况：</p>\n<ul>\n<li>通道已经 ready，node 可以发送请求，那么就直接发送请求。</li>\n<li>如果该 node 正在建立连接，则直接返回。</li>\n<li>如果该 node 还没建立连接，则向 broker 初始化连接。</li>\n</ul>\n<p>而 KafkaProducer 线程一直是阻塞在两个 while 循环中的，直到 metadata 更新：</p>\n<ul>\n<li>sender 线程第一次调用 poll，初始化与 node 的连接。</li>\n<li>sender 线程第二次调用 poll，发送 metadata 请求。</li>\n<li>sender 线程第三次调用 poll，获取 metadataResponse，并更新 metadata。</li>\n</ul>\n<p><strong>3.5 接收 Server 端的响应，更新 Metadata 信息</strong></p>\n<p>handleCompletedReceives 是如何处理任何已完成的接收响应，如下：</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000040855917\"></p>\n<p>之后进一步调用 handleSuccessfulResponse。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>Metadata 会在下面两种情况下进行更新：</p>\n<ul>\n<li>强制更新：调用 Metadata.requestUpdate() 将 needFullUpdate 置为 true 来强制更新。</li>\n<li>周期性更新：通过 Metadata 的 lastSuccessfulRefreshMs 和 metadataExpireMs 来实现，一般情况下，默认周期时间就是 metadataExpireMs，5 分钟时长。</li>\n</ul>\n<p>在 NetworkClient 的 poll() 方法调用时，会去检查两种更新机制，只要达到一种，就会触发更新操作。</p>\n<p>Metadata 的强制更新会在以下几种情况下进行：</p>\n<ul>\n<li>initConnect 方法调用时，初始化连接；</li>\n<li>poll() 方法中对 handleDisconnections() 方法调用来处理连接断开的情况，这时会触发强制更新；</li>\n<li>poll() 方法中对 handleTimedOutRequests() 来处理请求超时时；</li>\n<li>发送消息时，如果无法找到 partition 的 leader；</li>\n<li>处理 Producer 响应（handleProduceResponse），如果返回关于 Metadata 过期的异常，比如：没有 topic-partition 的相关 meta 或者 client 没有权限获取其 metadata。</li>\n</ul>\n<p>强制更新主要是用于处理各种异常情况。</p>\n<p>好了，Producer Metadata 读取与更新机制就说到这，我们下一期再见。</p>\n","text":"Producer Metadata 读取与更新机制一、前言宏观上介绍了 Producer 的宏观模型，其中通过 waitOnMetadata() 方法获取 to...","permalink":"/post/MIDDLEWARE/Producer Metadata 读取与更新机制","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"Metadata","slug":"Metadata","count":1,"path":"api/categories/Metadata.json"},{"name":"MIDDLEWARE","slug":"Metadata/MIDDLEWARE","count":1,"path":"api/categories/Metadata/MIDDLEWARE.json"}],"tags":[{"name":"partition","slug":"partition","count":2,"path":"api/tags/partition.json"},{"name":"metadata","slug":"metadata","count":1,"path":"api/tags/metadata.json"},{"name":"NetworkClient","slug":"NetworkClient","count":1,"path":"api/tags/NetworkClient.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Producer-Metadata-%E8%AF%BB%E5%8F%96%E4%B8%8E%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">Producer Metadata 读取与更新机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">一、前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81Metadata\"><span class=\"toc-text\">二、Metadata</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Producer-%E7%9A%84-Metadata-%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">三、Producer 的 Metadata 更新流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">四、总结</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"向量数据库","uid":"98948a6b47eff1c83e919c4c7211acdc","slug":"MIDDLEWARE/向量数据库","date":"2023-08-21T14:51:31.000Z","updated":"2025-12-05T01:47:47.410Z","comments":true,"path":"api/articles/MIDDLEWARE/向量数据库.json","keywords":"XuGuangSheng","cover":"/covers/f9f851e574d3.jpg","text":"向量数据库也许你最近可能听过这样的新闻，某向量数据库的初创公司刚写好 PPT，就获得了几千万的投资，某公司的开源的向量数据库因其代码的简陋而登上了 Hacker...","permalink":"/post/MIDDLEWARE/向量数据库","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"https","slug":"https","count":12,"path":"api/categories/https.json"},{"name":"MIDDLEWARE","slug":"https/MIDDLEWARE","count":2,"path":"api/categories/https/MIDDLEWARE.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"www","slug":"www","count":8,"path":"api/tags/www.json"},{"name":"github","slug":"github","count":1,"path":"api/tags/github.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"小米AX9000（SSH后） 开启北京联通IPTV转发服务，全家设备可以看IPTV","uid":"902bce5943bfcf4419fe702bc9520551","slug":"OTHER/小米AX9000（SSH后） 开启北京联通IPTV转发服务，全家设备可以看IPTV","date":"2023-07-26T23:55:11.000Z","updated":"2025-12-05T01:48:04.060Z","comments":true,"path":"api/articles/OTHER/小米AX9000（SSH后） 开启北京联通IPTV转发服务，全家设备可以看IPTV.json","keywords":"XuGuangSheng","cover":"/covers/ax9000ssh-iptviptv.jpg","text":"小米AX9000（SSH后） 开启北京联通IPTV转发服务，全家设备可以看IPTV北京联通，宽带+IPTV已经入户，我需求不用联通送的IPTV盒子，在一根网线（...","permalink":"/post/OTHER/小米AX9000（SSH后） 开启北京联通IPTV转发服务，全家设备可以看IPTV","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"IPTV","slug":"IPTV","count":1,"path":"api/categories/IPTV.json"},{"name":"OTHER","slug":"IPTV/OTHER","count":1,"path":"api/categories/IPTV/OTHER.json"}],"tags":[{"name":"udpxy","slug":"udpxy","count":1,"path":"api/tags/udpxy.json"},{"name":"SSH","slug":"SSH","count":1,"path":"api/tags/SSH.json"},{"name":"编辑","slug":"编辑","count":1,"path":"api/tags/编辑.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}