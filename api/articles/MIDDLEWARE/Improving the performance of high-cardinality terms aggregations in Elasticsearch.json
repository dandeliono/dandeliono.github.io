{"title":"Improving the performance of high-cardinality terms aggregations in Elasticsearch","uid":"920d4ca514647ffb02b7df5ef178364f","slug":"MIDDLEWARE/Improving the performance of high-cardinality terms aggregations in Elasticsearch","date":"2024-06-17T19:44:51.000Z","updated":"2025-09-30T03:26:47.460Z","comments":true,"path":"api/articles/MIDDLEWARE/Improving the performance of high-cardinality terms aggregations in Elasticsearch.json","keywords":"XuGuangSheng","cover":"/covers/improving-the-performance-of-high-cardinality-terms-aggregations-in-elasticsearc.jpg","content":"<h1 id=\"Improving-the-performance-of-high-cardinality-terms-aggregations-in-Elasticsearch\"><a href=\"#Improving-the-performance-of-high-cardinality-terms-aggregations-in-Elasticsearch\" class=\"headerlink\" title=\"Improving the performance of high-cardinality terms aggregations in Elasticsearch\"></a>Improving the performance of high-cardinality terms aggregations in Elasticsearch</h1><h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>An Elasticsearch <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html\">terms aggregation</a> is used to create <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket.html\">buckets</a> corresponding to unique values of a given field. For example, a terms aggregation on a field containing country names would create a bucket for USA, a bucket for Canada, a bucket for Spain, and so on. Under normal circumstances, terms aggregations are very fast, however in some exceptional cases they may be slow. One reason for slow terms aggregations may be a mis-configured cluster. Another reason for poor performance may be high-cardinality values on the field which a terms aggregation is executed on.</p>\n<p>In this blog post, I’ll first give a brief overview of general instructions that should be followed to ensure the best performance of an Elasticsearch cluster. This is then followed by several sections that present background material that will help to understand the underlying mechanics of terms aggregations, including (1) a definition of high cardinality, (2) a description of the refresh interval, and (3) a description of global ordinals. Next, I’ll show how to view the impact of building global ordinals on terms aggregation performance. Finally, I’ll present several techniques to improve the performance of high-cardinality terms aggregations, including (1) time-based indices, (2) eager global ordinals, and (3) techniques to prevent Elasticsearch from building global ordinals.</p>\n<p>In one instance, the techniques documented in this blog post were able to reduce the execution time of a high-cardinality terms aggregation that was running at a very large retail bank, from 15 seconds to below 15 milliseconds.</p>\n<h2 id=\"General-suggestions\"><a href=\"#General-suggestions\" class=\"headerlink\" title=\"General suggestions\"></a>General suggestions</h2><p>Tuning a cluster can have a large impact on overall cluster performance. The following Elasticsearch documentation provides details on configuring and tuning an Elasticsearch cluster, and should be followed:</p>\n<ul>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/system-config.html\">Important system configuration</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-search-speed.html\">Tune for search speed</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-indexing-speed.html\">Tune for indexing speed</a></li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-disk-usage.html\">Tune for disk usage</a></li>\n</ul>\n<p>Additional information on tuning slow queries can be found in <a href=\"https://www.elastic.co/blog/advanced-tuning-finding-and-fixing-slow-elasticsearch-queries\">this blog about advanced Elasticsearch tuning</a>.</p>\n<p>In addition to the above, having too many shards is a common cause of performance problems. <a href=\"https://www.elastic.co/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster\">This blog about sharding</a> gives good rules of thumb to follow.</p>\n<p>The remainder of this blog focuses specifically on understanding and tuning terms aggregations.  </p>\n<h2 id=\"Cardinality\"><a href=\"#Cardinality\" class=\"headerlink\" title=\"Cardinality\"></a>Cardinality</h2><p>The performance of terms aggregations can be greatly impacted by the cardinality of the field that is being aggregated. Cardinality refers to the uniqueness of values stored in a particular field. High cardinality means that a field contains a large percentage of unique values. Low cardinality means that a field contains a lot of repeated values. For example, a field storing country names will be relatively low cardinality since there are less than two hundred countries in the world. Alternatively, a field storing IBAN numbers or email addresses is high cardinality since there may be millions of unique values stored.</p>\n<p>When discussing high cardinality in this blog post, we are referring to fields with hundreds of thousands or millions of unique values.</p>\n<h2 id=\"Elasticsearch-refresh-interval\"><a href=\"#Elasticsearch-refresh-interval\" class=\"headerlink\" title=\"Elasticsearch refresh interval\"></a>Elasticsearch refresh interval</h2><p>In order to understand the remainder of this blog, we must have a general understanding of the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/index-modules.html#dynamic-index-settings\">refresh interval</a>.</p>\n<p>As documents are inserted into Elasticsearch, they are written into a buffer and then periodically flushed from that buffer into <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/index-modules-merge.html#index-modules-merge\">segments</a>. This flush operation is known as a <em>refresh</em>, and newly inserted documents are only searchable after a refresh. By default refreshes occur every second, however the refresh interval is configurable.</p>\n<p>The refresh interval is relevant to performance because in the background, Elasticsearch merges small segments into larger segments, and those larger segments are merged into even larger segments, and so on. Therefore, by enabling frequent refreshes, Elasticsearch needs to do more background work merging small segments than it would need to do with less frequent refreshes which would create larger segments.</p>\n<p>While frequent refreshes are necessary if near real-time search functionality is required for newly inserted data, such frequent refreshes may not be necessary in other use cases. If an application can wait longer for recent data to appear in its search results, then the refresh interval may be increased in order to improve the efficiency of data ingestion, which in turn should free up resources to help overall cluster performance.</p>\n<h2 id=\"Global-Ordinals\"><a href=\"#Global-Ordinals\" class=\"headerlink\" title=\"Global Ordinals\"></a>Global Ordinals</h2><p>Terms aggregations rely on <em>global ordinals</em> to improve efficiency. <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/eager-global-ordinals.html\">Global ordinals</a> is a data-structure that maintains an incremental numbering for each unique term for a given field. Global ordinals are computed on each shard, and by default subsequent terms aggregations will rely purely on those global ordinals to efficiently perform the aggregation at the shard level.  Global ordinals are then converted  to the real term for the final reduce phase, which combines results from different shards. If a shard is modified, then new global ordinals will need to be calculated for that shard.</p>\n<p>The performance of terms aggregations on high-cardinality fields may be slow and unpredictable in-part because (1) the time taken to build global ordinals will increase as the cardinality of the field increases, and (2) by default, global ordinals are lazily built on the first aggregation that occurs since the previous refresh. Furthermore, a combination of frequent document insertions, frequent refreshes, and frequently executed terms aggregations would cause global ordinals to be frequently recomputed. </p>\n<p>Additional details on global ordinal performance can be found in <a href=\"https://github.com/elastic/elasticsearch/issues/19780\">this GitHub issue</a>.</p>\n<h2 id=\"How-to-view-the-impact-of-global-ordinals-on-terms-aggregations\"><a href=\"#How-to-view-the-impact-of-global-ordinals-on-terms-aggregations\" class=\"headerlink\" title=\"How to view the impact of global ordinals on terms aggregations\"></a>How to view the impact of global ordinals on terms aggregations</h2><p>Elasticsearch log files are very helpful for detecting performance issues. Set <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/index-modules-slowlog.html\">log levels</a> to appropriate values, keeping in mind that excessive logging may increase disk IO and could negatively impact performance. Monitor the log file called <code>elasticsearch_index_search_slowlog.log</code>. If slow terms aggregations appear in the slowlog file, then their poor performance may be due to the building of global ordinals, which can be checked as follows:</p>\n<ul>\n<li>Continue to insert data into Elasticsearch to ensure that global ordinals will be rebuilt when we execute a terms aggregation. Copy the slow terms aggregation from the slowlog file and manually execute and <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-profile.html\">profile it</a>, to get a feeling for where execution time is spent.</li>\n<li>Continue to insert data into Elasticsearch. Copy the terms aggregation from the slowlog file and manually execute it. While the terms aggregation is executing, simultaneously execute the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.7/cluster-nodes-hot-threads.html\">hot_threads api</a>. If hot threads generally returns results that include references to <code>GlobalOrdinalsBuilder</code>, then the code may be spending significant time building global ordinals.</li>\n<li>Temporarily <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/logging.html#configuring-logging-levels\">enable logging</a> of global ordinals information by executing the following command:&#96;&#96;&#96;<br>PUT _cluster&#x2F;settings {  “transient”:  {  “logger.org.elasticsearch.index.fielddata”:  “TRACE”  }  }  <figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">This will <span class=\"built_in\">write</span> information about <span class=\"built_in\">time</span> spent building <span class=\"built_in\">global</span> ordinals <span class=\"built_in\">to</span> <span class=\"keyword\">the</span> `elasticsearch.<span class=\"built_in\">log</span>` <span class=\"built_in\">file</span>, such <span class=\"keyword\">as</span> <span class=\"keyword\">the</span> following:```</span><br><span class=\"line\"><span class=\"built_in\">global</span>-ordinals \\[&lt;field_name&gt;\\]\\[<span class=\"number\">1014089</span>\\] took \\[<span class=\"number\">592.3</span>ms\\]  </span><br></pre></td></tr></table></figure>\n\nBe sure to set the logging back to the default value after completing the above, as performance may be impacted while logging is set to <code>TRACE</code>.</li>\n<li>The size of the global ordinals data structure for a given field can be seen by viewing <code>memory_size_in_bytes</code> when executing the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-stats.html\">indices stats</a> command as follows:&#96;&#96;&#96;<br>GET <index_name>&#x2F;_stats&#x2F;fielddata?fielddata_fields&#x3D;<field_name>  <figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">The above commands should give an idea <span class=\"keyword\">if</span> building <span class=\"keyword\">global</span> ordinals <span class=\"keyword\">is</span> consuming significant resources. The remainder <span class=\"keyword\">of</span> this blog focuses <span class=\"keyword\">on</span> steps <span class=\"keyword\">to</span> mitigate the impact <span class=\"keyword\">of</span> building <span class=\"keyword\">global</span> ordinals <span class=\"keyword\">on</span> terms aggregations.</span><br><span class=\"line\"></span><br><span class=\"line\">Use <span class=\"type\">time</span>-based indices</span><br><span class=\"line\"><span class=\"comment\">----------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Global</span> ordinals <span class=\"keyword\">only</span> need <span class=\"keyword\">to</span> be re-created <span class=\"keyword\">on</span> a shard <span class=\"keyword\">if</span> that shard has been modified since the last computation <span class=\"keyword\">of</span> its <span class=\"keyword\">global</span> ordinals. <span class=\"keyword\">If</span> a shard <span class=\"keyword\">is</span> unmodified since the last computation <span class=\"keyword\">of</span> its <span class=\"keyword\">global</span> ordinals, <span class=\"keyword\">then</span> previously calculated <span class=\"keyword\">global</span> ordinals will <span class=\"keyword\">continue</span> <span class=\"keyword\">to</span> be used. <span class=\"keyword\">For</span> <span class=\"type\">time</span>-series data, implementing <span class=\"type\">time</span>-based indices <span class=\"keyword\">is</span> a good way <span class=\"keyword\">to</span> ensure that the majority <span class=\"keyword\">of</span> indices/shards remain unmodified, which will reduce the size <span class=\"keyword\">of</span> the <span class=\"keyword\">global</span> ordinals that need <span class=\"keyword\">to</span> be recomputed <span class=\"keyword\">after</span> a <span class=\"keyword\">refresh</span> operation.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">For</span> example, <span class=\"keyword\">if</span> two years <span class=\"keyword\">of</span> data <span class=\"keyword\">is</span> stored <span class=\"keyword\">in</span> monthly indices <span class=\"keyword\">instead</span> <span class=\"keyword\">of</span> <span class=\"keyword\">in</span> one <span class=\"keyword\">large</span> <span class=\"keyword\">index</span>, <span class=\"keyword\">then</span> <span class=\"keyword\">each</span> monthly <span class=\"keyword\">index</span> <span class=\"keyword\">is</span> <span class=\"number\">1</span>/<span class=\"number\">24</span>th the size that one <span class=\"keyword\">large</span> <span class=\"keyword\">index</span> would be. Since we are considering <span class=\"type\">time</span>-series data, we know that <span class=\"keyword\">only</span> the most recent monthly <span class=\"keyword\">index</span> will have <span class=\"built_in\">new</span> documents inserted. This means that <span class=\"keyword\">only</span> one <span class=\"keyword\">of</span> the <span class=\"number\">24</span> indices <span class=\"keyword\">is</span> actively written <span class=\"keyword\">into</span>. Since <span class=\"keyword\">global</span> ordinals are <span class=\"keyword\">only</span> rebuilt <span class=\"keyword\">on</span> shards that have been modified, the shards <span class=\"keyword\">in</span> <span class=\"number\">23</span> <span class=\"keyword\">of</span> the <span class=\"number\">24</span> monthly indices will <span class=\"keyword\">continue</span> <span class=\"keyword\">to</span> use previously computed <span class=\"keyword\">global</span> ordinals. This would reduce the <span class=\"keyword\">work</span> required <span class=\"keyword\">to</span> build <span class=\"keyword\">global</span> ordinals <span class=\"keyword\">by</span> a factor <span class=\"keyword\">of</span> up <span class=\"keyword\">to</span> <span class=\"number\">24</span> times <span class=\"keyword\">when</span> compared <span class=\"keyword\">to</span> storing two years worth <span class=\"keyword\">of</span> data <span class=\"keyword\">in</span> one <span class=\"keyword\">large</span> <span class=\"keyword\">index</span>.  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Enable</span> eager <span class=\"keyword\">global</span> ordinals</span><br><span class=\"line\"><span class=\"comment\">----------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">The performance <span class=\"keyword\">of</span> high-cardinality terms aggregations can be improved <span class=\"keyword\">by</span> [eager building <span class=\"keyword\">of</span> <span class=\"keyword\">global</span> ordinals](https://www.elastic.co/guide/en/elasticsearch/reference/<span class=\"number\">6.5</span>/eager-<span class=\"keyword\">global</span>-ordinals.html). Enabling eager building <span class=\"keyword\">of</span> <span class=\"keyword\">global</span> ordinals will <span class=\"keyword\">create</span> the <span class=\"keyword\">global</span> ordinals data structure <span class=\"keyword\">when</span> segments are refreshed, <span class=\"keyword\">as</span> opposed <span class=\"keyword\">to</span> the first query <span class=\"keyword\">after</span> <span class=\"keyword\">each</span> <span class=\"keyword\">refresh</span>. However, the trade-<span class=\"keyword\">off</span> <span class=\"keyword\">is</span> that eager building <span class=\"keyword\">of</span> <span class=\"keyword\">global</span> ordinals will potentially negatively impact ingest performance because <span class=\"built_in\">new</span> <span class=\"keyword\">global</span> ordinals will be computed <span class=\"keyword\">on</span> _every refresh_, even <span class=\"keyword\">if</span> they might <span class=\"keyword\">not</span> be used. <span class=\"keyword\">To</span> minimize the additional workload caused <span class=\"keyword\">by</span> frequently building <span class=\"keyword\">global</span> ordinals due <span class=\"keyword\">to</span> frequent refreshes, the <span class=\"keyword\">refresh</span> <span class=\"type\">interval</span> should be increased.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Do</span> <span class=\"keyword\">not</span> build <span class=\"keyword\">global</span> ordinals</span><br><span class=\"line\"><span class=\"comment\">----------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">Another approach <span class=\"keyword\">to</span> improving the performance <span class=\"keyword\">of</span> high-cardinality terms aggregations <span class=\"keyword\">is</span> <span class=\"keyword\">to</span> avoid the building <span class=\"keyword\">of</span> <span class=\"keyword\">global</span> ordinals entirely, <span class=\"keyword\">and</span> <span class=\"keyword\">instead</span> <span class=\"keyword\">execute</span> terms aggregations directly <span class=\"keyword\">on</span> the raw terms. This can be beneficial because computing <span class=\"keyword\">global</span> ordinals <span class=\"keyword\">on</span> a high-cardinality field may be slow, <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> building <span class=\"keyword\">global</span> ordinals will eliminate this delay. This comes at the expense <span class=\"keyword\">of</span> making <span class=\"keyword\">each</span> subsequent terms aggregation less efficient, <span class=\"keyword\">as</span> they cannot leverage <span class=\"keyword\">global</span> ordinals. </span><br><span class=\"line\"></span><br><span class=\"line\">Additionally, be aware that <span class=\"keyword\">if</span> <span class=\"keyword\">global</span> ordinals are <span class=\"keyword\">not</span> built <span class=\"keyword\">for</span> a terms aggregation, the terms aggregation will use more memory per request because Elasticsearch will need <span class=\"keyword\">to</span> keep a map <span class=\"keyword\">of</span> <span class=\"keyword\">all</span> <span class=\"keyword\">of</span> the <span class=\"keyword\">unique</span> terms that appear <span class=\"keyword\">in</span> the result <span class=\"keyword\">set</span>. This could potentially <span class=\"keyword\">trigger</span> an <span class=\"type\">internal</span> circuit breaker <span class=\"keyword\">to</span> prevent memory overuse <span class=\"keyword\">if</span> a <span class=\"keyword\">large</span> number <span class=\"keyword\">of</span> <span class=\"keyword\">unique</span> terms are <span class=\"keyword\">to</span> be aggregated, which could result <span class=\"keyword\">in</span> a failed aggregation.  </span><br><span class=\"line\"></span><br><span class=\"line\">Therefore, this approach should <span class=\"keyword\">only</span> be applied <span class=\"keyword\">if</span> a terms aggregation <span class=\"keyword\">is</span> expected <span class=\"keyword\">to</span> <span class=\"keyword\">execute</span> <span class=\"keyword\">on</span> a relatively small number <span class=\"keyword\">of</span> documents. <span class=\"keyword\">For</span> example, this would likely be the <span class=\"keyword\">case</span> <span class=\"keyword\">if</span> the aggregation <span class=\"keyword\">is</span> defined along <span class=\"keyword\">with</span> a selective [<span class=\"type\">bool</span> query](https://www.elastic.co/guide/en/elasticsearch/reference/<span class=\"keyword\">current</span>/query-dsl-<span class=\"type\">bool</span>-query.html) executing <span class=\"keyword\">in</span> [<span class=\"keyword\">filter</span> context](https://www.elastic.co/guide/en/elasticsearch/reference/<span class=\"keyword\">current</span>/query-<span class=\"keyword\">filter</span>-context.html). Run an experiment <span class=\"keyword\">with</span> <span class=\"type\">real</span> data <span class=\"keyword\">to</span> determine <span class=\"keyword\">if</span> this approach improves the performance <span class=\"keyword\">of</span> a specific use <span class=\"keyword\">case</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">In</span> Elasticsearch <span class=\"number\">6.7</span> <span class=\"keyword\">or</span> newer this can be accomplished <span class=\"keyword\">by</span> specifying [&quot;execution_hint&quot;: &quot;map&quot;](https://www.elastic.co/guide/en/elasticsearch/reference/<span class=\"keyword\">current</span>/<span class=\"keyword\">search</span>-aggregations-bucket-terms-aggregation.html#<span class=\"keyword\">search</span>-aggregations-bucket-terms-aggregation-execution-hint) which tells Elasticsearch <span class=\"keyword\">to</span> <span class=\"keyword\">aggregate</span> field <span class=\"keyword\">values</span> directly <span class=\"keyword\">without</span> leveraging <span class=\"keyword\">global</span> ordinals, <span class=\"keyword\">or</span> <span class=\"keyword\">in</span> older versions this can be accomplished <span class=\"keyword\">by</span> <span class=\"keyword\">using</span> the alternate technique <span class=\"keyword\">of</span> executing a script inside a terms aggregation, which <span class=\"keyword\">is</span> described below.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">By</span> <span class=\"keyword\">default</span> a terms aggregation will <span class=\"keyword\">return</span> buckets <span class=\"keyword\">for</span> the top ten terms ordered <span class=\"keyword\">by</span> the number <span class=\"keyword\">of</span> documents <span class=\"keyword\">in</span> <span class=\"keyword\">each</span> bucket. Below <span class=\"keyword\">is</span> an example terms aggregation <span class=\"keyword\">for</span> top IBAN identifiers. <span class=\"keyword\">By</span> <span class=\"keyword\">default</span> this terms aggregation will rebuild <span class=\"keyword\">global</span> ordinals <span class=\"keyword\">on</span> the first execution <span class=\"keyword\">after</span> the last <span class=\"keyword\">refresh</span>.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n“aggregations”:  {  “top-ibans”:  {  “terms”:  {  “field”:  “IBAN_keyword”  }  }  }<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">This could be re-written <span class=\"built_in\">to</span> avoid <span class=\"keyword\">using</span> <span class=\"built_in\">global</span> ordinals <span class=\"keyword\">in</span> Elasticsearch <span class=\"built_in\">version</span> <span class=\"number\">6.7</span> <span class=\"keyword\">or</span> newer <span class=\"keyword\">as</span> follows.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n“aggregations”:  {  “top-ibans”:  {  “terms”:  {  “field”:  “IBAN_keyword”,  “execution_hint”:  “map”  }  }  }<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">In versions <span class=\"keyword\">of</span> Elasticsearch prior <span class=\"built_in\">to</span> <span class=\"number\">6.7</span>, there was [<span class=\"keyword\">a</span> bug](<span class=\"keyword\">https</span>://github.com/elastic/elasticsearch/issues/<span class=\"number\">37705</span>) that caused <span class=\"built_in\">global</span> ordinals <span class=\"built_in\">to</span> be computed even <span class=\"keyword\">if</span> `<span class=\"string\">&quot;execution_hint&quot;</span>: <span class=\"string\">&quot;map&quot;</span>` was specified. This was fixed <span class=\"keyword\">in</span> [this github pull request](<span class=\"keyword\">https</span>://github.com/elastic/elasticsearch/pull/<span class=\"number\">37833</span>). For older versions, <span class=\"keyword\">the</span> following technique can be applied <span class=\"built_in\">to</span> prevent <span class=\"built_in\">global</span> ordinals <span class=\"built_in\">from</span> being built <span class=\"keyword\">for</span> <span class=\"keyword\">the</span> above terms aggregation. </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n“aggregations”  :  {  “top-ibans”  :  {  “terms”  :  {  “script”:  {  “source”  :  “doc[‘IBAN_keyword’].value”,  “lang”  :  “painless”  }  }  }  }</li>\n</ul>\n<pre><code>\nConclusion\n----------\n\nIn this blog post I first presented a brief overview of documentation that should be followed to ensure the best overall performance of an Elasticsearch cluster. This was followed by a deep dive into terms aggregations including an overview of how they work and several options to improve their performance.\n\nIf you have any questions about terms aggregations, Elasticsearch performance, or any other Elasticsearch-related topics, have a look at our [Discuss forums](https://discuss.elastic.co/) for valuable discussion, insights, and information. Also, don&#39;t forget to try out our [Elasticsearch Service](https://www.elastic.co/cloud/elasticsearch-service), the only hosted Elasticsearch and Kibana offering powered by the creators of Elasticsearch.\n</code></pre>\n","text":"Improving the performance of high-cardinality terms aggregations in Elasticsearc...","permalink":"/post/MIDDLEWARE/Improving the performance of high-cardinality terms aggregations in Elasticsearch","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"the","slug":"the","count":2,"path":"api/categories/the.json"},{"name":"MIDDLEWARE","slug":"the/MIDDLEWARE","count":1,"path":"api/categories/the/MIDDLEWARE.json"}],"tags":[{"name":"ordinals","slug":"ordinals","count":1,"path":"api/tags/ordinals.json"},{"name":"global","slug":"global","count":1,"path":"api/tags/global.json"},{"name":"terms","slug":"terms","count":1,"path":"api/tags/terms.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Improving-the-performance-of-high-cardinality-terms-aggregations-in-Elasticsearch\"><span class=\"toc-text\">Improving the performance of high-cardinality terms aggregations in Elasticsearch</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Introduction\"><span class=\"toc-text\">Introduction</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#General-suggestions\"><span class=\"toc-text\">General suggestions</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Cardinality\"><span class=\"toc-text\">Cardinality</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Elasticsearch-refresh-interval\"><span class=\"toc-text\">Elasticsearch refresh interval</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Global-Ordinals\"><span class=\"toc-text\">Global Ordinals</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#How-to-view-the-impact-of-global-ordinals-on-terms-aggregations\"><span class=\"toc-text\">How to view the impact of global ordinals on terms aggregations</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"ES如何在几十亿数据场景下优化查询性能","uid":"2234c4cd1c8f1704146bd28a35b83d4d","slug":"MIDDLEWARE/ES如何在几十亿数据场景下优化查询性能","date":"2024-06-17T19:45:12.000Z","updated":"2025-09-30T03:26:44.900Z","comments":true,"path":"api/articles/MIDDLEWARE/ES如何在几十亿数据场景下优化查询性能.json","keywords":"XuGuangSheng","cover":"/covers/es.jpg","text":"ES如何在几十亿数据场景下优化查询性能1. 面试官心里分析es在数据量很大的情况下（数十亿级别）如何提高查询效率啊？ 问这个问题，是肯定的，说白了，就是看你有没...","permalink":"/post/MIDDLEWARE/ES如何在几十亿数据场景下优化查询性能","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"cache","slug":"cache","count":1,"path":"api/categories/cache.json"},{"name":"MIDDLEWARE","slug":"cache/MIDDLEWARE","count":1,"path":"api/categories/cache/MIDDLEWARE.json"}],"tags":[{"name":"filesystem","slug":"filesystem","count":1,"path":"api/tags/filesystem.json"},{"name":"order","slug":"order","count":1,"path":"api/tags/order.json"},{"name":"mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"如何优雅的升级 Nginx（热部署）版本","uid":"ef5ca056fa60b2d5cee6602c81aa277f","slug":"MIDDLEWARE/如何优雅的升级 Nginx（热部署）版本","date":"2024-06-17T19:42:10.000Z","updated":"2025-09-30T03:26:54.289Z","comments":true,"path":"api/articles/MIDDLEWARE/如何优雅的升级 Nginx（热部署）版本.json","keywords":"XuGuangSheng","cover":"/covers/nginx.jpg","text":"如何优雅的升级 Nginx（热部署）版本1. 升级1.1. 下载、编译新版本的 Nginx12345➜ ~ wget https://nginx.org/dow...","permalink":"/post/MIDDLEWARE/如何优雅的升级 Nginx（热部署）版本","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Nginx","slug":"Nginx","count":1,"path":"api/categories/Nginx.json"},{"name":"MIDDLEWARE","slug":"Nginx/MIDDLEWARE","count":1,"path":"api/categories/Nginx/MIDDLEWARE.json"}],"tags":[{"name":"master","slug":"master","count":3,"path":"api/tags/master.json"},{"name":"进程","slug":"进程","count":1,"path":"api/tags/进程.json"},{"name":"worker","slug":"worker","count":1,"path":"api/tags/worker.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}