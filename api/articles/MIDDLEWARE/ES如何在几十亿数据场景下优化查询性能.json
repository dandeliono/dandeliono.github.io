{"title":"ES如何在几十亿数据场景下优化查询性能","uid":"2234c4cd1c8f1704146bd28a35b83d4d","slug":"MIDDLEWARE/ES如何在几十亿数据场景下优化查询性能","date":"2024-06-17T19:45:12.000Z","updated":"2025-09-30T03:26:44.900Z","comments":true,"path":"api/articles/MIDDLEWARE/ES如何在几十亿数据场景下优化查询性能.json","keywords":"XuGuangSheng","cover":"/covers/es.jpg","content":"<h1 id=\"ES如何在几十亿数据场景下优化查询性能\"><a href=\"#ES如何在几十亿数据场景下优化查询性能\" class=\"headerlink\" title=\"ES如何在几十亿数据场景下优化查询性能\"></a>ES如何在几十亿数据场景下优化查询性能</h1><h2 id=\"1-面试官心里分析\"><a href=\"#1-面试官心里分析\" class=\"headerlink\" title=\"1. 面试官心里分析\"></a><a href=\"#1-%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BF%83%E9%87%8C%E5%88%86%E6%9E%90\" title=\"1. 面试官心里分析\"></a>1. 面试官心里分析</h2><p>es在数据量很大的情况下（数十亿级别）如何提高查询效率啊？</p>\n<p>问这个问题，是肯定的，说白了，就是看你有没有实际干过es，因为啥？es说白了其实性能并没有你想象中那么好的。很多时候数据量大了，特别是有几亿条数据的时候，可能你会懵逼的发现，跑个搜索怎么一下5秒<del>10秒，坑爹了。第一次搜索的时候，是5</del>10秒，后面反而就快了，可能就几百毫秒。</p>\n<p>你就很懵，每个用户第一次访问都会比较慢，比较卡么？</p>\n<p>所以你要是没玩儿过es，或者就是自己玩玩儿demo，被问到这个问题容易懵逼，显示出你对es确实玩儿的不怎么样</p>\n<h2 id=\"2-面试题剖析\"><a href=\"#2-面试题剖析\" class=\"headerlink\" title=\"2. 面试题剖析\"></a><a href=\"#2-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%96%E6%9E%90\" title=\"2. 面试题剖析\"></a>2. 面试题剖析</h2><p>说实话，es性能优化是没有什么银弹的，啥意思呢？就是不要期待着随手调一个参数，就可以万能的应对所有的性能慢的场景。也许有的场景是你换个参数，或者调整一下语法，就可以搞定，但是绝对不是所有场景都可以这样。</p>\n<p>一块一块来分析吧</p>\n<p>在这个海量数据的场景下，如何提升es搜索的性能，也是我们之前生产环境实践经验所得</p>\n<h3 id=\"1-性能优化的杀手锏——filesystem-cache\"><a href=\"#1-性能优化的杀手锏——filesystem-cache\" class=\"headerlink\" title=\"1 性能优化的杀手锏——filesystem cache\"></a><a href=\"#1-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%94%E2%80%94filesystem-cache\" title=\"1 性能优化的杀手锏——filesystem cache\"></a>1 性能优化的杀手锏——filesystem cache</h3><p><strong>01_filesystem cache对es性能的影响</strong></p>\n<p><img src=\"https://haoran.tech/2019/04/23/4-ES%E5%A6%82%E4%BD%95%E5%9C%A8%E5%87%A0%E5%8D%81%E4%BA%BF%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/9c86705a-85d5-4219-b1ec-b99cd08382a4.png\"></p>\n<p>os cache，操作系统的缓存。</p>\n<p>你往es里写的数据，实际上都写到磁盘文件里去了，磁盘文件里的数据操作系统会自动将里面的数据缓存到os cache里面去</p>\n<p>es的搜索引擎严重依赖于底层的filesystem cache，你如果给filesystem cache更多的内存，尽量让内存可以容纳所有的indx segment file索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p>\n<p>性能差距可以有大，我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1秒，5秒，10秒。但是如果是走filesystem cache，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</p>\n<p>比如说，你，es节点有3台机器，每台机器，看起来内存很多，64G，总内存，64 * 3 &#x3D; 192g</p>\n<p>每台机器给es jvm heap是32G，那么剩下来留给filesystem cache的就是每台机器才32g，总共集群里给filesystem cache的就是32 * 3 &#x3D; 96g内存</p>\n<p>ok，那么就是你往es集群里写入的数据有多少数据量？</p>\n<p>如果你此时，你整个，磁盘上索引数据文件，在3台机器上，一共占用了1T的磁盘容量，你的es数据量是1t，每台机器的数据量是300g</p>\n<p>你觉得你的性能能好吗？filesystem cache的内存才100g，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差</p>\n<p>当时他们的情况就是这样子，es在测试，弄了3台机器，自己觉得还不错，64G内存的物理机。自以为可以容纳1T的数据量。</p>\n<p>归根结底，你要让es性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p>\n<p>比如说，你一共要在es中存储1T的数据，那么你的多台机器留个filesystem cache的内存加起来综合，至少要到512G，至少半数的情况下，搜索是走内存的，性能一般可以到几秒钟，2秒，3秒，5秒</p>\n<p>如果最佳的情况下，我们自己的生产环境实践经验，所以说我们当时的策略，是仅仅在es中就存少量的数据，就是你要用来搜索的那些索引，内存留给filesystem cache的，就100G，那么你就控制在100gb以内，相当于是，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在1秒以内</p>\n<p>比如说你现在有一行数据</p>\n<p>id name age ….30个字段</p>\n<p>但是你现在搜索，只需要根据id name age三个字段来搜索</p>\n<p>如果你傻乎乎的往es里写入一行数据所有的字段，就会导致说70%的数据是不用来搜索的，结果硬是占据了es机器上的filesystem cache的空间，单挑数据的数据量越大，就会导致filesystem cahce能缓存的数据就越少</p>\n<p>仅仅只是写入es中要用来检索的少数几个字段就可以了，比如说，就写入es id name age三个字段就可以了，然后你可以把其他的字段数据存在mysql里面，我们一般是建议用es + hbase的这么一个架构。</p>\n<p>hbase的特点是适用于海量数据的在线存储，就是对hbase可以写入海量数据，不要做复杂的搜索，就是做很简单的一些根据id或者范围进行查询的这么一个操作就可以了</p>\n<p>从es中根据name和age去搜索，拿到的结果可能就20个doc id，然后根据doc id到hbase里去查询每个doc id对应的完整的数据，给查出来，再返回给前端。</p>\n<p>你最好是写入es的数据小于等于，或者是略微大于es的filesystem cache的内存容量</p>\n<p>然后你从es检索可能就花费20ms，然后再根据es返回的id去hbase里查询，查20条数据，可能也就耗费个30ms，可能你原来那么玩儿，1T数据都放es，会每次查询都是5~10秒，现在可能性能就会很高，每次查询就是50ms。</p>\n<p>elastcisearch减少数据量仅仅放要用于搜索的几个关键字段即可，尽量写入es的数据量跟es机器的filesystem cache是差不多的就可以了；其他不用来检索的数据放hbase里，或者mysql。</p>\n<p>所以之前有些学员也是问，我也是跟他们说，尽量在es里，就存储必须用来搜索的数据，比如说你现在有一份数据，有100个字段，其实用来搜索的只有10个字段，建议是将10个字段的数据，存入es，剩下90个字段的数据，可以放mysql，hadoop hbase，都可以</p>\n<p>这样的话，es数据量很少，10个字段的数据，都可以放内存，就用来搜索，搜索出来一些id，通过id去mysql，hbase里面去查询明细的数据</p>\n<h3 id=\"2-数据预热\"><a href=\"#2-数据预热\" class=\"headerlink\" title=\"2 数据预热\"></a><a href=\"#2-%E6%95%B0%E6%8D%AE%E9%A2%84%E7%83%AD\" title=\"2 数据预热\"></a>2 数据预热</h3><p>假如说，哪怕是你就按照上述的方案去做了，es集群中每个机器写入的数据量还是超过了filesystem cache一倍，比如说你写入一台机器60g数据，结果filesystem cache就30g，还是有30g数据留在了磁盘上。</p>\n<p>举个例子，就比如说，微博，你可以把一些大v，平时看的人很多的数据给提前你自己后台搞个系统，每隔一会儿，你自己的后台系统去搜索一下热数据，刷到filesystem cache里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。</p>\n<p>电商，你可以将平时查看最多的一些商品，比如说iphone 8，热数据提前后台搞个程序，每隔1分钟自己主动访问一次，刷到filesystem cache里去。</p>\n<p>对于那些你觉得比较热的，经常会有人访问的数据，最好做一个专门的缓存预热子系统，就是对热数据，每隔一段时间，你就提前访问一下，让数据进入filesystem cache里面去。这样期待下次别人访问的时候，一定性能会好一些。</p>\n<h3 id=\"3-冷热分离\"><a href=\"#3-冷热分离\" class=\"headerlink\" title=\"3 冷热分离\"></a><a href=\"#3-%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB\" title=\"3 冷热分离\"></a>3 冷热分离</h3><p>关于es性能优化，数据拆分，我之前说将大量不搜索的字段，拆分到别的存储中去，这个就是类似于后面我最后要讲的mysql分库分表的垂直拆分。</p>\n<p>es可以做类似于mysql的水平拆分，就是说将大量的访问很少，频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引</p>\n<p>你最好是将冷数据写入一个索引中，然后热数据写入另外一个索引中，这样可以确保热数据在被预热之后，尽量都让他们留在filesystem os cache里，别让冷数据给冲刷掉。</p>\n<p>你看，假设你有6台机器，2个索引，一个放冷数据，一个放热数据，每个索引3个shard</p>\n<p>3台机器放热数据index；另外3台机器放冷数据index</p>\n<p>然后这样的话，你大量的时候是在访问热数据index，热数据可能就占总数据量的10%，此时数据量很少，几乎全都保留在filesystem cache里面了，就可以确保热数据的访问性能是很高的。</p>\n<p>但是对于冷数据而言，是在别的index里的，跟热数据index都不再相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就10%的人去访问冷数据；90%的人在访问热数据。</p>\n<h3 id=\"4-document模型设计\"><a href=\"#4-document模型设计\" class=\"headerlink\" title=\"4 document模型设计\"></a><a href=\"#4-document%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\" title=\"4 document模型设计\"></a>4 document模型设计</h3><p>假设场景：mysql，有两张表</p>\n<p>订单表：id order_code total_price</p>\n<p>1 测试订单 5000</p>\n<p>订单条目表：id order_id goods_id purchase_count price</p>\n<p>1 1 1 2 2000<br>2 1 2 5 200</p>\n<p>我在mysql里，都是select * from order join order_item on order.id&#x3D;order_item.order_id where order.id&#x3D;1</p>\n<p>1 测试订单 5000 1 1 1 2 2000<br>1 测试订单 5000 2 1 2 5 200</p>\n<p>在es里该怎么玩儿，es里面的复杂的关联查询，复杂的查询语法，尽量别用，一旦用了性能一般都不太好</p>\n<p>设计es里的数据模型</p>\n<p>写入es的时候，搞成两个索引，order索引，orderItem索引</p>\n<p>order索引，里面就包含id order_code total_price<br>orderItem索引，里面写入进去的时候，就完成join操作，id order_code total_price id order_id goods_id purchase_count price</p>\n<p>写入es的java系统里，就完成关联，将关联好的数据直接写入es中，搜索的时候，就不需要利用es的搜索语法去完成join来搜索了</p>\n<p>document模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es能支持的操作就是那么多，不要考虑用es做一些它不好操作的事情。如果真的有那种操作，尽量在document模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如join，nested，parent-child搜索都要尽量避免，性能都很差的。</p>\n<p>很多同学在问，很多复杂的乱七八糟的一些操作，如何执行？</p>\n<p>两个思路，在搜索&#x2F;查询的时候，要执行一些业务强相关的特别复杂的操作：</p>\n<p>1）在写入数据的时候，就设计好模型，加几个字段，把处理好的数据写入加的字段里面<br>2）自己用java程序封装，es能做的，用es来做，搜索出来的数据，在java程序里面去做，比如说我们，基于es，用java封装一些特别复杂的操作</p>\n<h3 id=\"5-分页性能优化\"><a href=\"#5-分页性能优化\" class=\"headerlink\" title=\"5 分页性能优化\"></a><a href=\"#5-%E5%88%86%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\" title=\"5 分页性能优化\"></a>5 分页性能优化</h3><p>es的分页是较坑的，为啥呢？举个例子吧，假如你每页是10条数据，你现在要查询第100页，实际上是会把每个shard上存储的前1000条数据都查到一个协调节点上，如果你有个5个shard，那么就有5000条数据，接着协调节点对这5000条数据进行一些合并、处理，再获取到最终第100页的10条数据。</p>\n<p>分布式的，你要查第100页的10条数据，你是不可能说从5个shard，每个shard就查2条数据？最后到协调节点合并成10条数据？你必须得从每个shard都查1000条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第100页的数据。</p>\n<p>你翻页的时候，翻的越深，每个shard返回的数据就越多，而且协调节点处理的时间越长。非常坑爹。所以用es做分页的时候，你会发现越翻到后面，就越是慢。</p>\n<p>我们之前也是遇到过这个问题，用es作分页，前几页就几十毫秒，翻到10页之后，几十页的时候，基本上就要5~10秒才能查出来一页数据了</p>\n<h4 id=\"1-不允许深度分页-x2F-默认深度分页性能很惨\"><a href=\"#1-不允许深度分页-x2F-默认深度分页性能很惨\" class=\"headerlink\" title=\"1 不允许深度分页&#x2F;默认深度分页性能很惨\"></a><a href=\"#1-%E4%B8%8D%E5%85%81%E8%AE%B8%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5-%E9%BB%98%E8%AE%A4%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E6%80%A7%E8%83%BD%E5%BE%88%E6%83%A8\" title=\"1 不允许深度分页/默认深度分页性能很惨\"></a>1 不允许深度分页&#x2F;默认深度分页性能很惨</h4><p>你系统不允许他翻那么深的页，pm，默认翻的越深，性能就越差</p>\n<h4 id=\"2-类似于app里的推荐商品不断下拉出来一页一页的\"><a href=\"#2-类似于app里的推荐商品不断下拉出来一页一页的\" class=\"headerlink\" title=\"2 类似于app里的推荐商品不断下拉出来一页一页的\"></a><a href=\"#2-%E7%B1%BB%E4%BC%BC%E4%BA%8Eapp%E9%87%8C%E7%9A%84%E6%8E%A8%E8%8D%90%E5%95%86%E5%93%81%E4%B8%8D%E6%96%AD%E4%B8%8B%E6%8B%89%E5%87%BA%E6%9D%A5%E4%B8%80%E9%A1%B5%E4%B8%80%E9%A1%B5%E7%9A%84\" title=\"2 类似于app里的推荐商品不断下拉出来一页一页的\"></a>2 类似于app里的推荐商品不断下拉出来一页一页的</h4><p>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用scroll api，自己百度</p>\n<p>scroll会一次性给你生成所有数据的一个快照，然后每次翻页就是通过游标移动，获取下一页下一页这样子，性能会比上面说的那种分页性能也高很多很多</p>\n<p>针对这个问题，你可以考虑用scroll来进行处理，scroll的原理实际上是保留一个数据快照，然后在一定时间内，你如果不断的滑动往后翻页的时候，类似于你现在在浏览微博，不断往下刷新翻页。那么就用scroll不断通过游标获取下一页数据，这个性能是很高的，比es实际翻页要好的多的多。</p>\n<p>但是唯一的一点就是，这个适合于那种类似微博下拉翻页的，不能随意跳到任何一页的场景。同时这个scroll是要保留一段时间内的数据快照的，你需要确保用户不会持续不断翻页翻几个小时。</p>\n<p>无论翻多少页，性能基本上都是毫秒级的</p>\n<p>因为scroll api是只能一页一页往后翻的，是不能说，先进入第10页，然后去120页，回到58页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻</p>\n","text":"ES如何在几十亿数据场景下优化查询性能1. 面试官心里分析es在数据量很大的情况下（数十亿级别）如何提高查询效率啊？ 问这个问题，是肯定的，说白了，就是看你有没...","permalink":"/post/MIDDLEWARE/ES如何在几十亿数据场景下优化查询性能","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"cache","slug":"cache","count":1,"path":"api/categories/cache.json"},{"name":"MIDDLEWARE","slug":"cache/MIDDLEWARE","count":1,"path":"api/categories/cache/MIDDLEWARE.json"}],"tags":[{"name":"filesystem","slug":"filesystem","count":1,"path":"api/tags/filesystem.json"},{"name":"order","slug":"order","count":1,"path":"api/tags/order.json"},{"name":"mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ES%E5%A6%82%E4%BD%95%E5%9C%A8%E5%87%A0%E5%8D%81%E4%BA%BF%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">ES如何在几十亿数据场景下优化查询性能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BF%83%E9%87%8C%E5%88%86%E6%9E%90\"><span class=\"toc-text\">1. 面试官心里分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%96%E6%9E%90\"><span class=\"toc-text\">2. 面试题剖析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%9D%80%E6%89%8B%E9%94%8F%E2%80%94%E2%80%94filesystem-cache\"><span class=\"toc-text\">1 性能优化的杀手锏——filesystem cache</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%95%B0%E6%8D%AE%E9%A2%84%E7%83%AD\"><span class=\"toc-text\">2 数据预热</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">3 冷热分离</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-document%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">4 document模型设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%88%86%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">5 分页性能优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%B8%8D%E5%85%81%E8%AE%B8%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5-x2F-%E9%BB%98%E8%AE%A4%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E6%80%A7%E8%83%BD%E5%BE%88%E6%83%A8\"><span class=\"toc-text\">1 不允许深度分页&#x2F;默认深度分页性能很惨</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%B1%BB%E4%BC%BC%E4%BA%8Eapp%E9%87%8C%E7%9A%84%E6%8E%A8%E8%8D%90%E5%95%86%E5%93%81%E4%B8%8D%E6%96%AD%E4%B8%8B%E6%8B%89%E5%87%BA%E6%9D%A5%E4%B8%80%E9%A1%B5%E4%B8%80%E9%A1%B5%E7%9A%84\"><span class=\"toc-text\">2 类似于app里的推荐商品不断下拉出来一页一页的</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Linux下so动态链接库使用总结","uid":"86d3016d930075b1294dec7c5e7f9e57","slug":"LINUX/Linux下so动态链接库使用总结","date":"2024-07-01T13:35:18.000Z","updated":"2025-09-30T03:26:34.326Z","comments":true,"path":"api/articles/LINUX/Linux下so动态链接库使用总结.json","keywords":"XuGuangSheng","cover":"/covers/linuxso.jpg","text":"Linux下so动态链接库使用总结本文主要总结在Linux环境下，使用so动态链接库经常遇到的问题，包括使用cp命令覆盖so导致进程coredump之类的问题。...","permalink":"/post/LINUX/Linux下so动态链接库使用总结","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"ldconfig","slug":"ldconfig","count":1,"path":"api/categories/ldconfig.json"},{"name":"LINUX","slug":"ldconfig/LINUX","count":1,"path":"api/categories/ldconfig/LINUX.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"lib","slug":"lib","count":1,"path":"api/tags/lib.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Improving the performance of high-cardinality terms aggregations in Elasticsearch","uid":"920d4ca514647ffb02b7df5ef178364f","slug":"MIDDLEWARE/Improving the performance of high-cardinality terms aggregations in Elasticsearch","date":"2024-06-17T19:44:51.000Z","updated":"2025-09-30T03:26:47.460Z","comments":true,"path":"api/articles/MIDDLEWARE/Improving the performance of high-cardinality terms aggregations in Elasticsearch.json","keywords":"XuGuangSheng","cover":"/covers/improving-the-performance-of-high-cardinality-terms-aggregations-in-elasticsearc.jpg","text":"Improving the performance of high-cardinality terms aggregations in Elasticsearc...","permalink":"/post/MIDDLEWARE/Improving the performance of high-cardinality terms aggregations in Elasticsearch","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"the","slug":"the","count":2,"path":"api/categories/the.json"},{"name":"MIDDLEWARE","slug":"the/MIDDLEWARE","count":1,"path":"api/categories/the/MIDDLEWARE.json"}],"tags":[{"name":"ordinals","slug":"ordinals","count":1,"path":"api/tags/ordinals.json"},{"name":"global","slug":"global","count":1,"path":"api/tags/global.json"},{"name":"terms","slug":"terms","count":1,"path":"api/tags/terms.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}