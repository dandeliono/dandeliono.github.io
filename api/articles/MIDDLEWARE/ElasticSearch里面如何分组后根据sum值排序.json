{"title":"ElasticSearch里面如何分组后根据sum值排序","uid":"4483f94e0db17009da0543d6cde026da","slug":"MIDDLEWARE/ElasticSearch里面如何分组后根据sum值排序","date":"2024-01-09T13:55:15.000Z","updated":"2025-12-05T01:47:25.038Z","comments":true,"path":"api/articles/MIDDLEWARE/ElasticSearch里面如何分组后根据sum值排序.json","keywords":"XuGuangSheng","cover":"/covers/elasticsearchsum.jpg","content":"<h1 id=\"ElasticSearch里面如何分组后根据sum值排序\"><a href=\"#ElasticSearch里面如何分组后根据sum值排序\" class=\"headerlink\" title=\"ElasticSearch里面如何分组后根据sum值排序\"></a>ElasticSearch里面如何分组后根据sum值排序</h1><p><a href=\"https://so.csdn.net/so/search?q=ElasticSearch&spm=1001.2101.3001.7020\">ElasticSearch</a>里面的聚合机制非常灵活和强大，今天我们来看下如何在ElasticSearch里面实现分组后，根据sum值进行排序？类似的数据库SQL如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> id,<span class=\"built_in\">sum</span>(c1) <span class=\"keyword\">as</span> c1 , <span class=\"built_in\">sum</span>(c2) <span class=\"keyword\">as</span> c2  <span class=\"keyword\">from</span> table1 <span class=\"keyword\">group</span> id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> c1 <span class=\"keyword\">desc</span>, c2 <span class=\"keyword\">asc</span></span><br></pre></td></tr></table></figure>\n\n<p>这是一个比较常见的统计需求，在es也能比较轻松的实现，先看看curl的一个实现例子查询：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;field&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;FIELD2.SUBFIELD&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后，我们看下，如何在Java Api里面操作：</p>\n<p>首先我们看下造的数据</p>\n<p>总共三个字段id,count,code都是int类型的</p>\n<p>然后，我们可以将上面的数据插入到es里面，具体的插入代码不在给出，比较简单，直接通过client.prepareIndex方法插入json即可。</p>\n<p>下面看下查询代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SearchRequestBuilder</span> <span class=\"variable\">search</span> <span class=\"operator\">=</span> client.prepareSearch(<span class=\"string\">&quot;gv_test&quot;</span>).setTypes(<span class=\"string\">&quot;gv_test&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">TermsBuilder tb= AggregationBuilders.terms(<span class=\"string\">&quot;id&quot;</span>).field(<span class=\"string\">&quot;id&quot;</span>).order(Terms.Order.compound(</span><br><span class=\"line\">    Terms.Order.aggregation(<span class=\"string\">&quot;sum_count&quot;</span>,<span class=\"literal\">false</span>), <span class=\"comment\">// 先按count，降序排</span></span><br><span class=\"line\">    Terms.Order.aggregation(<span class=\"string\">&quot;sum_code&quot;</span>,<span class=\"literal\">true</span>)   <span class=\"comment\">// 如果count相等情况下，使用code的和排序</span></span><br><span class=\"line\">));</span><br><span class=\"line\"></span><br><span class=\"line\">SumBuilder sb= AggregationBuilders.sum(<span class=\"string\">&quot;sum_count&quot;</span>).field(<span class=\"string\">&quot;count&quot;</span>);</span><br><span class=\"line\">SumBuilder sb_code= AggregationBuilders.sum(<span class=\"string\">&quot;sum_code&quot;</span>).field(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">tb.subAggregation(sb); <span class=\"comment\">//添加到分组聚合请求中</span></span><br><span class=\"line\">tb.subAggregation(sb_code); <span class=\"comment\">//添加到分组聚合请求中</span></span><br><span class=\"line\"></span><br><span class=\"line\">search.addAggregation(tb);</span><br><span class=\"line\"></span><br><span class=\"line\">Terms tms= search.get().getAggregations().get(<span class=\"string\">&quot;id&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Terms.Bucket tbb:tms.getBuckets())&#123;</span><br><span class=\"line\">    Sum sum= tbb.getAggregations().get(<span class=\"string\">&quot;sum_count&quot;</span>);</span><br><span class=\"line\">    Sum sum2=tbb.getAggregations().get(<span class=\"string\">&quot;sum_code&quot;</span>);</span><br><span class=\"line\">    System.out.println(tbb.getKey()+<span class=\"string\">&quot; &quot;</span> + tbb.getDocCount() +<span class=\"string\">&quot; &quot;</span>+sum.getValue()+<span class=\"string\">&quot; &quot;</span>+sum2.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终的结果如下：</p>\n<p>通过对比，我们可以到到结果是准确的，虽然代码量比sql多很多，但是ElasticSearch的聚合功能却是非常的强大和灵活，用来做一些OLAP分析是非常方便的。</p>\n","text":"ElasticSearch里面如何分组后根据sum值排序ElasticSearch里面的聚合机制非常灵活和强大，今天我们来看下如何在ElasticSearch里...","permalink":"/post/MIDDLEWARE/ElasticSearch里面如何分组后根据sum值排序","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"ElasticSearch","slug":"ElasticSearch","count":1,"path":"api/categories/ElasticSearch.json"},{"name":"MIDDLEWARE","slug":"ElasticSearch/MIDDLEWARE","count":1,"path":"api/categories/ElasticSearch/MIDDLEWARE.json"}],"tags":[{"name":"sum","slug":"sum","count":1,"path":"api/tags/sum.json"},{"name":"然后","slug":"然后","count":1,"path":"api/tags/然后.json"},{"name":"里面如何分组后根据","slug":"里面如何分组后根据","count":1,"path":"api/tags/里面如何分组后根据.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ElasticSearch%E9%87%8C%E9%9D%A2%E5%A6%82%E4%BD%95%E5%88%86%E7%BB%84%E5%90%8E%E6%A0%B9%E6%8D%AEsum%E5%80%BC%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">ElasticSearch里面如何分组后根据sum值排序</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Elasticsearch中如何进行日期(数值)范围查询","uid":"4bd9e9434ed4ab6b72d76312de1a0204","slug":"MIDDLEWARE/Elasticsearch中如何进行日期(数值)范围查询","date":"2024-01-09T13:56:38.000Z","updated":"2025-12-05T01:47:25.760Z","comments":true,"path":"api/articles/MIDDLEWARE/Elasticsearch中如何进行日期(数值)范围查询.json","keywords":"XuGuangSheng","cover":"/covers/elasticsearch.jpg","text":"Elasticsearch中如何进行日期(数值)范围查询 符号 含义 gte greater-than or equal to, 大于或等于 gt greate...","permalink":"/post/MIDDLEWARE/Elasticsearch中如何进行日期(数值)范围查询","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"now","slug":"now","count":1,"path":"api/categories/now.json"},{"name":"MIDDLEWARE","slug":"now/MIDDLEWARE","count":1,"path":"api/categories/now/MIDDLEWARE.json"}],"tags":[{"name":"结果是","slug":"结果是","count":1,"path":"api/tags/结果是.json"},{"name":"小时","slug":"小时","count":1,"path":"api/tags/小时.json"},{"name":"than","slug":"than","count":1,"path":"api/tags/than.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"使用 libfaketime 修改 docker 容器时间","uid":"9c243b726e495059eca1f4eed1c4f935","slug":"OCI/使用 libfaketime 修改 docker 容器时间","date":"2023-12-14T14:07:31.000Z","updated":"2025-12-05T01:47:59.851Z","comments":true,"path":"api/articles/OCI/使用 libfaketime 修改 docker 容器时间.json","keywords":"XuGuangSheng","cover":"/covers/libfaketime-docker.jpg","text":"使用 libfaketime 修改 docker 容器时间容器的时间问题：如果想要直接进入容器，使用date -s修改日期，则会出现一个 1 的错误，而且也不会...","permalink":"/post/OCI/使用 libfaketime 修改 docker 容器时间","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"使用","slug":"使用","count":2,"path":"api/categories/使用.json"},{"name":"OCI","slug":"使用/OCI","count":1,"path":"api/categories/使用/OCI.json"}],"tags":[{"name":"docker","slug":"docker","count":4,"path":"api/tags/docker.json"},{"name":"libfaketime","slug":"libfaketime","count":1,"path":"api/tags/libfaketime.json"},{"name":"cap","slug":"cap","count":1,"path":"api/tags/cap.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}