{"title":"zookeeper curator处理会话过期session expired","uid":"84d510f335cb1c9f3ff98caa4f69cfc2","slug":"MIDDLEWARE/zookeeper curator处理会话过期session expired","date":"2022-10-07T14:04:24.000Z","updated":"2025-09-30T03:26:53.936Z","comments":true,"path":"api/articles/MIDDLEWARE/zookeeper curator处理会话过期session expired.json","keywords":"XuGuangSheng","cover":"/covers/zookeeper-curatorsession-expired.jpg","content":"<h1 id=\"zookeeper-curator处理会话过期session-expired-扎心了老铁-博客园\"><a href=\"#zookeeper-curator处理会话过期session-expired-扎心了老铁-博客园\" class=\"headerlink\" title=\"zookeeper curator处理会话过期session expired - 扎心了老铁 - 博客园\"></a>zookeeper curator处理会话过期session expired - 扎心了老铁 - 博客园</h1><p>本文介绍在使用 curator 框架的时候如何 handle session expire。</p>\n<p><em><strong>1、什么是 zookeeper 的会话过期？</strong></em></p>\n<p> 一般来说，我们使用 zookeeper 是集群形式，如下图，client 和 zookeeper 集群 (3 个实例) 建立一个会话 session。</p>\n<p><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/14c6aa359f9766ccf2b813572a35317c.png\"></p>\n<p> 在这个会话 session 当中，client 其实是随机与其中一个 zk provider 建立的链接，并且互发心跳 heartbeat。zk 集群负责管理这个 session，并且在所有的 provider 上维护这个 session 的信息，包括这个 session 中定义的临时数据和监视点 watcher。</p>\n<p>如果再网络不佳或者 zk 集群中某一台 provider 挂掉的情况下，有可能出现 connection loss 的情况，例如 client 和 zk provider1 连接断开，这时候 client 不需要任何的操作 (zookeeper api 已经给我们做好了)，只需要等待 client 与其他 provider 重新连接即可。这个过程可能导致两个结果：</p>\n<p><strong>1）在 session timeout 之内连接成功</strong></p>\n<p>这个时候 client 成功切换到连接另一个 provider 例如是 provider2，由于 zk 在所有的 provider 上同步了 session 相关的数据，此时可以认为无缝迁移了。</p>\n<p><strong>2）在 session timeout 之内没有重新连接</strong></p>\n<p>这就是 session expire 的情况，这时候 zookeeper 集群会任务会话已经结束，并清除和这个 session 有关的所有数据，包括临时节点和注册的监视点 Watcher。</p>\n<p>在 session 超时之后，如果 client 重新连接上了 zookeeper 集群，很不幸，zookeeper 会发出 session expired 异常，且不会重建 session，也就是不会重建临时数据和 watcher。</p>\n<p><em><strong>2、如何使用 curator 实现 session expired 异常的捕获和处理？</strong></em></p>\n<p><strong>1）首先我们先创建一个链接</strong></p>\n<p>这里设置了重试策略 retryPolicy 和会话超时时间 sessionTimeoutMs，并打开链接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        RetryPolicy retryPolicy \\= <span class=\"keyword\">new</span> <span class=\"title class_\">ExponentialBackoffRetry</span>(baseSleepTimeMs, maxRetries);</span><br><span class=\"line\">        client \\= CuratorFrameworkFactory.builder().connectString(zookeeperServer).retryPolicy(retryPolicy)</span><br><span class=\"line\">                .sessionTimeoutMs(sessionTimeoutMs).connectionTimeoutMs(connectionTimeoutMs).build();</span><br><span class=\"line\">        client.start();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）客户端注册</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">()</span> &#123; <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String rootPath \\= <span class=\"string\">&quot;/services&quot;</span>;</span><br><span class=\"line\">            String hostAddress \\= InetAddress.getLocalHost().getHostAddress();</span><br><span class=\"line\">            String serviceInstance \\= <span class=\"string\">&quot;/prometheus&quot;</span> + <span class=\"string\">&quot;-&quot;</span> +  hostAddress + <span class=\"string\">&quot;-&quot;</span>;</span><br><span class=\"line\">            String path \\= rootPath + serviceInstance;</span><br><span class=\"line\">            SessionConnectionListener sessionConnectionListener \\= <span class=\"keyword\">new</span> <span class=\"title class_\">SessionConnectionListener</span>(path, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">            client.getConnectionStateListenable().addListener(sessionConnectionListener);</span><br><span class=\"line\">            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL\\_SEQUENTIAL).forPath(path);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">&quot;注册出错&quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 这里我们创建了一个临时有序节点 node，这个节点将会在 session expired 触发的时候被自动删除。当 session 又重新恢复的时候，client 只会收到 session expired 异常和不会自动将临时节点添加到 zookeeper 中。</p>\n<p>为了解决这个问题，我们增加了一个监听器，</p>\n<p>client.getConnectionStateListenable().addListener(sessionConnectionListener)</p>\n<p>这个监听器监听 session expired 事件，并且在事件发生的时候进行处理，监听器处理的流程如下。</p>\n<p>注意：这个监听器注册是可以复用的，即如果多次 session expired，不用重复注册监听器。</p>\n<p><strong>3、监听器 sessionConnectionListener</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.xiaoju.dqa.prometheus.client.zookeeper; <span class=\"keyword\">import</span> org.apache.curator.framework.CuratorFramework; <span class=\"keyword\">import</span> org.apache.curator.framework.state.ConnectionState; <span class=\"keyword\">import</span> org.apache.curator.framework.state.ConnectionStateListener; <span class=\"keyword\">import</span> org.apache.zookeeper.CreateMode; <span class=\"keyword\">import</span> org.slf4j.Logger; <span class=\"keyword\">import</span> org.slf4j.LoggerFactory; <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SessionConnectionListener</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ConnectionStateListener</span> &#123; <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(<span class=\"built_in\">this</span>.getClass()); <span class=\"keyword\">private</span> String path; <span class=\"keyword\">private</span> String data; <span class=\"keyword\">public</span> <span class=\"title function_\">SessionConnectionListener</span><span class=\"params\">(String path, String data)</span> &#123; <span class=\"built_in\">this</span>.path = path; <span class=\"built_in\">this</span>.data = data;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stateChanged</span><span class=\"params\">(CuratorFramework curatorFramework, ConnectionState connectionState)</span>&#123; <span class=\"keyword\">if</span>(connectionState == ConnectionState.LOST)&#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">&quot;\\[负载均衡失败\\]zk session超时&quot;</span>); <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123; <span class=\"keyword\">try</span> &#123; <span class=\"keyword\">if</span>(curatorFramework.getZookeeperClient().blockUntilConnectedOrTimedOut())&#123;</span><br><span class=\"line\">                        curatorFramework.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL\\_SEQUENTIAL).forPath(path, data.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">                        logger.info(<span class=\"string\">&quot;\\[负载均衡修复\\]重连zk成功&quot;</span>); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 这里的 ConnectionState.LOST 等同于 session expired 事件，对这个事件的处理是，在一个死循环中重试链接 zk，知道链接成功才退出循环。</p>\n<p>需要注意的是：一旦重新创建了会话，那么之前会话的所有观察点都会失效，需要重新初始化观察点。<br> <a href=\"https://www.cnblogs.com/kangoroo/p/7538314.html\">https://www.cnblogs.com/kangoroo/p/7538314.html</a></p>\n","text":"zookeeper curator处理会话过期session expired - 扎心了老铁 - 博客园本文介绍在使用 curator 框架的时候如何 hand...","permalink":"/post/MIDDLEWARE/zookeeper curator处理会话过期session expired","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"session","slug":"session","count":2,"path":"api/categories/session.json"},{"name":"MIDDLEWARE","slug":"session/MIDDLEWARE","count":1,"path":"api/categories/session/MIDDLEWARE.json"}],"tags":[{"name":"zookeeper","slug":"zookeeper","count":2,"path":"api/tags/zookeeper.json"},{"name":"client","slug":"client","count":1,"path":"api/tags/client.json"},{"name":"expired","slug":"expired","count":1,"path":"api/tags/expired.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#zookeeper-curator%E5%A4%84%E7%90%86%E4%BC%9A%E8%AF%9D%E8%BF%87%E6%9C%9Fsession-expired-%E6%89%8E%E5%BF%83%E4%BA%86%E8%80%81%E9%93%81-%E5%8D%9A%E5%AE%A2%E5%9B%AD\"><span class=\"toc-text\">zookeeper curator处理会话过期session expired - 扎心了老铁 - 博客园</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"记一次spring boot 功能模块化 freemarker只能识别一个resources目录下前端展示模板问题","uid":"b118a4f61bac8ee2550c64d69640d355","slug":"JAVA/记一次spring boot 功能模块化 freemarker只能识别一个resources目录下前端展示模板问题","date":"2022-10-07T14:04:24.000Z","updated":"2025-09-30T03:26:29.807Z","comments":true,"path":"api/articles/JAVA/记一次spring boot 功能模块化 freemarker只能识别一个resources目录下前端展示模板问题.json","keywords":"XuGuangSheng","cover":"/covers/spring-boot-freemarkerresources.jpg","text":"记一次spring boot 功能模块化 freemarker只能识别一个resources目录下前端展示模板问题 - 一枚码农的个人空间 - OSCHINA ...","permalink":"/post/JAVA/记一次spring boot 功能模块化 freemarker只能识别一个resources目录下前端展示模板问题","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"resource","slug":"resource","count":1,"path":"api/categories/resource.json"},{"name":"JAVA","slug":"resource/JAVA","count":1,"path":"api/categories/resource/JAVA.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"raw","slug":"raw","count":5,"path":"api/tags/raw.json"},{"name":"freemarker","slug":"freemarker","count":1,"path":"api/tags/freemarker.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制","uid":"5216b5eeb1a6215d7622123c3d5153cb","slug":"NETWORK/30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制","date":"2022-09-29T15:46:08.000Z","updated":"2025-09-30T03:26:55.085Z","comments":true,"path":"api/articles/NETWORK/30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制.json","keywords":"XuGuangSheng","cover":"/covers/30-tcp.jpg","text":"30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制相信大家都知道 TCP 是一个可靠传输的协议，那它是如何保证可靠的呢？ 为了实现可靠性传输，需要考虑很多...","permalink":"/post/NETWORK/30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"TCP","slug":"TCP","count":3,"path":"api/categories/TCP.json"},{"name":"NETWORK","slug":"TCP/NETWORK","count":1,"path":"api/categories/TCP/NETWORK.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"ACK","slug":"ACK","count":2,"path":"api/tags/ACK.json"},{"name":"cwnd","slug":"cwnd","count":1,"path":"api/tags/cwnd.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}