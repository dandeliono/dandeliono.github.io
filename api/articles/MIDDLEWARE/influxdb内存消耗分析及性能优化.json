{"title":"influxdb内存消耗分析及性能优化","uid":"9736c920c0447b484184935c1c343c5b","slug":"MIDDLEWARE/influxdb内存消耗分析及性能优化","date":"2023-04-19T16:34:36.000Z","updated":"2025-12-05T01:47:40.565Z","comments":true,"path":"api/articles/MIDDLEWARE/influxdb内存消耗分析及性能优化.json","keywords":"XuGuangSheng","cover":"/covers/influxdb.jpg","content":"<h1 id=\"influxdb内存消耗分析及性能优化\"><a href=\"#influxdb内存消耗分析及性能优化\" class=\"headerlink\" title=\"influxdb内存消耗分析及性能优化\"></a>influxdb内存消耗分析及性能优化</h1><p><img src=\"https://zyun.360.cn/blog/wp-content/uploads/2021/03/0319-2-1024x435.jpg\"></p>\n<p>influxdb目前支持内存型索引<strong>inmem</strong>及文件型索引<strong>tsi1</strong>。之前追踪篇将influxd索引修改为<strong>tsi1</strong>之后，经过一段时间的运行，从监控观察到，由于调用方采用<strong>异步队列+批处理</strong>的方案将数据写入influxdb，会在某些时刻调用方内部出现数据堆积，指标如图:</p>\n<ul>\n<li>横坐标: 时间轴，从12-29 00:00 到 12-30 00:00</li>\n<li>纵坐标: 队列中数据堆积长度，坐标最大值250k，即最大25w个数据堆积</li>\n</ul>\n<p><img src=\"https://zyun.360.cn/blog/wp-content/uploads/2021/03/1%E5%A4%A7%E5%9B%BE-1024x374.png\"></p>\n<p>从上图可以看到，当天监控出现数次堆积，上午7:00-10:00尤为严重。在堆积时，登录influxdb服务器，查看机器状态如下:</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 09:40:58 up<span class=\"number\"> 120 </span>days, 19:18, <span class=\"number\"> 1 </span>user,  load average: 32.29, 32.32, 29.82</span><br><span class=\"line\">Tasks:<span class=\"number\"> 364 </span>total,  <span class=\"number\"> 1 </span>running,<span class=\"number\"> 363 </span>sleeping,  <span class=\"number\"> 0 </span>stopped,  <span class=\"number\"> 0 </span>zombie</span><br><span class=\"line\">%Cpu(s):  0.4 us,  0.1 sy,  0.0 ni, 57.7 id, 41.8 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">KiB Mem :<span class=\"number\"> 65433892 </span>total,  <span class=\"number\"> 376024 </span>free,<span class=\"number\"> 30179144 </span>used,<span class=\"number\"> 34878724 </span>buff/cache</span><br><span class=\"line\">KiB Swap:<span class=\"number\"> 32833532 </span>total,<span class=\"number\"> 32689404 </span>free,  <span class=\"number\"> 26624 </span>used.<span class=\"number\"> 34607748 </span>avail Mem </span><br><span class=\"line\"></span><br><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR    S   %CPU %MEM     TIME+ COMMAND </span><br><span class=\"line\">9571 root     <span class=\"number\"> 20 </span> <span class=\"number\"> 0 </span>    0.269t 0.053t 0.025t  D  14.6 86.2     1081:18 influxd</span><br></pre></td></tr></table></figure>\n\n<p>在出现堆积时，wa很高，说明问题再次出现在磁盘io上，而且influxd的SHR空间占用了25g，又是为什么？ 面对新出现的问题，当前的主要手段仍然是从influxdb配置文件入手，但是该如何优化?</p>\n<p><strong>工欲善其事，必先利其器。</strong> </p>\n<p>查阅了相关资料之后，整理了influxdb使用<strong>tsi</strong>索引时原理图:</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-c1db4cd93434373bb77e9fa299461336_720w.png\"></p>\n<p>说明:</p>\n<ul>\n<li>写入influxdb时，会同时写wal文件及cache内存, wal用于宕机恢复cache</li>\n<li>cache在达到配置中的阈值时，会进行snapshot快照,进行落盘</li>\n<li>influxdb的series及index索引会在内存中全量保存，用于快速检索</li>\n<li>wal文件大小在达到配置中阈值时，会进行压缩转换到index索引</li>\n<li>influxdb会对磁盘数据文件NaN按照分片shard维度进行四次压缩(level1,2,3及full)，以节约磁盘空间</li>\n</ul>\n<p>在队列堆积的时间点，经过多次对比influxdb的日志:</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#调用方队列堆积时，influxdb的关键日志如下:</span></span><br><span class=\"line\"><span class=\"comment\">#influx开始执行第四次全量压缩策略，tsm1_strategy=full</span></span><br><span class=\"line\"><span class=\"attribute\">ts</span>=2021-01-05T10:30:02.049644Z <span class=\"attribute\">lvl</span>=info <span class=\"attribute\">msg</span>=<span class=\"string\">&quot;TSM compaction (start)&quot;</span> log\\<span class=\"attribute\">_id</span>=0RVRbtjl000 <span class=\"attribute\">engine</span>=tsm1 tsm1\\<span class=\"attribute\">_strategy</span>=full tsm1\\<span class=\"attribute\">_optimize</span>=<span class=\"literal\">false</span> trace\\<span class=\"attribute\">_id</span>=0RWXOKGG000 op\\<span class=\"attribute\">_name</span>=tsm1\\_compact\\_group op\\<span class=\"attribute\">_event</span>=start</span><br><span class=\"line\"><span class=\"built_in\">..</span>.</span><br><span class=\"line\"><span class=\"comment\">#省略</span></span><br><span class=\"line\"><span class=\"built_in\">..</span>.</span><br><span class=\"line\"><span class=\"comment\">#第四次全量压缩结束</span></span><br><span class=\"line\"><span class=\"attribute\">ts</span>=2021-01-05T10:44:13.931365Z <span class=\"attribute\">lvl</span>=info <span class=\"attribute\">msg</span>=<span class=\"string\">&quot;TSM compaction (end)&quot;</span> log\\<span class=\"attribute\">_id</span>=0RVRbtjl000 <span class=\"attribute\">engine</span>=tsm1 tsm1\\<span class=\"attribute\">_strategy</span>=full tsm1\\<span class=\"attribute\">_optimize</span>=<span class=\"literal\">false</span> trace\\<span class=\"attribute\">_id</span>=0RWXOKGG000 op\\<span class=\"attribute\">_name</span>=tsm1\\_compact\\_group op\\<span class=\"attribute\">_event</span>=end <span class=\"attribute\">op_elapsed</span>=851881.724ms</span><br><span class=\"line\"><span class=\"built_in\">..</span>.</span><br><span class=\"line\"><span class=\"built_in\">..</span>.</span><br></pre></td></tr></table></figure>\n\n<p>此时influxdb进行分片数据的第四次的全量压缩，会进行大量的磁盘io及cpu压缩计算，导致服务的压力增大，所以调用方队列出现数据堆积，相关参数见配置文件:</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#influxdb部分配置文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#描述：内存快照的冷冻写入周期，默认10m</span></span><br><span class=\"line\"><span class=\"comment\">#场景: 当创建新的shard分片开始接受数据之后，上个shard分片进入冷冻期，</span></span><br><span class=\"line\"><span class=\"comment\">#冷冻期的shard分片不再接收写入的请求，10分钟之后，会将内存里冷冻shard的cache进行落盘操作</span></span><br><span class=\"line\"><span class=\"comment\">#应用: 本文设置为30分钟。个人认为时间越短，会越快释放上个shard的内存cache</span></span><br><span class=\"line\"><span class=\"attr\">cache-snapshot-write-cold-duration</span> = <span class=\"string\">&quot;30m&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#描述: 使用全量策略压缩冷冻期分片的周期，默认4h</span></span><br><span class=\"line\"><span class=\"comment\">#场景: 当shard进入冷冻期后，会经过4h,开始进行全量压缩策略，进一步减少shard落盘数据占用的空间</span></span><br><span class=\"line\"><span class=\"comment\">#与cache-snapshot-write-cold-duration配合使用</span></span><br><span class=\"line\"><span class=\"comment\">#可以从日志中看到，新分片开始写入数据之后，在4h+10m之后，会对上个分片进行全量压缩策略</span></span><br><span class=\"line\"><span class=\"comment\">#应用: 本文设置为80小时。目的是不进行full压缩策略，来避免io过多消耗，后面会介绍由于设置的retention policy为72小时，所以此处大于72即可。</span></span><br><span class=\"line\"><span class=\"attr\">compact-full-write-cold-duration</span> = <span class=\"string\">&quot;80h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#描述: 最大并行压缩数,默认会使用golang的逻辑处理器的一半</span></span><br><span class=\"line\"><span class=\"comment\">#场景: 当进行level1，level2,level3及full策略压缩文件时使用的处理器数量，</span></span><br><span class=\"line\"><span class=\"comment\">#当前服务器为16core32物理线程，则会在压缩时默认使用16个处理器</span></span><br><span class=\"line\"><span class=\"comment\">#应用: 本文设置为8。用于减轻压缩策略时，cpu与磁盘io的压力，但相应的会导致压缩周期变长。</span></span><br><span class=\"line\"><span class=\"attr\">max-concurrent-compactions</span> = <span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#描述: 压缩文件时,每秒写入磁盘的数据量，默认48MB</span></span><br><span class=\"line\"><span class=\"comment\">#应用：本文设置为16MB，用于减轻磁盘写入时的压力，同样会导致压缩周期变长。</span></span><br><span class=\"line\"><span class=\"attr\">compact-throughput</span> = <span class=\"string\">&quot;16m&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#描述: 压缩文件时,每秒最大写入磁盘的峰值数据量，默认48MB</span></span><br><span class=\"line\"><span class=\"comment\">#应用：本文设置为16MB，用于减轻磁盘写入时的压力，同样会导致压缩周期变长。</span></span><br><span class=\"line\"><span class=\"attr\">compact-throughput-burst</span> = <span class=\"string\">&quot;16m&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>在本文第1小节中，使用linux的<strong>top</strong>命令可以看到，influxd进程占用RES内存为53g, SHR内存为25g。所以引申问题:</p>\n<ul>\n<li>何为SHR?</li>\n<li>为什么会有那么多的SHR?</li>\n<li>SHR对系统有什么影响?</li>\n</ul>\n<p>使用man查看top命令的解释:SHR – Shared Memory Size (KiB) The amount of shared memory available to a task, not all of which is typically resident. It simply reflects memory that could be potentially shared with other processes. 共享内存的大小 程序共享内存的数据量，并不是全部驻留在内存空间，通常反映了与其他程序潜在共用的内存。</p>\n<p>那为什么influxd会有那么高的共享内存？通过linux进程smaps分析当前实际占用内存的大小。</p>\n<p><strong><em>注: smaps中有些文件的引用仅占用虚拟内存，而不占用物理内存</em></strong></p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#influxdb当前程序运行pid为: <span class=\"number\">9571</span></span><br><span class=\"line\">#<span class=\"number\">1</span>.计算influxdb数据文件通过shr占用物理内存大小,筛选出内存占用大于<span class=\"number\">10</span>m的文件:</span><br><span class=\"line\">\\&gt; cat <span class=\"regexp\">/proc/</span><span class=\"number\">9571</span><span class=\"regexp\">/smaps | sed -n &#x27;/</span>rp\\_iot\\_cloud<span class=\"regexp\">/,+2p&#x27; | grep -v &#x27;Size:&#x27; | sed &#x27;s/</span>\\ kB<span class=\"comment\">//&#x27; | awk &#x27;&#123;print $NF&#125;&#x27; | awk &#x27;BEGIN&#123;i=-1&#125;&#123;i++;a\\[i\\]=$0&#125;END&#123;for(k=0;k&lt;length(a);k=k+2) &#123;if(a\\[k+1\\]/1000&gt;10)&#123;m+=a\\[k+1\\]/1000;print a\\[k\\],a\\[k+1\\]/1000,m&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\">\\-\\-\\-\\-\\-\\-\\-\\-\\- 文件名称  \\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\- 当前文件占用内存(MB) ----- 每行累计占用内存(MB) ----</span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000000640</span>-<span class=\"number\">000000010</span>.tsm <span class=\"number\">550.148</span> <span class=\"number\">550.148</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000000640</span>-<span class=\"number\">000000009</span>.tsm <span class=\"number\">322.392</span> <span class=\"number\">872.54</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000000640</span>-<span class=\"number\">000000008</span>.tsm <span class=\"number\">228.524</span> <span class=\"number\">1101.06</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000000512</span>-<span class=\"number\">000000010</span>.tsm <span class=\"number\">636.132</span> <span class=\"number\">1737.2</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000000512</span>-<span class=\"number\">000000009</span>.tsm <span class=\"number\">336.532</span> <span class=\"number\">2073.73</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000000512</span>-<span class=\"number\">000000008</span>.tsm <span class=\"number\">231.336</span> <span class=\"number\">2305.06</span></span><br><span class=\"line\">...</span><br><span class=\"line\">#省略</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000000384</span>-<span class=\"number\">000000005</span>.tsm <span class=\"number\">560.716</span> <span class=\"number\">17183.6</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000001209</span>-<span class=\"number\">000000002</span>.tsm <span class=\"number\">315.204</span> <span class=\"number\">17498.8</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000001216</span>-<span class=\"number\">000000001</span>.tsm <span class=\"number\">55.644</span> <span class=\"number\">17554.4</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/rp\\_iot_cloud/</span><span class=\"number\">233</span>/<span class=\"number\">000000256</span>-<span class=\"number\">000000005</span>.tsm <span class=\"number\">514</span> <span class=\"number\">18068.4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">2</span>.计算influxdb索引series文件通过shr占用物理内存大小,筛选出内存占用大于<span class=\"number\">10</span>m的文件:</span><br><span class=\"line\">\\&gt; cat <span class=\"regexp\">/proc/</span><span class=\"number\">9571</span><span class=\"regexp\">/smaps | sed -n &#x27;/</span>series<span class=\"regexp\">/,+2p&#x27; | grep -v &#x27;Size:&#x27; | sed &#x27;s/</span>\\ kB<span class=\"comment\">//&#x27; | awk &#x27;&#123;print $NF&#125;&#x27; | awk &#x27;BEGIN&#123;i=-1&#125;&#123;i++;a\\[i\\]=$0&#125;END&#123;for(k=0;k&lt;length(a);k=k+2) &#123;if(a\\[k+1\\]/1000&gt;10)&#123;m+=a\\[k+1\\]/1000;print a\\[k\\],a\\[k+1\\]/1000,m&#125;&#125;&#125;&#x27;</span></span><br><span class=\"line\">\\-\\-\\-\\-\\-\\-\\-\\-\\- 文件名称  \\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\- 当前文件占用内存(MB) ----- 每行累计占用内存(MB) ----</span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/\\_series/</span><span class=\"number\">07</span>/index <span class=\"number\">517.4</span> <span class=\"number\">517.4</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/\\_series/</span><span class=\"number\">07</span>/<span class=\"number\">0007</span> <span class=\"number\">99.032</span> <span class=\"number\">616.432</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/\\_series/</span><span class=\"number\">07</span>/<span class=\"number\">0006</span> <span class=\"number\">98.896</span> <span class=\"number\">715.328</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/\\_series/</span><span class=\"number\">07</span>/<span class=\"number\">0005</span> <span class=\"number\">62.732</span> <span class=\"number\">778.06</span></span><br><span class=\"line\">...</span><br><span class=\"line\">#省略</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/\\_series/</span><span class=\"number\">01</span>/<span class=\"number\">0002</span> <span class=\"number\">16.352</span> <span class=\"number\">7014.15</span></span><br><span class=\"line\"><span class=\"regexp\">/data/i</span>nfluxdb<span class=\"regexp\">/data/i</span>ot\\_cloud<span class=\"regexp\">/\\_series/</span><span class=\"number\">00</span>/<span class=\"number\">0002</span> <span class=\"number\">16.36</span> <span class=\"number\">7030.51</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看出程序运行时，会加载iot_cloud库文件:</p>\n<ul>\n<li>tsm数据文件(主要为当前shard的文件，共约18G)</li>\n<li>series文件(所有series文件，共约7G)</li>\n</ul>\n<p>加载的内存大小与SHR内存基本吻合。基于当前的分片策略retention policy周期为7天，每天一分片，所以可以从分片角度减少shard占用的内存。笔者尝试调整分片策略:</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#当前influxdb中数据库名</span></span><br><span class=\"line\"><span class=\"attribute\">use</span> iot_cloud</span><br><span class=\"line\"><span class=\"comment\">#修改保留策略为周期为3天，每2小时一分片</span></span><br><span class=\"line\"><span class=\"attribute\">alter</span> retention policy rp\\_iot\\_cloud <span class=\"literal\">on</span> iot_cloud duration <span class=\"number\">3</span>d  REPLICATION <span class=\"number\">1</span>  SHARD DURATION <span class=\"number\">2</span>h default</span><br></pre></td></tr></table></figure>\n\n<p>调整为2小时一分片之后，SHR内存峰值会减少10-15g左右的占用。但是缩短分片间隔之后，influxdb会更频繁的进行内部自检及数据压缩，会造成cpu及磁盘io的消耗。所以继续考虑SHR占用较大对系统会有什么影响？应用程序在启动之后，会共享系统一些内存:</p>\n<ul>\n<li>堆内存(共享函数库消耗的堆空间)</li>\n<li>文件缓存(从磁盘读取文件进行缓存)</li>\n</ul>\n<p>对于共享堆内存则是必须占用的物理空间，而文件缓存则是系统针对磁盘读取的优化。目前influxdb在内存中引入了大量文件，在内存充足时，会占用较多的空间，用于提高程序读取性能。</p>\n<p>cpu硬件体系架构可以分为:</p>\n<ul>\n<li>SMP(Symmetric Multi-Processor)&#x2F;UMA(Uniform Memory Access)模式SMP架构，所有的CPU争用一个总线来访问所有内存，优点是资源共享，而缺点是总线争用激烈。 实验证明，SMP服务器CPU利用率最好的情况是2至4个CPU</li>\n<li>NUMA(Non-Uniform Memory Access)模式NUMA架构引入了node和distance的概念。对于CPU和内存这两种最宝贵的硬件资源， NUMA用近乎严格的方式划分了所属的资源组（node），而每个资源组内的CPU和内存是几乎相等。</li>\n</ul>\n<p>在influxdb服务器上，查看当前cpu及numa相关信息如下:</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#lscpu用于查看当前cpu相关信息</span></span><br><span class=\"line\">\\&gt; lscpu</span><br><span class=\"line\">Architecture:          x86_64</span><br><span class=\"line\">CPU op-mode(s):        32-bit, 64-bit</span><br><span class=\"line\">Byte Order:            Little Endian</span><br><span class=\"line\">CPU(s):               <span class=\"number\"> 32 </span>        <span class=\"comment\">#共32个逻辑核数</span></span><br><span class=\"line\">On-line CPU(s) list:   0-31       </span><br><span class=\"line\">Thread(s) per core:   <span class=\"number\"> 2 </span>         <span class=\"comment\">#每个核心支持2个物理线程</span></span><br><span class=\"line\">Core(s) per socket:   <span class=\"number\"> 8 </span>         <span class=\"comment\">#每个卡槽有8个核心</span></span><br><span class=\"line\">Socket(s):            <span class=\"number\"> 2 </span>         <span class=\"comment\">#共2个卡槽，总共16个核心</span></span><br><span class=\"line\">NUMA node(s):         <span class=\"number\"> 2 </span>         <span class=\"comment\">#共2个numa节点</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">L1d cache:             32K</span><br><span class=\"line\">L1i cache:             32K</span><br><span class=\"line\">L2 cache:              256K</span><br><span class=\"line\">L3 cache:              20480K</span><br><span class=\"line\">NUMA node0 CPU(s):     0-7,16-23       <span class=\"comment\">#numa节点分布</span></span><br><span class=\"line\">NUMA node1 CPU(s):     8-15,24-31</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#numactl --hardware用于查看相关硬件信息</span></span><br><span class=\"line\">\\&gt; numactl --hardware</span><br><span class=\"line\">available:<span class=\"number\"> 2 </span>nodes (0-1)</span><br><span class=\"line\">node<span class=\"number\"> 0 </span>cpus:<span class=\"number\"> 0 </span>1<span class=\"number\"> 2 </span>3<span class=\"number\"> 4 </span>5<span class=\"number\"> 6 </span>7<span class=\"number\"> 16 </span>17<span class=\"number\"> 18 </span>19<span class=\"number\"> 20 </span>21<span class=\"number\"> 22 </span>23</span><br><span class=\"line\">node<span class=\"number\"> 0 </span>size:<span class=\"number\"> 32365 </span>MB    <span class=\"comment\">#节点0分配内存为32G</span></span><br><span class=\"line\">node<span class=\"number\"> 0 </span>free:<span class=\"number\"> 185 </span>MB      <span class=\"comment\">#节点0剩余内存185M</span></span><br><span class=\"line\">node<span class=\"number\"> 1 </span>cpus:<span class=\"number\"> 8 </span>9<span class=\"number\"> 10 </span>11<span class=\"number\"> 12 </span>13<span class=\"number\"> 14 </span>15<span class=\"number\"> 24 </span>25<span class=\"number\"> 26 </span>27<span class=\"number\"> 28 </span>29<span class=\"number\"> 30 </span>31</span><br><span class=\"line\">node<span class=\"number\"> 1 </span>size:<span class=\"number\"> 32768 </span>MB    <span class=\"comment\">#节点1分配内存为32G</span></span><br><span class=\"line\">node<span class=\"number\"> 1 </span>free:<span class=\"number\"> 2492 </span>MB     <span class=\"comment\">#节点1剩余内存2492M</span></span><br><span class=\"line\">node distances:</span><br><span class=\"line\">node  <span class=\"number\"> 0 </span> <span class=\"number\"> 1 </span></span><br><span class=\"line\">  0: <span class=\"number\"> 10 </span><span class=\"number\"> 21 </span></span><br><span class=\"line\">  1: <span class=\"number\"> 21 </span> 10</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#numastat查看当前状态</span></span><br><span class=\"line\"><span class=\"comment\">#miss值和foreign值越高，就要考虑绑定的问题。</span></span><br><span class=\"line\">\\&gt; numastat</span><br><span class=\"line\">                           node0           node1</span><br><span class=\"line\">numa_hit            <span class=\"number\"> 46726204589 </span>    16958785317</span><br><span class=\"line\">numa\\_miss            <span class=\"number\"> 1636704898 </span>   <span class=\"number\"> 11155932344 </span><span class=\"comment\">#numa\\_miss较高</span></span><br><span class=\"line\">numa_foreign        <span class=\"number\"> 11155932344 </span>     1636704898</span><br><span class=\"line\">interleave_hit            <span class=\"number\"> 22442 </span>          22958</span><br><span class=\"line\">local_node          <span class=\"number\"> 46726202598 </span>    16958838294</span><br><span class=\"line\">other\\_node           <span class=\"number\"> 1636706889 </span>   <span class=\"number\"> 11155879367 </span><span class=\"comment\">#other\\_node较高</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#numactl --show 用于查看当前numa策略</span></span><br><span class=\"line\">\\&gt; numactl --show</span><br><span class=\"line\">policy: default        <span class=\"comment\">#使用默认策略(localalloc)</span></span><br><span class=\"line\">preferred node: current</span><br><span class=\"line\">physcpubind:<span class=\"number\"> 0 </span>1<span class=\"number\"> 2 </span>3<span class=\"number\"> 4 </span>5<span class=\"number\"> 6 </span>7<span class=\"number\"> 8 </span>9<span class=\"number\"> 10 </span>11<span class=\"number\"> 12 </span>13<span class=\"number\"> 14 </span>15<span class=\"number\"> 16 </span>17<span class=\"number\"> 18 </span>19<span class=\"number\"> 20 </span>21<span class=\"number\"> 22 </span>23<span class=\"number\"> 24 </span>25<span class=\"number\"> 26 </span>27<span class=\"number\"> 28 </span>29<span class=\"number\"> 30 </span>31 </span><br><span class=\"line\">cpubind:<span class=\"number\"> 0 </span>1 </span><br><span class=\"line\">nodebind:<span class=\"number\"> 0 </span>1 </span><br><span class=\"line\">membind:<span class=\"number\"> 0 </span>1</span><br></pre></td></tr></table></figure>\n\n<p>通过查询，发现当前的numa策略会出现大量的miss。由于influxdb基于go语言开发，go语言社区中有关于 numa 感知调度的设计文档，但是本身的实现过于复杂，所以 go 语言团队在最新1.15版本还没有着手实现。目前根据相关资料，考虑influxdb运行时会占用大规模内存，建议通过如下方式启动influxdb:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numactl --interleave=all <span class=\"regexp\">/usr/</span>bin<span class=\"regexp\">/influxd  -config  /u</span>sr<span class=\"regexp\">/bin/i</span>nfluxdb.conf</span><br></pre></td></tr></table></figure>\n\n<p>从系统角度，应该同时关注influxdb写入和读取两个维度。 写入端应从具体业务场景，提前划分好写入的tags及fields，从而避免产生大量的series导致内存膨胀过快。而读取端，应明确查询时间范围，命中更少的分片数据，来防止加载大量的无用查询结果而导致程序OOM。 走查了读取端相关influxdb查询语句，发现几处类似如下消耗内存及性能的语句:</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#表描述</span><br><span class=\"line\">\\- 表名: <span class=\"keyword\">table</span></span><br><span class=\"line\">\\- tags: productKey,deviceName</span><br><span class=\"line\">\\- fields: identifier</span><br><span class=\"line\"></span><br><span class=\"line\">#修改之前的<span class=\"keyword\">sql</span></span><br><span class=\"line\">#由于没有时间范围，会导致查询所有shard数据，并从磁盘加载到内存，最后进行排序</span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> productKey=? <span class=\"keyword\">and</span> deviceName=? <span class=\"keyword\">and</span> identifier=? <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"type\">time</span> <span class=\"keyword\">desc</span> <span class=\"keyword\">limit</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">#优化之后的<span class=\"keyword\">sql</span></span><br><span class=\"line\">#根据业务场景，此处可以仅查询最近<span class=\"number\">2</span>小时内的数据，避免全分片</span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> <span class=\"type\">time</span> &gt; now()<span class=\"number\">-2</span>h <span class=\"keyword\">and</span> productKey=? <span class=\"keyword\">and</span> deviceName=? <span class=\"keyword\">and</span> identifier=? <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"type\">time</span> <span class=\"keyword\">desc</span> <span class=\"keyword\">limit</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>本文整理了业务中使用influxdb遇到的问题，并提出了一些优化方案。目前来看，influxdb对于笔者仍然是一个黑盒程序，更细致的内容就需要从源码追寻。 当前采用了如下方式进行优化(由于需要对配置参数，策略各方面权衡，这是一个持续的过程)：</p>\n<p><strong>(1) retention policy</strong></p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#将保留策略修改为：3天一周期；1天一分片</span></span><br><span class=\"line\"><span class=\"attribute\">alter</span> retention policy rp\\_iot\\_cloud <span class=\"literal\">on</span> iot_cloud duration <span class=\"number\">3</span>d  REPLICATION <span class=\"number\">1</span>  SHARD DURATION <span class=\"number\">1</span>d default</span><br></pre></td></tr></table></figure>\n\n<p><strong>(2) 配置文件</strong></p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#influxdb配置文件，主要参数如下:</span></span><br><span class=\"line\">\\[data\\]</span><br><span class=\"line\">  <span class=\"comment\">#wal日志落盘周期，官方建议0-100ms</span></span><br><span class=\"line\">  <span class=\"comment\">#尝试了100ms,50ms,20ms之后，目前折中采用50ms</span></span><br><span class=\"line\">  wal-fsync-delay = <span class=\"string\">&quot;50ms&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#使用tsi1索引</span></span><br><span class=\"line\">  index-<span class=\"built_in\">version</span> = <span class=\"string\">&quot;tsi1&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#分片允许最大内存,当超过最大内存会拒绝写入</span></span><br><span class=\"line\">  <span class=\"comment\">#内存越大，多个新老分片会占用更多的堆空间</span></span><br><span class=\"line\">  cache-<span class=\"built_in\">max</span>-memory-size = <span class=\"string\">&quot;2g&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#当cache超过128m时，会进行快照落盘</span></span><br><span class=\"line\">  cache-snapshot-memory-size = <span class=\"string\">&quot;128m&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#cache冷冻写入时间</span></span><br><span class=\"line\">  cache-snapshot-<span class=\"built_in\">write</span>-cold-duration = <span class=\"string\">&quot;30m&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#进行全量压缩时间</span></span><br><span class=\"line\">  <span class=\"comment\">#由于retention policy为72小时</span></span><br><span class=\"line\">  <span class=\"comment\">#超过72小时，可以认为不进行全量压缩</span></span><br><span class=\"line\">  compact-full-<span class=\"built_in\">write</span>-cold-duration = <span class=\"string\">&quot;80h&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#并行压缩处理器</span></span><br><span class=\"line\">  <span class=\"built_in\">max</span>-concurrent-compactions = <span class=\"number\">8</span></span><br><span class=\"line\">  <span class=\"comment\">#压缩每秒落盘数据量</span></span><br><span class=\"line\">  compact-throughput = <span class=\"string\">&quot;16m&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#压缩每秒最大落盘数据量</span></span><br><span class=\"line\">  compact-throughput-burst = <span class=\"string\">&quot;16m&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#wal日志超过128m时会被压缩为索引文件，并删除</span></span><br><span class=\"line\">  <span class=\"built_in\">max</span>-index-<span class=\"built_in\">log</span>-<span class=\"built_in\">file</span>-size = <span class=\"string\">&quot;128m&quot;</span></span><br><span class=\"line\">\\[monitor\\]</span><br><span class=\"line\">  <span class=\"comment\">#关闭监控</span></span><br><span class=\"line\">  store-enabled = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>(3) 程序启动</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numactl <span class=\"attribute\">--interleave</span>=all env <span class=\"attribute\">GODEBUG</span>=madvdontneed=1 /usr/bin/influxd  -config  /usr/bin/influxdb.conf</span><br></pre></td></tr></table></figure>\n","text":"influxdb内存消耗分析及性能优化 influxdb目前支持内存型索引inmem及文件型索引tsi1。之前追踪篇将influxd索引修改为tsi1之后，经过...","permalink":"/post/MIDDLEWARE/influxdb内存消耗分析及性能优化","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"influxdb","slug":"influxdb","count":1,"path":"api/categories/influxdb.json"},{"name":"MIDDLEWARE","slug":"influxdb/MIDDLEWARE","count":1,"path":"api/categories/influxdb/MIDDLEWARE.json"}],"tags":[{"name":"CPU","slug":"CPU","count":3,"path":"api/tags/CPU.json"},{"name":"SHR","slug":"SHR","count":1,"path":"api/tags/SHR.json"},{"name":"influxd","slug":"influxd","count":2,"path":"api/tags/influxd.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#influxdb%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%E5%88%86%E6%9E%90%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">influxdb内存消耗分析及性能优化</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"influxdb内存消耗分析及性能优化【追踪篇】","uid":"6e2f3443cc73a783063825b9fb8c089c","slug":"MIDDLEWARE/influxdb内存消耗分析及性能优化【追踪篇】","date":"2023-04-19T16:40:55.000Z","updated":"2025-12-05T01:47:41.975Z","comments":true,"path":"api/articles/MIDDLEWARE/influxdb内存消耗分析及性能优化【追踪篇】.json","keywords":"XuGuangSheng","cover":"/covers/influxdb.jpg","text":"influxdb内存消耗分析及性能优化【追踪篇】由于业务场景需求，在生产环境服务器(32core64G)搭建了基于golang开发的influx时序数据库v1....","permalink":"/post/MIDDLEWARE/influxdb内存消耗分析及性能优化【追踪篇】","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"runtime","slug":"runtime","count":1,"path":"api/categories/runtime.json"},{"name":"MIDDLEWARE","slug":"runtime/MIDDLEWARE","count":1,"path":"api/categories/runtime/MIDDLEWARE.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"使用","slug":"使用","count":5,"path":"api/tags/使用.json"},{"name":"influx","slug":"influx","count":1,"path":"api/tags/influx.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"用手写一个请求合并","uid":"b6f5eb01abd12277953691dc9b2fec2e","slug":"JAVA/用手写一个请求合并","date":"2023-04-19T15:45:48.000Z","updated":"2025-12-05T01:46:52.855Z","comments":true,"path":"api/articles/JAVA/用手写一个请求合并.json","keywords":"XuGuangSheng","cover":"/covers/e425c5f6a9af.jpg","text":"用手写一个请求合并推荐阅读： 一、服务器崩溃的思考老板说，他要做个现场营销活动，线上线下都要参与推广，这个活动参与人数可能很大哦··· 果然，由于不是我写的代码...","permalink":"/post/JAVA/用手写一个请求合并","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"https","slug":"https","count":12,"path":"api/categories/https.json"},{"name":"JAVA","slug":"https/JAVA","count":5,"path":"api/categories/https/JAVA.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"pic","slug":"pic","count":2,"path":"api/tags/pic.json"},{"name":"zhimg","slug":"zhimg","count":2,"path":"api/tags/zhimg.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}