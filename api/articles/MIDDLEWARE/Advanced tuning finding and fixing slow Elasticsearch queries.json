{"title":"Advanced tuning finding and fixing slow Elasticsearch queries","uid":"19b24bca918ce369e190f8fc79735fce","slug":"MIDDLEWARE/Advanced tuning finding and fixing slow Elasticsearch queries","date":"2022-03-29T10:28:38.000Z","updated":"2025-09-30T03:26:44.406Z","comments":true,"path":"api/articles/MIDDLEWARE/Advanced tuning finding and fixing slow Elasticsearch queries.json","keywords":"XuGuangSheng","cover":"/covers/advanced-tuning-finding-and-fixing-slow-elasticsearch-queries.jpg","content":"<h1 id=\"Advanced-tuning-finding-and-fixing-slow-Elasticsearch-queries\"><a href=\"#Advanced-tuning-finding-and-fixing-slow-Elasticsearch-queries\" class=\"headerlink\" title=\"Advanced tuning: finding and fixing slow Elasticsearch queries\"></a>Advanced tuning: finding and fixing slow Elasticsearch queries</h1><p>Elasticsearch 是一个非常灵活且功能丰富的应用程序，它提供了许多不同的数据查询方法。但是，您是否遇到过查询速度低于预期的情况？对于像 Elasticsearch 这样的分布式系统，可能会有各种影响查询性能的因素，包括负载平衡器设置、网络延迟（带宽、网卡 &#x2F; 驱动程序）等在内的各种外部因素。</p>\n<p>在本篇博文中，我将讨论导致慢查询的原因，以及如何在 Elasticsearch 的上下文中识别它们。本文主要源于一些常见的排查方法展开论述，因此，可能需要您对 ElasticSearch 的工作原理非常熟悉。</p>\n<h2 id=\"Elasticsearch-慢查询的常见原因\"><a href=\"#Elasticsearch-慢查询的常见原因\" class=\"headerlink\" title=\"Elasticsearch 慢查询的常见原因\"></a>Elasticsearch 慢查询的常见原因</h2><p>在我们研究一些更棘手的情况之前，让我们先从一些导致慢查询的最常见原因及其解决方案入手。</p>\n<h3 id=\"症状：非活动状态下资源利用率也很高\"><a href=\"#症状：非活动状态下资源利用率也很高\" class=\"headerlink\" title=\"症状：非活动状态下资源利用率也很高\"></a>症状：非活动状态下资源利用率也很高</h3><p>每个分片都消耗资源（CPU &#x2F; 内存）。即使没有索引 &#x2F; 搜索请求，分片的存在也会产生集群开销。</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>集群中的<a href=\"https://www.elastic.co/cn/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster\">分片太多</a>，以至于任何查询的执行速度看起来都很慢。一个好的经验法则是：确保对于每个节点上已配置的每个 GB <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/heap-size.html\">堆</a>，将非<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/frozen-indices.html\">冻结</a>的分片数量保持在 20 以下。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>减少分片计数，实施<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/freeze-index-api.html\">冻结索引</a>和 &#x2F; 或添加附加节点来实现负载平衡。考虑结合使用 Elasticsearch 中的<a href=\"https://www.elastic.co/cn/blog/hot-warm-architecture-in-elasticsearch-5-x\">热 &#x2F; 温架构</a>（非常适合基于时间的索引）以及<a href=\"https://www.elastic.co/cn/blog/managing-time-based-indices-efficiently\">滚动 &#x2F; 收缩功能</a>，以高效管理分片计数。要想顺利完成部署，最好先执行适当的<a href=\"https://www.elastic.co/guide/en/elasticsearch/guide/master/capacity-planning.html\">容量计划</a>，以帮助确定适合每个搜索用例的最佳分片数。</p>\n<h3 id=\"症状：线程池存在大量的-“rejected”（拒绝）\"><a href=\"#症状：线程池存在大量的-“rejected”（拒绝）\" class=\"headerlink\" title=\"症状：线程池存在大量的 “rejected”（拒绝）\"></a>症状：线程池存在大量的 “rejected”（拒绝）</h3><p>根据上次集群重新启动的累积值看，搜索线程池显示 “rejected” 计数在持续增加。</p>\n<pre><code>GET /\\_cat/thread\\_pool/search?v&amp;h\\=node\\_name,name,active,rejected,completed\n</code></pre>\n<p>响应类似如下：</p>\n<pre><code>node\\_name             name   active rejected completed\ninstance\\-0000000001 search 0  10  0 instance\\-0000000002 search 0  20  0 instance\\-0000000003 search 0  30  0\n</code></pre>\n<h4 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>查询面向的分片太多，超过了集群中的核心数。这会在搜索线程池中造成排队任务，从而导致搜索拒绝。另一个常见原因是磁盘 I&#x2F;O 速度慢，导致搜索排队或在某些情况下 CPU 完全饱和。 </p>\n<h4 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>创建索引时采用 <em>1 个主分片: 1 个副本分片</em> (1P:1R) 模型。使用<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/indices-templates.html\">索引模板</a>是一个在创建索引时部署此设置的好方法。（Elasticsearch 7.0 或更高版本将默认 1P:1R）。Elasticsearch 5.1 或更高版本支持<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search.html#global-search-cancellation\">搜索任务取消</a>，这对于取消<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tasks.html\">任务管理 API</a> 中出现的慢查询任务非常有用。若要改进磁盘 I&#x2F;O，请查看<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-indexing-speed.html#_use_faster_hardware\">存储建议</a>，并确保使用推荐的硬件以获得最佳性能。</p>\n<h3 id=\"症状：高-CPU-使用率和索引延迟\"><a href=\"#症状：高-CPU-使用率和索引延迟\" class=\"headerlink\" title=\"症状：高 CPU 使用率和索引延迟\"></a>症状：高 CPU 使用率和索引延迟</h3><p><a href=\"https://www.elastic.co/guide/en/kibana/7.0/elasticsearch-metrics.html\">指标</a>相关性表明，当集群不堪重负时，CPU 使用率和索引延迟都会很高。</p>\n<h4 id=\"问题-2\"><a href=\"#问题-2\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>集群索引量大会影响搜索性能。</p>\n<h4 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>将 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/index-modules.html#dynamic-index-settings\">index.refresh_ interval</a> 的值（从文档被索引到其变为可见的时间间隔）增加到 30 秒，通常有助于提高索引性能。实际业务情境中可能会有所不同，因此测试是关键。这可以确保分片不必因为每 1 秒默认创建一个新分段而造成工作负载增大。</p>\n<p>对于索引量大的用例，请查看<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-indexing-speed.html#_disable_refresh_and_replicas_for_initial_loads\">索引调优建议</a>，以优化索引和搜索性能。</p>\n<h3 id=\"症状：副本分片增加后延迟增大\"><a href=\"#症状：副本分片增加后延迟增大\" class=\"headerlink\" title=\"症状：副本分片增加后延迟增大\"></a>症状：副本分片增加后延迟增大</h3><p>在副本分片计数增加（例如，从 1 增加到 2）后，可以观察到查询延迟。如果存在较多的数据，那么缓存的数据将很快被逐出，从而导致操作系统页面错误增加。</p>\n<h4 id=\"问题-3\"><a href=\"#问题-3\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>文件系统缓存没有足够的内存来缓存索引中经常查询的部分。Elasticsearch 的 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/query-cache.html\">查询缓存</a>实现了 LRU 逐出策略：当缓存变满时，将逐出最近使用最少的数据，以便为新数据让路。</p>\n<h4 id=\"解决方案-3\"><a href=\"#解决方案-3\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>为文件系统缓存留出<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-indexing-speed.html#_give_memory_to_the_filesystem_cache\">至少 50% 的物理 RAM</a>。内存越多，缓存的空间就越大，尤其是当集群遇到 I&#x2F;O 问题时。 假设<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/heap-size.html\">堆大小</a>已正确配置，任何剩余的可用于文件系统缓存的物理 RAM 都会大大提高搜索性能。</p>\n<p>例如，128GB 的 RAM 服务器留出 30GB 的内存用于堆，剩余内存用于文件系统缓存（有时称为 OS 缓存），假设操作系统缓存了最近访问的 4KB 数据块，这样，如果您一次又一次地读取相同的文件，那么您不必花很长时间到磁盘上读，而是会从内存中直接读取。</p>\n<p>除了文件系统缓存，Elasticsearch 还使用<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-search-speed.html#preference-cache-optimization\">查询缓存和请求缓存</a><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-search-speed.html#_use_literal_preference_literal_to_optimize_cache_utilization\"></a>来提高搜索速度。 所有这些缓存都可以使用<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search-request-preference.html\">搜索请求首选项</a>进行优化，以便每次都将某些搜索请求路由到同一组分片，而不是在不同的可用副本之间进行交替。这将更好地利用请求缓存、节点查询缓存和文件系统缓存。</p>\n<h3 id=\"症状：共享资源时利用率高\"><a href=\"#症状：共享资源时利用率高\" class=\"headerlink\" title=\"症状：共享资源时利用率高\"></a>症状：共享资源时利用率高</h3><p>操作系统显示出持续的高 CPU &#x2F; 磁盘 I&#x2F;O 利用率。停止第三方应用程序后，可以看到性能会提高。</p>\n<h4 id=\"问题-4\"><a href=\"#问题-4\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>其他进程（例如 Logstash）和 Elasticsearch 本身之间存在资源（CPU 和 &#x2F; 或磁盘 I&#x2F;O）争用。</p>\n<h4 id=\"解决方案-4\"><a href=\"#解决方案-4\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>避免在共享硬件上与其他资源密集型应用程序一起运行 ElasticSearch。</p>\n<h3 id=\"症状：聚合多个高度唯一字段时堆利用率高\"><a href=\"#症状：聚合多个高度唯一字段时堆利用率高\" class=\"headerlink\" title=\"症状：聚合多个高度唯一字段时堆利用率高\"></a>症状：聚合多个高度唯一字段时堆利用率高</h3><p>当查询包含高度唯一值（如 ID、用户名、电子邮件地址等）的聚合字段时，性能不佳。在堆转储分析期间发现：使用 “search”、“buckets”、“aggregation” 等术语的 Java 对象消耗了大量的堆空间。</p>\n<h4 id=\"问题-5\"><a href=\"#问题-5\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>聚合在<a href=\"https://en.wikipedia.org/wiki/Cardinality_(SQL_statements)\">高基数</a>字段上运行，需要大量资源来提取许多存储桶。 此外，还可能存在涉及嵌套字段和 &#x2F; 或联接字段的嵌套聚合。</p>\n<h4 id=\"解决方案-5\"><a href=\"#解决方案-5\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>若要改进高基数术语聚合的性能，请阅读我的咨询团队同事的这篇博文：<a href=\"https://www.elastic.co/cn/blog/improving-the-performance-of-high-cardinality-terms-aggregations-in-elasticsearch\">https://www.elastic.co/cn/blog/improving-the-performance-of-high-cardinality-terms-aggregations-in-elasticsearch</a></p>\n<p>有关进一步的调整，请查看我们关于<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/nested.html#_limiting_the_number_of_literal_nested_literal_fields\">嵌套字段</a>和<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/parent-join.html#_parent_join_and_performance\">联接字段</a>的建议，以更好地提高聚合性能。</p>\n<h2 id=\"偶发慢查询\"><a href=\"#偶发慢查询\" class=\"headerlink\" title=\"偶发慢查询\"></a>偶发慢查询</h2><p>一般来说，可以采用一些<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-indexing-speed.html\">索引调优</a>&#x2F;<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-search-speed.html\">搜索调优</a>建议来解决偶尔或间歇出现的慢查询问题。偶发的慢查询应该与这些<a href=\"https://www.elastic.co/guide/en/kibana/7.0/elasticsearch-metrics.html\">监测指标</a>中的一个或多个密切相关：</p>\n<ul>\n<li>CPU 负载</li>\n<li>索引吞吐量</li>\n<li>搜索吞吐量</li>\n<li>垃圾收集 (GC) 活动</li>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/cat-thread-pool.html#cat-thread-pool\">搜索线程池队列大小</a></li>\n</ul>\n<p>Elasticsearch 还有另一个有用的功能，称为<a href=\"https://www.elastic.co/cn/blog/improving-response-latency-in-elasticsearch-with-adaptive-replica-selection\">自适应副本选择 (ARS)</a>，它允许<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/modules-node.html#coordinating-node\">协调节点</a>了解数据节点上的负载，并允许它选择最佳分片副本来执行搜索，从而提高搜索吞吐量并降低延迟。通过在查询期间更均匀地分配负载，ARS 对于偶发的减速有很大帮助。在 Elasticsearch 7.0 及更高版本中，默认情况下将启用 ARS。</p>\n<h2 id=\"持续性慢查询\"><a href=\"#持续性慢查询\" class=\"headerlink\" title=\"持续性慢查询\"></a>持续性慢查询</h2><p>对于持续性的慢查询，我们可以尝试逐个删除查询中的功能，并检查查询是否仍然慢。查找最简单查询以再现性能问题，有助于隔离和识别问题：</p>\n<ul>\n<li>没有<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search-request-highlighting.html\">高亮显示</a>，它是否仍然很慢？</li>\n<li>没有聚合，它是否仍然很慢？</li>\n<li>如果<code>大小</code>设为 0，它是否仍然慢？（当<code>大小</code>设为 0 时，Elasticsearch 会<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/shard-request-cache.html#shard-request-cache\">缓存</a>搜索请求的结果，以便更快地进行搜索）</li>\n</ul>\n<p>一些<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/tune-for-search-speed.html\">“搜索调优” 的建议</a>是否有用？</p>\n<p>在故障排除期间，执行以下操作通常很有用：</p>\n<ul>\n<li>在启用<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search-profile.html\">配置文件</a>的情况下，获取查询响应。</li>\n<li>通过在 while(true) 循环中运行的查询，收集<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/cluster-nodes-hot-threads.html\">节点的热点线程</a>输出。这有助于了解 CPU 时间的使用情况。</li>\n<li>使用这个<a href=\"https://www.elastic.co/guide/en/kibana/7.0/xpack-profiler.html\">用户友好版本</a>的配置文件 API 来配置查询。</li>\n</ul>\n<p>如果查询来自 Kibana 可视化，则使用<a href=\"https://www.elastic.co/guide/en/kibana/6.3/vis-spy.html\">可视化侦查面板</a>（Kibana 版本 6.3 及更高版本）或<a href=\"https://www.elastic.co/guide/en/kibana/6.4/viewing-detailed-information.html\">仪表板检查面板</a>（Kibana 版本 6.4 及更高版本）来查看并导出实际的查询请求，并将其导入到配置文件 API 中以做进一步分析。</p>\n<h2 id=\"捕获慢查询或耗费资源的查询\"><a href=\"#捕获慢查询或耗费资源的查询\" class=\"headerlink\" title=\"捕获慢查询或耗费资源的查询\"></a>捕获慢查询或耗费资源的查询</h2><p>有时，在像 Elasticsearch 这样的分布式应用程序中，当同时处理不同的请求 &#x2F; 线程时，很难捕获慢查询或耗费资源的查询。如果对运行耗费资源查询的用户不加以控制，情况就会变得愈加复杂，这些查询会降低集群性能（例如，较长的垃圾收集 (GC) 周期），甚至更糟糕地会出现内存不足 (OOM) 的情况。</p>\n<p>在 Elasticsearch version 7.0 中，我们引入了一种<a href=\"https://github.com/elastic/elasticsearch/pull/31767\">新的内容熔断策略</a>，用于在保留内存时测量实际堆内存的使用情况。这个新策略可<a href=\"https://www.elastic.co/cn/blog/improving-node-resiliency-with-the-real-memory-circuit-breaker\">提高节点对耗费资源的查询导致集群过载的弹性支持</a>，并且在默认情况下处于启用状态，并可使用新的集群设置 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/circuit-breaker.html#parent-circuit-breaker\">indices.breaker.total.use_real_memory</a> 对其进行控制。</p>\n<p>但是，我们应该注意，这些都是尽力而为；对于以上内容未涉及的情况，最好<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/heap-dump-path.html\">在 OOM 崩溃后收集堆转储</a>，或<a href=\"https://discuss.elastic.co/t/how-to-capture-a-heap-dump-from-a-running-jvm/84\">从运行的 JVM 中收集堆转储</a>，以更好地了解根本原因。</p>\n<p>Elasticsearch 还有另一个保护设置（<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search-aggregations-bucket.html#\">最大存储桶软限制</a>），用于防止集群出现 OOM。当超过存储桶数量（在 7.0 版中默认为 10,000）时（例如，当运行多层聚合时），此最大存储桶聚合设置将停止执行并使搜索请求失败。</p>\n<p>为了进一步识别潜在的耗费资源查询，我们可以设置断路器设置 (<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/circuit-breaker.html#request-circuit-breaker\">indices.breaker.request.limit</a>)，从一个低阈值开始隔离查询，并逐渐向上移动阈值，以将范围缩小到特定的查询。</p>\n<h3 id=\"slowlogs\"><a href=\"#slowlogs\" class=\"headerlink\" title=\"slowlogs\"></a>slowlogs</h3><p>此外，还可以通过在 Elasticsearch 中启用 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/index-modules-slowlog.html\">slowlogs</a> 来识别运行缓慢的查询。slowlogs 专门用于分片级别，这意味着仅适用于<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/modules-node.html#data-node\">数据节点</a>。<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/modules-node.html#coordinating-only-node\">仅协调 &#x2F; 客户端节点</a>不具备慢日志分析功能，因为它们不保存数据（索引 &#x2F; 分片）。</p>\n<p>slowlogs 有助于回答如下问题：</p>\n<ul>\n<li>查询花费了多长时间？</li>\n<li>查询请求正文的内容是什么？</li>\n</ul>\n<p>slowlog 输出示例：</p>\n<pre><code>\\[2019\\-02\\-11T16:47:39,882\\]\\[TRACE\\]\\[index.search.slowlog.query\\]  \\[2g1yKIZ\\]  \\[logstash\\-20190211\\]\\[4\\] took\\[10.4s\\], took\\_millis\\[10459\\], total\\_hits\\[16160\\], types\\[\\], stats\\[\\], search\\_type\\[QUERY\\_THEN\\_FETCH\\], total\\_shards\\[10\\], source\\[&#123;&quot;size&quot;:0,&quot;query&quot;:&#123;&quot;bool&quot;:&#123;&quot;must&quot;:\\[&#123;&quot;range&quot;:&#123;&quot;timestamp&quot;:&#123;&quot;from&quot;:1549266459837,&quot;to&quot;:1549871259837,&quot;include\\_lower&quot;:true,  &quot;include\\_upper&quot;:true,&quot;format&quot;:&quot;epoch\\_millis&quot;,&quot;boost&quot;:1.0&#125;&#125;&#125;\\],&quot;adjust\\_pure\\_negative&quot;:true,&quot;boost&quot;:1.0&#125;&#125;,&quot;\\_source&quot;:&#123;&quot;includes&quot;:\\[\\],&quot;excludes&quot;:\\[\\]&#125;,&quot;stored\\_fields&quot;:&quot;\\*&quot;,&quot;docvalue\\_fields&quot;:  \\[&#123;&quot;field&quot;:&quot;timestamp&quot;,&quot;format&quot;:&quot;date\\_time&quot;&#125;,&#123;&quot;field&quot;:&quot;utc\\_time&quot;,&quot;format&quot;:&quot;date\\_time&quot;&#125;\\],&quot;script\\_fields&quot;:&#123;&quot;hour\\_of\\_day&quot;:&#123;&quot;script&quot;:&#123;&quot;source&quot;:&quot;doc\\[&#39;timestamp&#39;\\].value.getHourOfDay()&quot;,  &quot;lang&quot;:&quot;painless&quot;&#125;,&quot;ignore\\_failure&quot;:false&#125;&#125;,&quot;aggregations&quot;:&#123;&quot;maxAgg&quot;:&#123;&quot;max&quot;:&#123;&quot;field&quot;:&quot;bytes&quot;&#125;&#125;,&quot;minAgg&quot;:&#123;&quot;min&quot;:&#123;&quot;field&quot;:&quot;bytes&quot;&#125;&#125;&#125;&#125;\\], id\\[\\]\\],\n</code></pre>\n<p>slowlog 消息拆解：</p>\n<p>| <strong>拆分项</strong> | <strong>说明</strong> |<br>| <code>[2019-02-11T16:47:39,882]</code> | 查询日期 |<br>| <code>[TRACE]</code> | 日志级别 |<br>| <code>[index.search.slowlog.query]</code> | 搜索 slowlog 的查询阶段 |<br>| <code>[2g1yKIZ]</code> | 节点名称 |<br>| <code>[logstash-20190211]</code> | 索引名称 |<br>| <code>[4]</code> | 查询执行的分片序号 |<br>| <code>took[10.4s]</code> | 在分片 [4] 上花费的处理时间。注意：在查看 slowlog 时，我们需要避免将来自不同分片的所有时间相加，因为每个分片可能并行执行。 |<br>| <code>took_millis[10459]</code> | 花费的时间（毫秒） |<br>| <code>total_hits[16160]</code> | 总命中数 |<br>| <code>search_type[QUERY_THEN_FETCH]</code> | <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/search-request-search-type.html\">搜索类型</a> |<br>| <code>total_shards[10]</code> | 索引的总分片数 |<br>| <code>source[]</code> | 执行的查询正文 |</p>\n<h3 id=\"审计日志\"><a href=\"#审计日志\" class=\"headerlink\" title=\"审计日志\"></a>审计日志</h3><p>黄金级或白金级<a href=\"https://www.elastic.co/cn/subscriptions\">订阅</a>的客户（包括 <a href=\"https://www.elastic.co/cn/what-is/elastic-stack-security\">Elastic 安全功能</a>），可以启用<a href=\"https://www.elastic.co/guide/en/elastic-stack-overview/7.0/auditing.html\">审计日志</a>来捕获有关查询的更多详细信息。（用户可以开始为期 <a href=\"https://www.elastic.co/guide/en/kibana/7.0/managing-licenses.html\">30 天的试用</a>来测试 Elastic 安全功能。） 审计日志有助于回答以下问题：</p>\n<ul>\n<li>查询是何时发生的？</li>\n<li>谁执行了查询？</li>\n<li>查询的内容是什么？</li>\n</ul>\n<p>由于默认的审计设置相当繁琐，我们需要调整设置：</p>\n<ol>\n<li><strong>启用安全审计日志：</strong>  在 elasticsearch.yml 中设置 <code>xpack.security.audit.enabled: true</code>。</li>\n<li><strong>在安全审计输出中启用日志或索引：</strong>  在 elasticsearch.yml 中设置 <code>xpack.security.audit.outputs:[logfile, index]</code>。<br><strong>备注：</strong> <ul>\n<li>xpack.security.audit.outputs 设置仅适用于版本 6.0-6.2 和 5.x。版本 7.0 不再接受此设置，并且当 xpack.security.audit.enabled 设置为 true 时，<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/auditing-settings.html#general-audit-settings\">默认为 json 输出</a> (<clustername>_audit.json)。</li>\n<li>出于排除故障的目的，我们建议选择 logfile 而不是索引，因为审计日志的冗长可能会对安全索引超出其预期大小的集群性能造成不必要的压力。</li>\n<li>审计模式可能非常冗长，因此，请在完成故障排除后将其关闭。</li>\n</ul>\n</li>\n<li><strong>在事件列表中包含 authentication_success 访问：</strong>  在 elasticsearch.yml 中设置 <code>xpack.security.audit.logfile.events.include: authentication_success</code>。<br><strong>备注：</strong> <ul>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/auditing-settings.html#event-audit-settings\">默认事件</a>中不包括此设置。此设置会覆盖默认设置。</li>\n<li>如果需要再添加一个事件（而不是替换），请先写入现有的默认事件列表，然后在最后一个条目后添加上述设置。</li>\n<li><strong>在审计事件中输出请求正文：</strong>  在 elasticsearch.yml 中设置 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.0/auditing-settings.html#event-audit-settings\"><code>xpack.security.audit.logfile.events.emit_request_body: true</code></a>。</li>\n</ul>\n</li>\n</ol>\n<p>借助这些设置，您就可以像下面这样监测用户查询。</p>\n<ul>\n<li>_用户：_louisong</li>\n<li><em>查询时间：</em> 2019-05-01T19:26:53,554 (UTC)</li>\n<li><em>查询端点：</em>_msearch（通常表示它是从 Kibana 可视化 &#x2F; 仪表板发出的查询）</li>\n<li>_查询主体：_从以下日志中的 <code>&quot;request.body&quot;:</code> 开始：```<br>{“@timestamp”:”2019-05-01T19:26:53,554”,  “node.id”:”Z1z_64sIRcy4dW2eqyqzMw”,”event.type”:”rest”,”event.action”:”authentication_success”,”user.name”:”louisong”,”origin.type”:”rest”,”origin.address”:”127.0.0.1:51426”,”realm”:”default_native”,”url.path”:”&#x2F;_msearch”,”url.query”:”rest_total_hits_as_int&#x3D;true&amp;ignore_throttled&#x3D;true”,”request.method”:”POST”,”request.body”:”{\\“index\\“:\\“*\\“,\\“ignore_unavailable\\“:true,\\“preference\\“:1556709820160}\\n{\\“aggs\\“:{\\“2\\“:{\\“terms\\“:{\\“field\\“:\\“actions\\“,\\“size\\“:5,\\“order\\“:{\\“_count\\“:\\“desc\\“},\\“missing\\“:\\“__missing__\\“}}},\\“size\\“:0,\\“_source\\“:{\\“excludes\\“:[]},\\“stored_fields\\“:[\\“*\\“],\\“script_fields\\“:{},\\“docvalue_fields\\“:[{\\“field\\“:\\“access_token.user_token.expiration_time\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“canvas-workpad.@created\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“canvas-workpad.@timestamp\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“creation_time\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“expiration_time\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“maps-telemetry.timeCaptured\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“task.runAt\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“task.scheduledAt\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“updated_at\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“url.accessDate\\“,\\“format\\“:\\“date_time\\“},{\\“field\\“:\\“url.createDate\\“,\\“format\\“:\\“date_time\\“}],\\“query\\“:{\\“bool\\“:{\\“must\\“:[{\\“range\\“:{\\“canvas-workpad.@timestamp\\“:{\\“format\\“:\\“strict_date_optional_time\\“,\\“gte\\“:\\“2019-05-01T11:11:53.498Z\\“,\\“lte\\“:\\“2019-05-01T11:26:53.498Z\\“}}}],\\“filter\\“:[{\\“match_all\\“:{}},{\\“match_all\\“:{}}],\\“should\\“:[],\\“must_not\\“:[]}},\\“timeout\\“:\\“30000ms\\“}\\n”,”request.id”:”qrktsPxyST2nVh29GG7tog”}  <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>在本文中，我们讨论了慢查询的常见原因以及相应的解决方案。我们还讨论了识别持续性慢查询和偶发慢查询的不同方法。通常会将慢查询视为需要解决的更广泛集群性能问题的典型症状。<br> <a href=\"https://www.elastic.co/cn/blog/advanced-tuning-finding-and-fixing-slow-elasticsearch-queries\">https://www.elastic.co/cn/blog/advanced-tuning-finding-and-fixing-slow-elasticsearch-queries</a></p>\n","text":"Advanced tuning: finding and fixing slow Elasticsearch queriesElasticsearch 是一个非...","permalink":"/post/MIDDLEWARE/Advanced tuning finding and fixing slow Elasticsearch queries","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"elastic","slug":"elastic","count":1,"path":"api/categories/elastic.json"},{"name":"MIDDLEWARE","slug":"elastic/MIDDLEWARE","count":1,"path":"api/categories/elastic/MIDDLEWARE.json"}],"tags":[{"name":"https","slug":"https","count":44,"path":"api/tags/https.json"},{"name":"www","slug":"www","count":8,"path":"api/tags/www.json"},{"name":"elasticsearch","slug":"elasticsearch","count":1,"path":"api/tags/elasticsearch.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Advanced-tuning-finding-and-fixing-slow-Elasticsearch-queries\"><span class=\"toc-text\">Advanced tuning: finding and fixing slow Elasticsearch queries</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Elasticsearch-%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">Elasticsearch 慢查询的常见原因</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%97%87%E7%8A%B6%EF%BC%9A%E9%9D%9E%E6%B4%BB%E5%8A%A8%E7%8A%B6%E6%80%81%E4%B8%8B%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87%E4%B9%9F%E5%BE%88%E9%AB%98\"><span class=\"toc-text\">症状：非活动状态下资源利用率也很高</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%97%87%E7%8A%B6%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%98%E5%9C%A8%E5%A4%A7%E9%87%8F%E7%9A%84-%E2%80%9Crejected%E2%80%9D%EF%BC%88%E6%8B%92%E7%BB%9D%EF%BC%89\"><span class=\"toc-text\">症状：线程池存在大量的 “rejected”（拒绝）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98-1\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1\"><span class=\"toc-text\">解决方案</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%97%87%E7%8A%B6%EF%BC%9A%E9%AB%98-CPU-%E4%BD%BF%E7%94%A8%E7%8E%87%E5%92%8C%E7%B4%A2%E5%BC%95%E5%BB%B6%E8%BF%9F\"><span class=\"toc-text\">症状：高 CPU 使用率和索引延迟</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98-2\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2\"><span class=\"toc-text\">解决方案</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%97%87%E7%8A%B6%EF%BC%9A%E5%89%AF%E6%9C%AC%E5%88%86%E7%89%87%E5%A2%9E%E5%8A%A0%E5%90%8E%E5%BB%B6%E8%BF%9F%E5%A2%9E%E5%A4%A7\"><span class=\"toc-text\">症状：副本分片增加后延迟增大</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98-3\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3\"><span class=\"toc-text\">解决方案</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%97%87%E7%8A%B6%EF%BC%9A%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E6%97%B6%E5%88%A9%E7%94%A8%E7%8E%87%E9%AB%98\"><span class=\"toc-text\">症状：共享资源时利用率高</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98-4\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-4\"><span class=\"toc-text\">解决方案</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%97%87%E7%8A%B6%EF%BC%9A%E8%81%9A%E5%90%88%E5%A4%9A%E4%B8%AA%E9%AB%98%E5%BA%A6%E5%94%AF%E4%B8%80%E5%AD%97%E6%AE%B5%E6%97%B6%E5%A0%86%E5%88%A9%E7%94%A8%E7%8E%87%E9%AB%98\"><span class=\"toc-text\">症状：聚合多个高度唯一字段时堆利用率高</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98-5\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-5\"><span class=\"toc-text\">解决方案</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%81%B6%E5%8F%91%E6%85%A2%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">偶发慢查询</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8C%81%E7%BB%AD%E6%80%A7%E6%85%A2%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">持续性慢查询</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8D%95%E8%8E%B7%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%88%96%E8%80%97%E8%B4%B9%E8%B5%84%E6%BA%90%E7%9A%84%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">捕获慢查询或耗费资源的查询</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#slowlogs\"><span class=\"toc-text\">slowlogs</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">审计日志</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">结论</span></a></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Linux PageCache详解","uid":"5d405dae2a57ea9119868cf9afedbd64","slug":"LINUX/Linux PageCache详解","date":"2022-04-12T14:38:01.000Z","updated":"2025-09-30T03:26:31.266Z","comments":true,"path":"api/articles/LINUX/Linux PageCache详解.json","keywords":"XuGuangSheng","cover":"/covers/linux-pagecache.jpg","text":"Linux PageCache详解应用程序要存储或访问数据时，只需读或者写” 文件” 的一维地址空间即可，而这个地址空间与存储设备上存储块之间的对应关系则由操作...","permalink":"/post/LINUX/Linux PageCache详解","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"proc","slug":"proc","count":2,"path":"api/categories/proc.json"},{"name":"LINUX","slug":"proc/LINUX","count":2,"path":"api/categories/proc/LINUX.json"}],"tags":[{"name":"Cache","slug":"Cache","count":2,"path":"api/tags/Cache.json"},{"name":"cache","slug":"cache","count":2,"path":"api/tags/cache.json"},{"name":"page","slug":"page","count":1,"path":"api/tags/page.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Homeassistant - 使用小爱音箱控制 Hass 设备","uid":"0ba37cbc11858729ececbe4090fe5335","slug":"OTHER/Homeassistant - 使用小爱音箱控制 Hass 设备","date":"2022-03-28T20:30:27.000Z","updated":"2025-09-30T03:27:01.150Z","comments":true,"path":"api/articles/OTHER/Homeassistant - 使用小爱音箱控制 Hass 设备.json","keywords":"XuGuangSheng","cover":"/covers/homeassistant-hass.jpg","text":"Homeassistant - 使用小爱音箱控制 Hass 设备使用小爱音箱 + 小爱开放平台技能开发 + NodeRed 控制 Homeassistant 的...","permalink":"/post/OTHER/Homeassistant - 使用小爱音箱控制 Hass 设备","photos":[],"count_time":{"symbolsCount":987,"symbolsTime":"1 mins."},"categories":[{"name":"https","slug":"https","count":12,"path":"api/categories/https.json"},{"name":"OTHER","slug":"https/OTHER","count":2,"path":"api/categories/https/OTHER.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"NodeRed","slug":"NodeRed","count":1,"path":"api/tags/NodeRed.json"},{"name":"state","slug":"state","count":1,"path":"api/tags/state.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}