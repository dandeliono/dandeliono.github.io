{"title":"MySql Lock wait timeout exceeded","uid":"56ab2e24b6f8563e1b3aef14738d978d","slug":"MIDDLEWARE/MySql Lock wait timeout exceeded","date":"2023-05-17T15:04:27.000Z","updated":"2025-12-05T01:47:31.654Z","comments":true,"path":"api/articles/MIDDLEWARE/MySql Lock wait timeout exceeded.json","keywords":"XuGuangSheng","cover":"/covers/mysql-lock-wait-timeout-exceeded.jpg","content":"<h1 id=\"MySql-Lock-wait-timeout-exceeded\"><a href=\"#MySql-Lock-wait-timeout-exceeded\" class=\"headerlink\" title=\"MySql Lock wait timeout exceeded\"></a>MySql Lock wait timeout exceeded</h1><p>Mysql造成锁的情况有很多，下面我们就列举一些情况：</p>\n<ol>\n<li>执行DML操作没有commit，再执行删除操作就会锁表。</li>\n<li>在同一事务内先后对同一条数据进行插入和更新操作。</li>\n<li>表索引设计不当，导致数据库出现死锁。</li>\n<li>长事物，阻塞DDL，继而阻塞所有同表的后续操作。</li>\n</ol>\n<p>但是要区分的是<code>Lock wait timeout exceeded</code>与<code>Dead Lock</code>是不一样。</p>\n<ul>\n<li><code>Lock wait timeout exceeded</code>：后提交的事务等待前面处理的事务释放锁，但是在等待的时候超过了mysql的锁等待时间，就会引发这个异常。</li>\n<li><code>Dead Lock</code>：两个事务互相等待对方释放相同资源的锁，从而造成的死循环，就会引发这个异常。</li>\n</ul>\n<p>还有一个要注意的是<code>innodb_lock_wait_timeout</code>与<code>lock_wait_timeout</code>也是不一样的。</p>\n<ul>\n<li><code>innodb_lock_wait_timeout</code>：innodb的dml操作的行级锁的等待时间</li>\n<li><code>lock_wait_timeout</code>：数据结构ddl操作的锁的等待时间</li>\n</ul>\n<p>如何查看innodb_lock_wait_timeout的具体值？</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> VARIABLES <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;innodb_lock_wait_timeout&#x27;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如何修改innode lock wait timeout的值？</p>\n<p>参数修改的范围有Session和Global，并且支持动态修改，可以有两种方法修改：</p>\n<p>方法一：</p>\n<p>通过下面语句修改</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> innodb_lock_wait_timeout<span class=\"operator\">=</span><span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> innodb_lock_wait_timeout<span class=\"operator\">=</span><span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><em>ps. 注意global的修改对当前线程是不生效的，只有建立新的连接才生效。</em></p>\n<p>方法二：</p>\n<p>修改参数文件<code>/etc/my.cnf</code> <code>innodb_lock_wait_timeout = 50</code></p>\n<p><em>ps. <code>innodb_lock_wait_timeout</code>指的是事务等待获取资源等待的最长时间，超过这个时间还未分配到资源则会返回应用失败； 当锁等待超过设置时间的时候，就会报如下的错误；<code>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</code>。其参数的时间单位是秒，最小可设置为1s(一般不会设置得这么小)，最大可设置1073741824秒，默认安装时这个值是50s(默认参数设置)。</em></p>\n<p>下面介绍在遇到这类问题该如何处理</p>\n<ul>\n<li><p>数据更新或新增后数据经常自动回滚。</p>\n</li>\n<li><p>表操作总报 <code>Lock wait timeout exceeded</code> 并长时间无反应</p>\n</li>\n<li><p>应急方法：<code>show full processlist;</code> <code>kill</code>掉出现问题的进程。 <em>ps.有的时候通过processlist是看不出哪里有锁等待的，当两个事务都在commit阶段是无法体现在processlist上</em></p>\n</li>\n<li><p>根治方法：<code>select * from innodb_trx;</code>查看有是哪些事务占据了表资源。 <em>ps.通过这个办法就需要对innodb有一些了解才好处理</em></p>\n</li>\n</ul>\n<p>说起来很简单找到它杀掉它就搞定了，但是实际上并没有想象的这么简单，当问题出现要分析问题的原因，通过原因定位业务代码可能某些地方实现的有问题，从而来避免今后遇到同样的问题。</p>\n<p><code>Mysql</code>的<code>InnoDB</code>存储引擎是支持事务的，事务开启后没有被主动<code>Commit</code>。导致该资源被长期占用，其他事务在抢占该资源时，因上一个事务的锁而导致抢占失败！因此出现 <code>Lock wait timeout exceeded</code></p>\n<p>下面几张表是innodb的事务和锁的信息表，理解这些表就能很好的定位问题。</p>\n<p><code>innodb_trx</code> ## 当前运行的所有事务 <code>innodb_locks</code> ## 当前出现的锁 <code>innodb_lock_waits</code> ## 锁等待的对应关系</p>\n<p>下面对 <code>innodb_trx</code> 表的每个字段进行解释：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trx_id：事务ID。</span><br><span class=\"line\">trx_state：事务状态，有以下几种状态：<span class=\"keyword\">RUNNING</span>、LOCK WAIT、ROLLING BACK 和 COMMITTING。</span><br><span class=\"line\">trx_started：事务开始时间。</span><br><span class=\"line\">trx_requested_lock_id：事务当前正在等待锁的标识，可以和 INNODB_LOCKS 表 <span class=\"keyword\">JOIN</span> 以得到更多详细信息。</span><br><span class=\"line\">trx_wait_started：事务开始等待的时间。</span><br><span class=\"line\">trx_weight：事务的权重。</span><br><span class=\"line\">trx_mysql_thread_id：事务线程 ID，可以和 PROCESSLIST 表 <span class=\"keyword\">JOIN</span>。</span><br><span class=\"line\">trx_query：事务正在执行的 <span class=\"keyword\">SQL</span> 语句。</span><br><span class=\"line\">trx_operation_state：事务当前操作状态。</span><br><span class=\"line\">trx_tables_in_use：当前事务执行的 <span class=\"keyword\">SQL</span> 中使用的表的个数。</span><br><span class=\"line\">trx_tables_locked：当前执行 <span class=\"keyword\">SQL</span> 的行锁数量。</span><br><span class=\"line\">trx_lock_structs：事务保留的锁数量。</span><br><span class=\"line\">trx_lock_memory_bytes：事务锁住的内存大小，单位为 BYTES。</span><br><span class=\"line\">trx_rows_locked：事务锁住的记录数。包含标记为 DELETED，并且已经保存到磁盘但对事务不可见的行。</span><br><span class=\"line\">trx_rows_modified：事务更改的行数。</span><br><span class=\"line\">trx_concurrency_tickets：事务并发票数。</span><br><span class=\"line\">trx_isolation_level：当前事务的隔离级别。</span><br><span class=\"line\">trx_unique_checks：是否打开唯一性检查的标识。</span><br><span class=\"line\">trx_foreign_key_checks：是否打开外键检查的标识。</span><br><span class=\"line\">trx_last_foreign_key_error：最后一次的外键错误信息。</span><br><span class=\"line\">trx_adaptive_hash_latched：自适应散列索引是否被当前事务锁住的标识。</span><br><span class=\"line\">trx_adaptive_hash_timeout：是否立刻放弃为自适应散列索引搜索 LATCH 的标识。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>下面对 <code>innodb_locks</code> 表的每个字段进行解释：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock_id：锁 ID。</span><br><span class=\"line\">lock_trx_id：拥有锁的事务 ID。可以和 INNODB_TRX 表 <span class=\"keyword\">JOIN</span> 得到事务的详细信息。</span><br><span class=\"line\">lock_mode：锁的模式。有如下锁类型：行级锁包括：S、X、<span class=\"keyword\">IS</span>、IX，分别代表：共享锁、排它锁、意向共享锁、意向排它锁。表级锁包括：S_GAP、X_GAP、IS_GAP、IX_GAP 和 AUTO_INC，分别代表共享间隙锁、排它间隙锁、意向共享间隙锁、意向排它间隙锁和自动递增锁。</span><br><span class=\"line\">lock_type：锁的类型。RECORD 代表行级锁，<span class=\"keyword\">TABLE</span> 代表表级锁。</span><br><span class=\"line\">lock_table：被锁定的或者包含锁定记录的表的名称。</span><br><span class=\"line\">lock_index：当 LOCK_TYPE<span class=\"operator\">=</span>’RECORD’ 时，表示索引的名称；否则为 <span class=\"keyword\">NULL</span>。</span><br><span class=\"line\">lock_space：当 LOCK_TYPE<span class=\"operator\">=</span>’RECORD’ 时，表示锁定行的表空间 ID；否则为 <span class=\"keyword\">NULL</span>。</span><br><span class=\"line\">lock_page：当 LOCK_TYPE<span class=\"operator\">=</span>’RECORD’ 时，表示锁定行的页号；否则为 <span class=\"keyword\">NULL</span>。</span><br><span class=\"line\">lock_rec：当 LOCK_TYPE<span class=\"operator\">=</span>’RECORD’ 时，表示一堆页面中锁定行的数量，亦即被锁定的记录号；否则为 <span class=\"keyword\">NULL</span>。</span><br><span class=\"line\">lock_data：当 LOCK_TYPE<span class=\"operator\">=</span>’RECORD’ 时，表示锁定行的主键；否则为<span class=\"keyword\">NULL</span>。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>下面对 innodb_lock_waits 表的每个字段进行解释：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requesting_trx_id：请求事务的 ID。</span><br><span class=\"line\">requested_lock_id：事务所等待的锁定的 ID。可以和 INNODB_LOCKS 表 <span class=\"keyword\">JOIN</span>。</span><br><span class=\"line\">blocking_trx_id：阻塞事务的 ID。</span><br><span class=\"line\">blocking_lock_id：某一事务的锁的 ID，该事务阻塞了另一事务的运行。可以和 INNODB_LOCKS 表 <span class=\"keyword\">JOIN</span>。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>直接查看 innodb_lock_waits 表</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> innodb_lock_waits;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>innodb_locks 表和 innodb_lock_waits 表结合：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> innodb_locks <span class=\"keyword\">WHERE</span> lock_trx_id <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> blocking_trx_id <span class=\"keyword\">FROM</span> innodb_lock_waits);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>innodb_locks 表 JOIN innodb_lock_waits 表:</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> innodb_locks.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> innodb_locks <span class=\"keyword\">JOIN</span> innodb_lock_waits <span class=\"keyword\">ON</span> (innodb_locks.lock_trx_id <span class=\"operator\">=</span> innodb_lock_waits.blocking_trx_id);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询 innodb_trx 表:</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> trx_id, trx_requested_lock_id, trx_mysql_thread_id, trx_query <span class=\"keyword\">FROM</span> innodb_trx <span class=\"keyword\">WHERE</span> trx_state <span class=\"operator\">=</span> <span class=\"string\">&#x27;LOCK WAIT&#x27;</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>trx_mysql_thread_id 即kill掉事务线程 ID</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> ENGINE INNODB STATUS ;</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> PROCESSLIST ;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>从上述方法中得到了相关信息，我们可以得到发生锁等待的线程 ID，然后将其 KILL 掉。 KILL 掉发生锁等待的线程。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill ID;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","text":"MySql Lock wait timeout exceededMysql造成锁的情况有很多，下面我们就列举一些情况： 执行DML操作没有commit，再执行删...","permalink":"/post/MIDDLEWARE/MySql Lock wait timeout exceeded","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"innodb","slug":"innodb","count":1,"path":"api/categories/innodb.json"},{"name":"MIDDLEWARE","slug":"innodb/MIDDLEWARE","count":1,"path":"api/categories/innodb/MIDDLEWARE.json"}],"tags":[{"name":"wait","slug":"wait","count":1,"path":"api/tags/wait.json"},{"name":"timeout","slug":"timeout","count":1,"path":"api/tags/timeout.json"},{"name":"lock","slug":"lock","count":1,"path":"api/tags/lock.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySql-Lock-wait-timeout-exceeded\"><span class=\"toc-text\">MySql Lock wait timeout exceeded</span></a></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"tcpdump在启用TCP卸载功能的网卡上报告 checksum error ·","uid":"1bb022f0a90cc114ad2400e87144dac4","slug":"LINUX/tcpdump在启用TCP卸载功能的网卡上报告 checksum error ·","date":"2023-06-08T12:39:56.000Z","updated":"2025-12-05T01:47:10.770Z","comments":true,"path":"api/articles/LINUX/tcpdump在启用TCP卸载功能的网卡上报告 checksum error ·.json","keywords":"XuGuangSheng","cover":"/covers/tcpdumptcp-checksum-error.jpg","text":"tcpdump在启用TCP卸载功能的网卡上报告”checksum error” ·在使用tcpdump对网卡进行抓包的时，很多时候会发现有cksum incor...","permalink":"/post/LINUX/tcpdump在启用TCP卸载功能的网卡上报告 checksum error ·","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"TCP","slug":"TCP","count":3,"path":"api/categories/TCP.json"},{"name":"LINUX","slug":"TCP/LINUX","count":1,"path":"api/categories/TCP/LINUX.json"}],"tags":[{"name":"checksum","slug":"checksum","count":1,"path":"api/tags/checksum.json"},{"name":"offloading","slug":"offloading","count":1,"path":"api/tags/offloading.json"},{"name":"offload","slug":"offload","count":1,"path":"api/tags/offload.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Shiro中多Realm下抛出异常不准确","uid":"923091e5afde124d5b66314a0b825fb8","slug":"JAVA/Shiro中多Realm下抛出异常不准确","date":"2023-05-12T15:13:14.000Z","updated":"2025-12-05T01:46:29.796Z","comments":true,"path":"api/articles/JAVA/Shiro中多Realm下抛出异常不准确.json","keywords":"XuGuangSheng","cover":"/covers/shirorealm.jpg","text":"Shiro中多Realm下抛出异常不准确如果你的项目中存在多个Realm，当你在Realm中判断账号异常抛出了一个UnknownAccountException...","permalink":"/post/JAVA/Shiro中多Realm下抛出异常不准确","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"Realm","slug":"Realm","count":1,"path":"api/categories/Realm.json"},{"name":"JAVA","slug":"Realm/JAVA","count":1,"path":"api/categories/Realm/JAVA.json"}],"tags":[{"name":"FormAuthenticationFilter","slug":"FormAuthenticationFilter","count":1,"path":"api/tags/FormAuthenticationFilter.json"},{"name":"onLoginFailure","slug":"onLoginFailure","count":1,"path":"api/tags/onLoginFailure.json"},{"name":"doMultiRealmAuthentication","slug":"doMultiRealmAuthentication","count":1,"path":"api/tags/doMultiRealmAuthentication.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}