{"title":"Nginx gzip参数详解及常见问题","uid":"a03cc162cee41bf570dc5f1147b3943c","slug":"MIDDLEWARE/Nginx gzip参数详解及常见问题","date":"2021-08-16T16:16:06.000Z","updated":"2025-12-05T01:47:33.397Z","comments":true,"path":"api/articles/MIDDLEWARE/Nginx gzip参数详解及常见问题.json","keywords":"XuGuangSheng","cover":"/covers/nginx-gzip.jpg","content":"<h1 id=\"Nginx-gzip参数详解及常见问题\"><a href=\"#Nginx-gzip参数详解及常见问题\" class=\"headerlink\" title=\"Nginx gzip参数详解及常见问题\"></a>Nginx gzip参数详解及常见问题</h1><h2 id=\"1、Nginx-gzip-功能\"><a href=\"#1、Nginx-gzip-功能\" class=\"headerlink\" title=\"1、Nginx gzip 功能\"></a>1、Nginx gzip 功能</h2><p>Nginx 实现资源压缩的原理是通过 ngx_http_gzip_module 模块拦截请求，并对需要做 gzip 的类型做 gzip，ngx_http_gzip_module 是 Nginx 默认集成的，<strong>不需要重新编译，直接开启即可</strong>。</p>\n<h2 id=\"2、参数详解\"><a href=\"#2、参数详解\" class=\"headerlink\" title=\"2、参数详解\"></a>2、参数详解</h2><h3 id=\"gzip-on\"><a href=\"#gzip-on\" class=\"headerlink\" title=\"gzip on\"></a>gzip on</h3><p>这个没的说，打开或关闭 gzip</p>\n<h3 id=\"gzip-buffers\"><a href=\"#gzip-buffers\" class=\"headerlink\" title=\"gzip_buffers\"></a><strong>gzip_buffers</strong></h3><p>设置用于处理请求压缩的缓冲区数量和大小。比如 32 4K 表示按照内存页（one memory page）大小以 4K 为单位（即一个系统中内存页为 4K），申请 32 倍的内存空间。建议此项不设置，使用默认值。</p>\n<h3 id=\"gzip-comp-level\"><a href=\"#gzip-comp-level\" class=\"headerlink\" title=\"gzip_comp_level\"></a><strong>gzip_comp_level</strong></h3><p>设置 gzip 压缩级别，级别越底压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大</p>\n<p>我们以一个大小为 92.6K 的脚本文件为例，如下所示。其中最后三个数值分别表示压缩比、包大小、平均处理时间（使用 ab 压测，100 用户并发下， <code>./ab -n 10000 -c 100 -H &#39;Accept-Encoding: gzip&#39; http://10.27.180.75/jquery.js</code> ）以及 CPU 消耗。</p>\n<p>从这我们可以得出结论：</p>\n<ul>\n<li>随着压缩级别的升高，压缩比有所提高，但到了级别 6 后，很难再提高；</li>\n<li>随着压缩级别的升高，处理时间明显变慢;</li>\n<li>gzip 很消耗 cpu 的性能，高并发情况下 cpu 达到 100%;</li>\n</ul>\n<p>因此，建议：</p>\n<ul>\n<li>不是压缩级别越高越好，其实 gzip_comp_level 1 的压缩能力已经够用了，后面级别越高，压缩的比例其实增长不大，反而很吃处理性能。</li>\n<li>压缩一定要和静态资源缓存相结合，缓存压缩后的版本，否则每次都压缩高负载下服务器肯定吃不住。</li>\n</ul>\n<h3 id=\"gzip-disable\"><a href=\"#gzip-disable\" class=\"headerlink\" title=\"gzip_disable\"></a><strong>gzip_disable</strong></h3><p>通过表达式，表明哪些 UA 头不使用 gzip 压缩</p>\n<h3 id=\"gzip-min-length\"><a href=\"#gzip-min-length\" class=\"headerlink\" title=\"gzip_min_length\"></a><strong>gzip_min_length</strong></h3><p>当返回内容大于此值时才会使用 gzip 进行压缩, 以 K 为单位, 当值为 0 时，所有页面都进行压缩。</p>\n<h3 id=\"gzip-http-version\"><a href=\"#gzip-http-version\" class=\"headerlink\" title=\"gzip_http_version\"></a><strong>gzip_http_version</strong></h3><p>用于识别 http 协议的版本，早期的浏览器不支持 gzip 压缩，用户会看到乱码，所以为了支持前期版本加了此选项。默认在 http&#x2F;1.0 的协议下不开启 gzip 压缩。</p>\n<p>因为浏览器基本上都支持 HTTP&#x2F;1.1。然而这里面却存在着一个很容易掉入的坑，也是笔者从生产环境中一个诡异问题中发现的：</p>\n<p><strong>明明开启 gzip 功能，但是未生效。</strong> </p>\n<p><strong>原因定位：</strong> 为什么这样呢？<br>在应用服务器前，公司还有一层 Nginx 的集群作为七层负责均衡，在这一层上，是没有开启 gzip 的。</p>\n<p>如果我们使用了 proxy_pass 进行反向代理，那么 nginx 和后端的 upstream server 之间默认是用 HTTP&#x2F;1.0 协议通信的。<br>如果我们的 Cache Server 也是 nginx，而前端的 nginx 没有开启 gzip。<br>同时，我们后端的 nginx 上没有设置 gzip_http_version 为 1.0，那么 Cache 的 url 将不会进行 gzip 压缩。</p>\n<p><strong><a href=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/c39c2f21cf5872b68fbf6160c06a7ae2.png\"><img src=\"https://raw.githubusercontent.com/dandeliono/img/main/resource/c39c2f21cf5872b68fbf6160c06a7ae2.png\">\n</a></strong></p>\n<p>我相信，以后还有人会入坑，比如你用 Apache ab 做压测，如果不是设置 gzip_http_version 为 1.0，你也压不出 gzip 的效果（同样的道理）。希望写在这里对大家有帮助</p>\n<h3 id=\"gzip-proxied\"><a href=\"#gzip-proxied\" class=\"headerlink\" title=\"gzip_proxied\"></a><strong>gzip_proxied</strong></h3><p>Nginx 做为反向代理的时候启用：</p>\n<ul>\n<li>off – 关闭所有的代理结果数据压缩</li>\n<li>expired – 如果 header 中包含”Expires” 头信息，启用压缩</li>\n<li>no-cache – 如果 header 中包含”Cache-Control:no-cache” 头信息，启用压缩</li>\n<li>no-store – 如果 header 中包含”Cache-Control:no-store” 头信息，启用压缩</li>\n<li>private – 如果 header 中包含”Cache-Control:private” 头信息，启用压缩</li>\n<li>no_last_modified – 启用压缩，如果 header 中包含”Last_Modified” 头信息，启用压缩</li>\n<li>no_etag – 启用压缩，如果 header 中包含 “ETag” 头信息，启用压缩</li>\n<li>auth – 启用压缩，如果 header 中包含 “Authorization” 头信息，启用压缩</li>\n<li>any – 无条件压缩所有结果数据</li>\n</ul>\n<h3 id=\"gzip-vary\"><a href=\"#gzip-vary\" class=\"headerlink\" title=\"gzip_vary\"></a><strong>gzip_vary</strong></h3><p>增加响应头”Vary: Accept-Encoding”</p>\n<h3 id=\"gzip-types\"><a href=\"#gzip-types\" class=\"headerlink\" title=\"gzip_types\"></a><strong>gzip_types</strong></h3><p>设置需要压缩的 MIME 类型, 如果不在设置类型范围内的请求不进行压缩</p>\n<p><a href=\"https://www.darrenfang.com/2015/01/setting-up-http-cache-and-gzip-with-nginx/\">参考文章</a></p>\n<p>所以 MIME-TYPE 中应该新增字体类型：</p>\n<p>| 字体类型扩展名 | Content-type |<br>| .eot | application&#x2F;vnd.ms-fontobject |<br>| .ttf | font&#x2F;ttf |<br>| .otf | font&#x2F;opentype |<br>| .woff | font&#x2F;x-woff |<br>| .svg | image&#x2F;svg+xml |</p>\n","text":"Nginx gzip参数详解及常见问题1、Nginx gzip 功能Nginx 实现资源压缩的原理是通过 ngx_http_gzip_module 模块拦截请求...","permalink":"/post/MIDDLEWARE/Nginx gzip参数详解及常见问题","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"gzip","slug":"gzip","count":1,"path":"api/categories/gzip.json"},{"name":"MIDDLEWARE","slug":"gzip/MIDDLEWARE","count":1,"path":"api/categories/gzip/MIDDLEWARE.json"}],"tags":[{"name":"如果","slug":"如果","count":2,"path":"api/tags/如果.json"},{"name":"http","slug":"http","count":6,"path":"api/tags/http.json"},{"name":"启用压缩","slug":"启用压缩","count":1,"path":"api/tags/启用压缩.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Nginx-gzip%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">Nginx gzip参数详解及常见问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81Nginx-gzip-%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">1、Nginx gzip 功能</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">2、参数详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gzip-on\"><span class=\"toc-text\">gzip on</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gzip-buffers\"><span class=\"toc-text\">gzip_buffers</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gzip-comp-level\"><span class=\"toc-text\">gzip_comp_level</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gzip-disable\"><span class=\"toc-text\">gzip_disable</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gzip-min-length\"><span class=\"toc-text\">gzip_min_length</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gzip-http-version\"><span class=\"toc-text\">gzip_http_version</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gzip-proxied\"><span class=\"toc-text\">gzip_proxied</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gzip-vary\"><span class=\"toc-text\">gzip_vary</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gzip-types\"><span class=\"toc-text\">gzip_types</span></a></li></ol></li></ol></li></ol>","author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"ThreadLocal系列（一）-ThreadLocal的使用及原理解析","uid":"55a6aea8b4cb4859de314d4babde9ef4","slug":"JAVA/ThreadLocal系列（一）-ThreadLocal的使用及原理解析","date":"2021-08-16T16:17:55.000Z","updated":"2025-12-05T01:46:38.516Z","comments":true,"path":"api/articles/JAVA/ThreadLocal系列（一）-ThreadLocal的使用及原理解析.json","keywords":"XuGuangSheng","cover":"/covers/threadlocal-threadlocal.jpg","text":"ThreadLocal系列（一）-ThreadLocal的使用及原理解析一、基本使用先来看下基本用法： 123456789101112131415 privat...","permalink":"/post/JAVA/ThreadLocal系列（一）-ThreadLocal的使用及原理解析","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"set","slug":"set","count":1,"path":"api/categories/set.json"},{"name":"JAVA","slug":"set/JAVA","count":1,"path":"api/categories/set/JAVA.json"}],"tags":[{"name":"Thread","slug":"Thread","count":1,"path":"api/tags/Thread.json"},{"name":"ThreadLocalMap","slug":"ThreadLocalMap","count":1,"path":"api/tags/ThreadLocalMap.json"},{"name":"ThreadLocal","slug":"ThreadLocal","count":1,"path":"api/tags/ThreadLocal.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java内存访问重排序的研究","uid":"db9816c4607e7d8e795e08923e1430dc","slug":"JAVA/Java内存访问重排序的研究","date":"2021-08-15T23:36:56.000Z","updated":"2025-12-05T01:46:22.607Z","comments":true,"path":"api/articles/JAVA/Java内存访问重排序的研究.json","keywords":"XuGuangSheng","cover":"/covers/java.jpg","text":"Java内存访问重排序的研究什么是重排序请先看这样一段代码： 12345678910111213141516171819202122public class P...","permalink":"/post/JAVA/Java内存访问重排序的研究","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"Java","slug":"Java","count":1,"path":"api/categories/Java.json"},{"name":"JAVA","slug":"Java/JAVA","count":1,"path":"api/categories/Java/JAVA.json"}],"tags":[{"name":"com","slug":"com","count":26,"path":"api/tags/com.json"},{"name":"volatile","slug":"volatile","count":2,"path":"api/tags/volatile.json"},{"name":"before","slug":"before","count":1,"path":"api/tags/before.json"}],"author":{"name":"dandeliono","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/29496357","link":"/","description":"永远相信美好的事情即将发生","socials":{"github":"https://github.com/dandeliono","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}