# 从Java多线程可见性谈Happens-Before原则 
Happens-Before 是一个非常抽象的概念，然而它又是学习 Java 并发编程不可跨域的部分。本文会先阐述 Happens-Before 在并发编程中解决的问题——_多线程可见性_，然后再详细讲解 Happens-Before 原则本身。

## Java 多线程可见性

在现代操作系统上编写并发程序时，除了要注意线程安全性 (多个线程互斥访问临界资源) 以外，还要注意多线程对共享变量的可见性，而后者往往容易被人忽略。  
可见性是指当一个线程修改了共享变量的值，其它线程能够适时得知这个修改。在单线程环境中，如果在程序前面修改了某个变量的值，后面的程序一定会读取到那个变量的新值。这看起来很自然，然而当变量的写操作和读操作在不同的线程中时，情况却并非如此。

    public class NoVisibility {
        private static boolean ready; 
        private static int number;
        
        private static class ReaderThread extends Thread {
            public void run() {
                while(!ready) {
                    Thread.yield();
                }
                System.out.println(number);
            }
        }
        
        public static void main(String\[\] args) {
            new ReaderThread().start(); 
            number = 42;
            ready = true;
        }
    }

上面的代码中，主线程和读线程都访问共享变量 ready 和 number。程序看起来会输出 42，但事实上很可能会输出 0，或者根本无法终止。这是因为上面的程序缺少_线程间变量可见性_的保证，所以在主线程中写入的变量值，可能无法被读线程感知到。

## 为什么会出现线程可见性问题

要想解释_为什么会出现线程可见性问题_，需要从计算机处理器结构谈起。我们都知道计算机运算任务需要 CPU 和内存相互配合共同完成，其中 CPU 负责逻辑计算，内存负责数据存储。CPU 要与内存进行交互，如读取运算数据、存储运算结果等。由于内存和 CPU 的计算速度有几个数量级的差距，为了提高 CPU 的利用率，现代处理器结构都加入了一层读写速度尽可能接近 CPU 运算速度的高速缓存来作为内存与 CPU 之间的缓冲：将运算需要使用的数据复制到缓存中，让 CPU 运算可以快速进行，计算结束后再将计算结果从缓存同步到主内存中，这样处理器就无须等待缓慢的内存读写了。  
高速缓存的引入解决了 CPU 和内存之间速度的矛盾，但是在多 CPU 系统中也带来了新的问题：缓存一致性。在多 CPU 系统中，每个 CPU 都有自己的高速缓存，所有的 CPU 又共享同一个主内存。如果多个 CPU 的运算任务都涉及到主内存中同一个变量时，那同步回主内存时以哪个 CPU 的缓存数据为准呢？这就需要各个 CPU 在数据读写时都遵循同一个协议进行操作。  
![](https://github.com/dandeliono/dandeliono.github.io/blob/master/source/_posts/resources/2021-8-16%2016-24-44/8803d290-1069-49cc-bdf9-8de55fedd69e.jpeg?raw=true)

参考上图，假设有两个线程 A、B 分别在两个不同的 CPU 上运行，它们共享同一个变量 X。如果线程 A 对 X 进行修改后，并没有将 X 更新后的结果同步到主内存，则变量 X 的修改对 B 线程是不可见的。所以 CPU 与内存之间的高速缓存就是导致_线程可见性问题_的一个原因。  
CPU 和主内存之间的高速缓存还会导致另一个问题——**重排序**。假设 A、B 两个线程共享两个变量 X、Y，A 和 B 分别在不同的 CPU 上运行。在 A 中先更改变量 X 的值，然后再更改变量 Y 的值。这时有可能发生 Y 的值被同步回主内存，而 X 的值没有同步回主内存的情况，此时对于 B 线程来说是无法感知到 X 变量被修改的，或者可以认为对于 B 线程来说，Y 变量的修改被重排序到了 X 变量修改的前面。上面的程序 NoVisibility 类中有可能输出 0 就是这种情况，虽然在主线程中是先修改 number 变量，再修改 ready 变量，但对于读线程来说，ready 变量的修改有可能被重排序到 number 变量修改之前。  
此外，为了提高程序的执行效率，编译器在生成指令序列时和 CPU 执行指令序列时，都有可能对指令进行重排序。_Java 语言规范_要求 JVM 只在单个线程内部维护一种**类似**串行的语义，即只要程序的最终结果与严格串行环境中执行的结果相同即可。所以在单线程环境中，我们无法察觉到重排序，因为程序重排序后的执行结果与严格按顺序执行的结果相同。就像在类 NoVisibility 的主线程中，先修改 ready 变量还是先修改 number 变量对于主线程自己的执行结果是没有影响的，但是如果 number 变量和 ready 变量的修改发生重排序，对读线程是有影响的。所以在编写并发程序时，我们一定要注意重排序对多线程执行结果的影响。  
看到这里大家一定会发现，我们所讨论的 CPU 高速缓存、指令重排序等内容都是计算机体系结构方面的东西，并不是 Java 语言所特有的。事实上，很多主流程序语言 (如 C/C++) 都存在_多线程可见性_的问题，这些语言是借助物理硬件和操作系统的内存模型来处理_多线程可见性_问题的，因此不同平台上内存模型的差异，会影响到程序的执行结果。Java 虚拟机规范定义了自己的内存模型 JMM(Java Memory Model) 来屏蔽掉不同硬件和操作系统的内存模型差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问结果。所以对于 Java 程序员，无需了解底层硬件和操作系统内存模型的知识，只要关注 Java 自己的内存模型，就能够解决 Java 语言中的内存可见性问题了。

## Happens-Before 原则

上面讨论了 Java 中多线程共享变量的可见性问题及产生这种问题的原因。下面我们看一下如何解决这个问题，即当一个多线程共享变量被某个线程修改后，如何让这个修改被需要读取这个变量的线程感知到。  
为了方便程序员开发，将底层的烦琐细节屏蔽掉，JMM 定义了 Happens-Before 原则。只要我们理解了 Happens-Before 原则，无需了解 JVM 底层的内存操作，就可以解决在并发编程中遇到的变量可见性问题。  
JVM 定义的 Happens-Before 原则是一组偏序关系：**对于两个操作 A 和 B，这两个操作可以在不同的线程中执行。如果 A Happens-Before B，那么可以保证，当 A 操作执行完后，A 操作的执行结果对 B 操作是可见的。**  
Happens-Before 的规则包括：

1.  程序顺序规则
2.  锁定规则
3.  volatile 变量规则
4.  线程启动规则
5.  线程结束规则
6.  中断规则
7.  终结器规则
8.  传递性规则

下面我们将详细讲述这 8 条规则的具体内容。

## 程序顺序规则

在一个线程内部，按照程序代码的**书写**顺序，书写在前面的代码操作 Happens-Before 书写在后面的代码操作。这时因为_Java 语言规范_要求 JVM 在单个线程内部要维护类似严格串行的语义，如果多个操作之间有先后依赖关系，则不允许对这些操作进行重排序。

## 锁定规则

对锁 M 解锁之前的**所有**操作 Happens-Before 对锁 M 加锁之后的**所有**操作。

    class HappensBeforeLock {
        private int value = 0;
        
        public synchronized void setValue(int value) {
            this.value = value;
        }
        
        public synchronized int getValue() {
            return value;
        }
    }

上面这段代码，setValue 和 getValue 两个方法共享同一个监视器锁。假设 setValue 方法在线程 A 中执行，getValue 方法在线程 B 中执行。setValue 方法会先对 value 变量赋值，然后释放锁。getValue 方法会先获取到同一个锁后，再读取 value 的值。所以根据锁定原则，线程 A 中对 value 变量的修改，可以被线程 B 感知到。  
如果这个两个方法上没有 synchronized 声明，则在线程 A 中执行 setValue 方法对 value 赋值后，线程 B 中 getValue 方法返回的 value 值并不能保证是最新值。  
本条锁定规则对显示锁 (ReentrantLock) 和内置锁 (synchronized) 在加锁和解锁等操作上有着相同的内存语义。  
对于锁定原则，可以像下面这样去理解：同一时刻只能有一个线程执行锁中的操作，所以锁中的操作被重排序外界是**不关心**的，只要最终结果能被外界感知到就好。除了重排序，剩下影响变量可见性的就是 CPU 缓存了。在锁被释放时，A 线程会把释放锁之前所有的操作结果同步到主内存中，而在获取锁时，B 线程会使自己 CPU 的缓存失效，重新从主内存中读取变量的值。这样，A 线程中的操作结果就会被 B 线程感知到了。

## volatile 变量规则

对一个 volatile 变量的写操作及这个写操作之前的所有操作 Happens-Before 对这个变量的读操作及这个读操作之后的所有操作。

    Map configOptions;
    char\[\] configText; 

    volatile boolean initialized = false;



    configText = readConfigFile(fileName);
    processConfigOptions(configText, configOptions);
    initialized = true;

    while (!initialized) {    
        sleep();
    }

    doSomethingWithConfig();

上面这段代码，读取配置文件的操作和使用配置信息的操作分别在两个不同的线程 A、B 中执行，两个线程通过共享变量 configOptions 传递配置信息，并通过共享变量 initialized 作为初始化是否完成的通知。initialized 变量被声明为 volatile 类型的，根据 volatile 变量规则，volatile 变量的写入操作 Happens-Before 对这个变量的读操作，所以在线程 A 中将变量 initialized 设为 true，线程 B 中是可以感知到这个修改操作的。  
但是更牛逼的是，volatile 变量不仅可以保证自己的变量可见性，还能保证**书写**在 volatile 变量写操作之前的操作对其它线程的可见性。考虑这样一种情况，如果 volatile 变量仅能保证自己的变量可见性，那么当线程 B 感知到 initialized 已经变成 true 然后执行 doSomethingWithConfig 操作时，可能无法获取到 configOptions 最新值而导致操作结果错误。所以 volatile 变量不仅可以保证自己的变量可见性，还能保证书写在 volatile 变量写操作之前的操作 Happens-Before 书写在 volatile 变量读操作之后的那些操作。  
可以这样理解 volatile 变量的写入和读取操作流程：  
首先，volatile 变量的操作会禁止与其它普通变量的操作进行重排序，例如上面代码中会禁止 initialized = true 与它上面的两行代码进行重排序 (但是它上面的代码之间是可以重排序的)，否则会导致程序结果错误。volatile 变量的写操作就像是一条基准线，到达这条线之后，不管之前的代码有没有重排序，反正到达这条线之后，前面的操作都已完成并生成好结果。  
然后，在 volatile 变量写操作发生后，A 线程会把 volatile 变量本身和书写在它之前的那些操作的执行结果一起同步到主内存中。  
最后，当 B 线程读取 volatile 变量时，B 线程会使自己的 CPU 缓存失效，重新从主内存读取所需变量的值，这样无论是 volatile 本身，还是书写在 volatile 变量写操作之前的那些操作结果，都能让 B 线程感知到，也就是上面程序中的 initialized 和 configOptions 变量的最新值都可以让线程 B 感知到。  
原子变量与 volatile 变量在读操作和写操作上有着相同的语义。

## 线程启动规则

Thread 对象的 start 方法及**书写**在 start 方法前面的代码操作 Happens-Before 此线程的每一个动作。  
start 方法和新线程中的动作一定是在两个不同的线程中执行。_线程启动规则_可以这样去理解：调用 start 方法时，会将 start 方法之前所有操作的结果同步到主内存中，新线程创建好后，需要从主内存获取数据。这样在 start 方法调用之前的所有操作结果对于新创建的线程都是可见的。

## 线程终止规则

线程中的任何操作都 Happens-Before 其它线程检测到该线程已经结束。这个说法有些抽象，下面举例子对其进行说明。  
假设两个线程 s、t。在线程 s 中调用 t.join() 方法。则线程 s 会被挂起，等待 t 线程运行结束才能恢复执行。当 t.join() 成功返回时，s 线程就知道 t 线程已经结束了。所以根据本条原则，在 t 线程中对共享变量的修改，对 s 线程都是可见的。类似的还有 Thread.isAlive 方法也可以检测到一个线程是否结束。  
可以猜测，当一个线程结束时，会把自己所有操作的结果都同步到主内存。而任何其它线程当发现这个线程已经执行结束了，就会从主内存中重新刷新最新的变量值。所以结束的线程 A 对共享变量的修改，对于其它检测了 A 线程是否结束的线程是可见的。

## 中断规则

一个线程在另一个线程上调用 interrupt,Happens-Before 被中断线程检测到 interrupt 被调用。  
假设两个线程 A 和 B，A 先做了一些操作 operationA，然后调用 B 线程的 interrupt 方法。当 B 线程感知到自己的中断标识被设置时 (通过抛出 InterruptedException，或调用 interrupted 和 isInterrupted),operationA 中的操作结果对 B 都是可见的。

## 终结器规则

一个对象的构造函数执行结束 Happens-Before 它的 finalize() 方法的开始。  
“结束”和 “开始” 表明在时间上，一个对象的构造函数必须在它的 finalize()方法调用时执行完。  
根据这条原则，可以确保在对象的 finalize 方法执行时，该对象的所有 field 字段值都是可见的。

## 传递性规则

如果操作 A Happens-Before B，B Happens-Before C，那么可以得出操作 A Happens-Before C。

## 再次思考 Happens-Before 规则的真正意义

到这里我们已经讨论了线程的可见性问题和导致这个问题的原因，并详细阐述了 8 条 Happens-Before 原则和它们是如何帮助我们解决变量可见性问题的。下面我们在深入思考一下，Happens-Before 原则到底是如何解决变量间可见性问题的。  
我们已经知道，导致多线程间可见性问题的两个 “罪魁祸首” 是_CPU 缓存_和_重排序_。那么如果要保证多个线程间共享的变量对每个线程都及时可见，一种极端的做法就是禁止使用所有的重排序和 CPU 缓存。即关闭所有的编译器、操作系统和处理器的优化，所有指令顺序全部按照程序代码书写的顺序执行。去掉 CPU 高速缓存，让 CPU 的每次读写操作都直接与主存交互。  
当然，上面的这种极端方案是绝对不可取的，因为这会极大影响处理器的计算性能，并且对于那些非多线程共享的变量是不公平的。  
_重排序_和_CPU 高速缓存_有利于计算机性能的提高，但却对多 CPU 处理的一致性带来了影响。为了解决这个矛盾，我们可以采取一种折中的办法。我们用分割线把整个程序划分成几个程序块，在每个程序块内部的指令是可以重排序的，但是分割线上的指令与程序块的其它指令之间是不可以重排序的。在一个程序块内部，CPU 不用每次都与主内存进行交互，只需要在 CPU 缓存中执行读写操作即可，但是当程序执行到分割线处，CPU 必须将执行结果同步到主内存或从主内存读取最新的变量值。那么，Happens-Before 规则就是定义了这些程序块的分割线。下图展示了一个使用_锁定原则_作为分割线的例子：  
![](https://github.com/dandeliono/dandeliono.github.io/blob/master/source/_posts/resources/2021-8-16%2016-24-44/9c725cbb-3b8d-4f81-a943-7ada54b361cc.jpeg?raw=true)

如图所示，这里的 unlock M 和 lock M 就是划分程序的分割线。在这里，红色区域和绿色区域的代码内部是可以进行重排序的，但是 unlock 和 lock 操作是不能与它们进行重排序的。即第一个图中的红色部分必须要在 unlock M 指令之前全部执行完，第二个图中的绿色部分必须全部在 lock M 指令之后执行。并且在第一个图中的 unlock M 指令处，红色部分的执行结果要全部刷新到主存中，在第二个图中的 lock M 指令处，绿色部分用到的变量都要从主存中重新读取。  
在程序中加入分割线将其划分成多个程序块，虽然在程序块内部代码仍然可能被重排序，但是保证了程序代码在宏观上是有序的。并且可以确保在分割线处，CPU 一定会和主内存进行交互。Happens-Before 原则就是定义了程序中什么样的代码可以作为分隔线。并且无论是哪条 Happens-Before 原则，它们所产生分割线的作用都是相同的。

## 小结

在写作本文时，我主要参考的是《Java 并发编程实战》和《深入理解 Java 虚拟机》的最后一章，此外有部分内容是我自己对并发编程的一些浅薄理解，希望能够对阅读的人有所帮助。如有错误的地方，欢迎大家指正。 
 [https://segmentfault.com/a/1190000011458941](https://segmentfault.com/a/1190000011458941)
